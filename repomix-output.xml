This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.eslintignore
.gitignore
工具操作經驗總結.md
待改善2025.10.20.txt
待實作.txt
特價優先處理功能更新說明.txt
單價計算.txt
新增卡片備份.txt
圖片裁剪範圍一致性說明.txt
價格優先處理功能說明.txt
模擬圖片功能說明.txt
歷史價格與折線.txt
擷取畫面顯示功能說明.txt
鏡頭權限.txt
AI辨識參考.txt
COLLABORATION_POLICY.md
ESLINT_CHECK_REQUIREMENT.md
Firebase.txt
GEMINI.md
Github netlify.txt
netlify.toml
netlify/functions/gemini-proxy.js
package.json
public/士力架.png
public/index.html
README_ERROR_HANDLING.md
README.md
requirements_changes.md
src/AllRecordsPage.js
src/App.css
src/App.js
src/components/AIOcrCaptureModal.js
src/components/AIOcrCaptureModal備份
src/components/components.xml
src/components/DataManagement.js
src/components/SettingsPage.js
src/firebase-config.js
src/index.css
src/index.js
src/OcrQueuePage.js
src/src.xml
src/StoreSelector.js
src/utils/errorHandler.js
src/utils/errorHandler.test.js
src/utils/priceCalculations.js
tailwind.config.js
tool_usage_notes.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="工具操作經驗總結.md">
# 工具操作經驗總結：處理 replace 工具遞迴失敗

**日期：** 2025 年 10 月 20 日
**事件：** 在嘗試將 AllRecordsPage.js 檔案中的 setTimeout 延遲從 3000 毫秒更改為 2000 毫秒時，AI 模型陷入了多次 Editreplace 工具呼叫失敗的遞迴循環。

## 一、工具設計的嚴格要求 (AI 必須遵守的規則)

這是 `replace` 工具在設計上對參數的基礎要求。任何違反都將導致操作失敗。

1.  **完整的檔案內容：**
    *   **要求：** `old_string` 和 `new_string` 參數必須包含檔案的完整內容（從檔案頭到檔案尾）。
    *   **錯誤範例：** 僅提供程式碼片段（例如只提供 `showSuccessMessage` 函數）會導致失敗。

2.  **內容必須實質不同：**
    *   **要求：** `new_string` 必須在內容上與 `old_string` 存在差異。
    *   **錯誤範例：** 如果嘗試替換但最終傳遞了兩個完全相同的字串，工具會觸發安全機制而失敗。

3.  **清晰的指令 (Instruction)：**
    *   **要求：** 雖然不是工具失敗的直接原因，但指令（`instruction`）必須清晰，才能讓 AI 在建構複雜的 `new_string` 時做出正確的邏輯判斷。

## 二、實戰中導致遞迴失敗的根本原因

儘管 AI 意識到必須遵守上述規則 1 和 2，但在長檔案操作中，仍然難以打破循環，其根本原因在於 **"長字串的保真度 (Fidelity)"** 問題。

### 核心教訓：長字串的逐字元保真度極難維護

*   **問題描述：** 原始檔案可能長達數百行。當 AI 模型嘗試在記憶中建構一個完整的、修改後的 `new_string` 時，它必須確保這個新字串與原始檔案（除了目標變更點之外）在每個空白、換行符、縮排和註釋上都完全一致。
*   **失敗點：** 任何微小的、無意的字元差異（例如，AI 在重新生成時多了一個空行或少了一個縮排）都會導致 `replace` 工具的底層匹配邏輯失敗。

## 避免錯誤的最佳實踐

為避免未來在處理大型檔案的微小修改時陷入此類循環，我們應採取以下策略：

1.  **首選 File Generation 模式：**
    *   遇到長檔案且變更點明確時，應優先使用 **檔案生成 (File Generation Workflow)**，直接輸出完整的修正後檔案內容。這一步跳過了嚴格的 `replace` 工具比對。

2.  **本地精準替換 (若有機會)：**
    *   如果使用 `replace` 工具，應在確認 `old_string` 後，使用程式內部的字串替換邏輯 (`.replace()`) 精準地在 `old_string` 上進行修改，然後將結果作為 `new_string` 傳遞，而不是依賴 LLM 從頭生成一個長字串。

**目標：** 遵循此份總結，確保未來工具呼叫具備更高的可靠性與執行效率。
</file>

<file path="待改善2025.10.20.txt">
優化性能與邏輯：抽取單價計算函數 (單價計算.txt 參考)：javascript



function calculateUnitPrice(price, quantity, unitType) { const p = parseFloat(price); const q = parseFloat(quantity); if (isNaN(p) || isNaN(q) || q <= 0) return null; return (unitType === 'g' || unitType === 'ml') ? (p / q) * 100 : p / q;}



在 useEffect、handleAnalyze 等處呼叫。

合併 Firestore 查詢：在 saveAndComparePrice 中，先查 records，然後在新增後直接用本地陣列比價，減少一次讀取。

添加分頁：在 lookupProduct 與 AllRecordsPage 中，使用 Firestore 的 limit 與 startAfter 實作無限捲動。


1. 優化性能與邏輯：抽取單價計算函數
建議： 抽取 calculateUnitPrice 函數 (單價計算.txt 參考)，並在 useEffect、handleAnalyze 等處呼叫。

可行性與優勢： 極高。

單一職責原則 (SRP)： 將複雜的計算邏輯隔離，確保單價計算的規則（如公克/毫升需乘以 100 進行單位標準化）只存在於一個地方。

一致性： 確保無論是使用者手動輸入、AI 擷取分析 (handleAnalyze)，還是歷史數據處理 (useEffect 或其他組件)，單價計算邏輯都完全一致，從而避免數據不一致性錯誤。

測試性： 外部函數可以獨立於 React 組件進行單元測試，大幅簡化除錯和驗證流程。

需要注意的細節：

輸入解析： 您的函數已經包含 parseFloat(price) 和 parseFloat(quantity) 以及錯誤檢查 (isNaN(p) || isNaN(q) || q <= 0)，這點做得非常好，確保了函數的穩健性。

命名與位置： 建議將此函數放在一個通用的 utils 或 helpers 資料夾中，例如 utils/priceCalculations.js，以利於專案結構清晰。

2. 合併 Firestore 查詢（減少讀取次數）
建議： 在 saveAndComparePrice 中，先查詢歷史 records，然後在新增紀錄後直接用本地陣列比價，減少一次讀取。

可行性與優勢： 極高，這是數據庫操作優化的典範。

性能提升與成本節省： 減少一次 Firestore 讀取操作。在雲端資料庫中，讀取操作通常是產生費用的主要來源，減少一次讀取可以直接降低運行成本並提升延遲（Latency）。

邏輯效率： 比較邏輯需要將新記錄與所有舊記錄進行對比。只要在新增記錄前讀取舊記錄，新增後將新記錄物件添加到讀取的舊記錄陣列中，就可以在本地完成完整的比價流程，無需再次查詢資料庫。

需要注意的細節：

本地數據包含性： 實作時，必須確保本地比較的陣列中包含 1. 剛讀取的歷史紀錄 和 2. 剛成功寫入的新紀錄。

寫入確認： 由於是在寫入之後才進行本地比價，您需要確保資料庫寫入操作 (addDoc 或 setDoc) 成功完成後，再執行比價邏輯。

3. 添加分頁：使用 limit 與 startAfter 實作無限捲動
建議： 在 lookupProduct 與 AllRecordsPage 中，使用 Firestore 的 limit 與 startAfter 實作無限捲動。

可行性與優勢： 高。這是處理大型數據集（尤其在行動裝置上）的標準且必要的做法。

使用者體驗 (UX)： 無限捲動（或稱為延遲加載）消除了傳統分頁的點擊負擔，提供流暢的瀏覽體驗。

資源效率： 每次只加載固定數量的文件（例如 10 或 20 筆），大大減少了瀏覽器處理的數據量和首次加載時間。

Firestore 最佳實踐： limit 和 startAfter 是 Firestore 針對分頁推薦的官方方法（基於 Cursor 的分頁），效率極高。

需要注意的細節：

狀態管理複雜度： 您需要管理三個關鍵的 React 狀態：

records: 當前已加載的所有記錄列表。

lastVisible: 用於下一頁查詢的起始點（即上一頁的最後一個文件快照）。

isLoading / hasMore: 處理載入狀態和判斷是否已到達列表末尾。

排序依賴： startAfter 必須依賴一個固定的排序條件 (orderBy)。您需要確保所有分頁查詢都使用相同的排序規則（例如按時間戳記降序 timestamp, 'desc'）。

UI 呈現： 必須設計一個清晰的載入指示器（Loading Spinner），並在列表底部觸發新的查詢。
</file>

<file path="待實作.txt">
增加頁面可以指定區塊，區分品名、標價、單價以及分辨不同店家的設計

多張序列辨識功能實作

firebase實作


因為目前程式還在MVP測試階段，我想請你幫我先屏蔽firbase的相關功能，但是不要刪除任何程式，資料庫部分改由使用本機儲存，等待測試沒有問題後再開啟firebase串接，且請幫我在程式中柱記，以免其他開發者誤刪


單價計算與優惠處理：目前的比價僅基於標價。我們應該如何擴展數據模型來納入容量 (e.g., 500ml, 100g) 和優惠類型 (e.g., 買一送一)，以計算出真正的**「每單位最低價」**？

數據唯一性與雜湊 ID 衝突：我們使用 DJB2 雜湊算法從條碼字串生成數值 ID。雖然衝突機率低，但在處理數百萬個產品時，如何設計一個數據庫檢查機制來避免兩個不同條碼意外產生相同的數值 ID？

優化二維條碼 (QR Code, Data Matrix) 的支援：如何將 QuaggaJS (只支援一維條碼) 替換或增強為支援 QR Code 的函式庫，以實現對所有類型條碼的通用識別？

歷史價格趨勢分析：除了顯示最低價，如何增加功能，讓使用者能查看價格隨時間變動的圖表，以判斷當前是否為進場的最佳時機？
</file>

<file path="特價優先處理功能更新說明.txt">
特價優先處理功能更新說明
=====================

功能目標：
當辨識資料有特價和原價時，應優先在總價欄位填入特價價格

實作變更總結：

1. AI OCR 辨識功能增強：
   - 修改了 AI 分析的 JSON Schema，新增 originalPrice 和 specialPrice 欄位
   - 更新系統提示詞，明確指示當同時存在原價和特價時的處理方式
   - listedPrice 欄位現在會優先使用特價（如果存在）

2. 價格計算工具增強：
   - 新增 calculateFinalPrice 函數來處理價格優先邏輯
   - 當同時存在原價和特價時，優先使用特價進行計算

3. 資料處理邏輯：
   - 在 handleAiCaptureSuccess 函數中，優先使用 specialPrice 作為最終價格
   - 在 saveAndComparePrice 函數中，使用 calculateFinalPrice 函數確定最終價格
   - 在 useEffect 鉤子中，使用 calculateFinalPrice 函數進行即時價格計算
   - 保留 originalPrice 和 specialPrice 資訊以便後續顯示

4. UI 顯示優化：
   - 在 AI 辨識結果區塊顯示原價和特價信息
   - 在價格歷史記錄中以刪除線顯示原價，以突出顯示特價
   - 在所有記錄頁面中同樣顯示原價和特價信息
   - 原價以刪除線顯示，特價以醒目的顏色顯示

5. 編輯功能增強：
   - 在編輯模式中新增原價和特價的輸入欄位
   - 保持與新增記錄時一致的價格處理邏輯

6. 資料儲存：
   - originalPrice 和 specialPrice 資料會儲存到 Firebase 中
   - 確保所有價格計算和比價功能基於消費者實際支付的價格（特價優先）

測試方式：
1. 使用「模擬 AI 分析成功」功能測試特價處理
2. 實際上傳包含原價和特價的圖片進行測試
3. 檢查歷史價格記錄中的顯示效果
4. 測試編輯功能中的價格輸入
5. 確認價格趨勢圖基於正確的價格數據繪製

技術細節：
- specialPrice 和 originalPrice 資料會儲存到 Firebase 中
- 價格顯示會根據是否存在特價來動態調整樣式
- 所有計算仍然使用實際支付價格（特價優先）以確保比價準確性
- 新增的 calculateFinalPrice 工具函數確保價格優先邏輯的一致性
</file>

<file path="單價計算.txt">
import React, { useState, useEffect, useCallback } from 'react';

// 假設這些是您的主題顏色配置
const themeConfig = {
    'blue': { primary: 'indigo-600', hover: 'indigo-700', bg: 'indigo-50' },
    'red': { primary: 'red-600', hover: 'red-700', bg: 'red-50' },
    // ... 其他主題色
};

// 輔助函數：將 base64 轉換為 ArrayBuffer (用於 TTS - 儘管這裡未使用，但作為標準庫函數備著)
function base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

// 輔助函數：實現指數退避 (Exponential Backoff)
const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
        }
    }
};

const AIOcrCaptureModal = ({ theme, onAnalysisSuccess, onClose }) => {
    const [imageSrc, setImageSrc] = useState(null);
    const [base64Image, setBase64Image] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [resultData, setResultData] = useState(null);
    const [error, setError] = useState(null);

    const currentTheme = themeConfig[theme] || themeConfig['blue'];
    const apiKey = ""; // 保持空白，讓 Canvas 注入

    const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                setImageSrc(e.target.result);
                // 儲存 base64 字串供 API 使用
                const base64 = e.target.result.split(',')[1];
                setBase64Image(base64);
                setError(null);
                setResultData(null);
            };
            reader.readAsDataURL(file);
        }
    };

    const handleAnalyzeImage = useCallback(async () => {
        if (!base64Image) {
            setError("請先選擇一張包含價格或規格的圖片。");
            return;
        }

        setIsLoading(true);
        setError(null);
        setResultData(null);

        const userQuery = "請根據圖片中的標價、產品名稱和規格（質量/容量/數量），以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。";
        
        // 核心變更：定義新的 JSON Schema
        const newSchema = {
            type: "OBJECT",
            properties: {
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59）" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" }
            },
            propertyOrdering: ["productName", "listedPrice", "totalCapacity", "baseUnit"]
        };
        
        // 核心變更：定義嚴格的系統指令
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品名稱、標價以及完整的容量/質量/數量資訊，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: "image/jpeg",
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: newSchema
            }
        };

        try {
            const response = await withExponentialBackoff(async () => {
                const res = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) {
                    throw new Error(`API error: ${res.status} ${res.statusText}`);
                }
                return res.json();
            });

            const jsonText = response.candidates?.[0]?.content?.parts?.[0]?.text;
            if (jsonText) {
                const parsedJson = JSON.parse(jsonText);
                setResultData(parsedJson);

                // 計算並添加單價欄位
                const { listedPrice, totalCapacity, baseUnit } = parsedJson;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     // 假設我們以每 100g/ml 或每個為標準
                    if (baseUnit === 'g' || baseUnit === 'ml') {
                        // 價格 / (總容量 / 100) = 每 100 單位價格
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        // 價格 / 總數量 = 每個單價
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據，包含計算出的單價
                const finalData = {
                    ...parsedJson,
                    unitPrice: unitPrice,
                    standard: (baseUnit === 'g' || baseUnit === 'ml') ? `每 100${baseUnit}` : `每個`,
                    timestamp: Date.now(),
                    // 臨時數據：假設此處應有 storeName
                    storeName: '待定義店舖' 
                };

                onAnalysisSuccess(finalData);

            } else {
                setError("AI 分析失敗或未能返回有效的 JSON 數據。");
            }
        } catch (err) {
            console.error("API Call Failed:", err);
            setError(`分析過程中發生錯誤: ${err.message}`);
        } finally {
            setIsLoading(false);
        }
    }, [base64Image, onAnalysisSuccess]);

    useEffect(() => {
        // 在組件掛載時，確保 apiKey 存在
        if (!apiKey && typeof __initial_auth_token === 'undefined') {
            console.warn("API Key is missing. Check environment setup.");
        }
    }, [apiKey]);


    return (
        <div className="fixed inset-0 z-50 overflow-y-auto bg-gray-900 bg-opacity-75 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-xl p-6 transform transition-all">
                <h2 className={`text-2xl font-bold mb-4 text-${currentTheme.primary}`}>AI 視覺擷取與單價分析</h2>
                
                {/* 1. 圖片上傳區 */}
                <div className="mb-4">
                    <label className={`block text-sm font-medium text-gray-700 mb-2`}>
                        上傳產品照片 (含價格與規格)
                    </label>
                    <input 
                        type="file" 
                        accept="image/*" 
                        onChange={handleImageChange} 
                        className="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                    />
                </div>
                
                {/* 2. 圖片預覽區 */}
                {imageSrc && (
                    <div className="mb-4">
                        <h3 className="text-lg font-semibold mb-2">預覽圖片：</h3>
                        <div className="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-2">
                            <img src={imageSrc} alt="上傳預覽" className="max-w-full h-auto rounded-lg shadow-md" />
                        </div>
                    </div>
                )}
                
                {/* 3. 操作按鈕與狀態 */}
                <div className="flex justify-end space-x-3 mb-4">
                    <button 
                        onClick={onClose} 
                        className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-full hover:bg-gray-200 transition duration-150"
                        disabled={isLoading}
                    >
                        取消/關閉
                    </button>
                    <button 
                        onClick={handleAnalyzeImage} 
                        className={`px-6 py-2 text-sm font-semibold text-white bg-${currentTheme.primary} rounded-full shadow-md hover:bg-${currentTheme.hover} transition duration-150 flex items-center justify-center`}
                        disabled={isLoading || !base64Image}
                    >
                        {isLoading ? (
                             <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        ) : '開始分析'}
                    </button>
                </div>

                {/* 4. 結果顯示/錯誤區 */}
                {error && (
                    <div className={`p-3 rounded-lg bg-red-100 border border-red-400 text-red-700 text-sm mb-4`}>
                        錯誤: {error}
                    </div>
                )}

                {resultData && (
                    <div className={`p-4 rounded-lg bg-${currentTheme.bg} border border-${currentTheme.primary} mb-4`}>
                        <h3 className="text-lg font-semibold mb-2">分析結果：</h3>
                        <pre className="text-xs overflow-auto bg-white p-3 rounded-md border border-gray-300">
                            {JSON.stringify(resultData, null, 2)}
                        </pre>
                        <p className="text-sm mt-2 font-medium text-gray-700">
                            **結果已成功傳遞並計算單價！**
                            {/* 臨時展示計算結果 - 實際應在父組件處理 */}
                            <span className="block mt-1">
                                **單價標準:** {resultData.standard}
                                **計算單價:** ${resultData.unitPrice ? resultData.unitPrice.toFixed(2) : 'N/A'}
                            </span>
                        </p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default AIOcrCaptureModal;
</file>

<file path="新增卡片備份.txt">
深入分析與實作建議此功能的核心邏輯應實作於 src/App.js 中，因為它是管理 pendingOcrCards 狀態並新增卡片的地方。UI 呈現則在 src/OcrQueuePage.js 中完成。步驟 1：修改 src/App.js - 實作 Firebase 自動備份與狀態管理我們需要修改卡片資料結構以追蹤同步狀態，並在新增卡片時觸發非同步的 Firebase 寫入操作。受影響範圍： src/App.js數據結構變更： 在新增至 pendingOcrCards 的物件中，加入兩個新欄位：id: 用於在本地狀態中唯一識別卡片，便於後續更新同步狀態。syncStatus: 追蹤狀態，可為 'pending' (處理中), 'success' (成功), 或 'error' (失敗)。新增 Firebase 備份函式：建立一個新的非同步函式來處理寫入 Firebase 的邏輯。修改 handleQueueNextCapture 邏輯：在此函式中，先將卡片新增到本地狀態（設定為 'pending'），然後觸發備份，並根據備份結果更新本地狀態。src/App.js 程式碼建議修改處：首先，您需要確保在 src/App.js 中引入所需的 Firebase 函式：JavaScriptimport { db } from './firebase-config.js'; // 已在其他組件中引入
import { addDoc, collection, serverTimestamp, updateDoc, doc } from "firebase/firestore";
import { handleFirestoreSaveError } from './utils/errorHandler'; // 引入錯誤處理
import { v4 as uuidv4 } from 'uuid'; // 建議引入 uuid 函式庫來生成本地 ID
新增備份邏輯：在 App 函式元件內部，定義新的備份與狀態更新邏輯：JavaScript// ... 在 App() 函數內 ...

// 定義一個新的函式來處理 Firebase 備份
const backupOcrCardToFirebase = async (cardData) => {
    // 檢查 Firebase 是否準備好
    if (!isAuthReady || !userId) {
        // 由於功能要求是自動備份，若服務未準備好，則將其視為 pending 或 error (可選)
        console.warn("Firebase 服務尚未準備好，跳過備份。");
        // 由於此專案似乎有 MVP 階段屏蔽 Firebase 的歷史需求，
        // 這裡可以選擇將狀態設為 'error' 或保留 'pending'。
        // 為避免影響核心功能，建議在此處直接返回，讓卡片保持 'pending' 狀態。
        return;
    }

    const cardToSave = {
        ...cardData,
        userId: userId, // 儲存用戶 ID
        timestamp: serverTimestamp(), // 使用 Firebase 服務器時間戳
        // 移除本地 ID 和同步狀態，因為這些只用於本地 UI
        id: undefined, 
        syncStatus: undefined
    };

    try {
        // 將卡片數據儲存到 pendingOcrCards 集合
        const docRef = await addDoc(collection(db, "pendingOcrCards"), cardToSave);
        
        // 成功後更新本地狀態
        setPendingOcrCards(prevCards => 
            prevCards.map(c => 
                c.id === cardData.id ? { ...c, syncStatus: 'success', fbDocId: docRef.id } : c
            )
        );

    } catch (error) {
        console.error("Firebase 待辨識卡片備份失敗:", error);
        handleFirestoreSaveError(error, "備份待辨識卡片"); // 使用錯誤處理機制
        
        // 失敗後更新本地狀態
        setPendingOcrCards(prevCards => 
            prevCards.map(c => 
                c.id === cardData.id ? { ...c, syncStatus: 'error' } : c
            )
        );
    }
};

// ...

// 修改 handleQueueNextCapture 函式 (應為在 App.js 中定義)
const handleQueueNextCapture = (ocrCardData) => {
    // 1. 建立具有初始同步狀態的新卡片物件
    const newCard = {
        ...ocrCardData,
        id: uuidv4(), // 確保本地狀態有一個唯一 ID
        timestamp: Date.now(), // 本地時間戳 (用於排序/顯示)
        syncStatus: 'pending', // 初始狀態設為處理中
    };
    
    // 2. 更新本地狀態 (立即顯示卡片)
    setPendingOcrCards(prev => [...prev, newCard]);

    // 3. 觸發 Firebase 備份
    backupOcrCardToFirebase(newCard); 
};
步驟 2：修改 src/OcrQueuePage.js - 實作同步狀態圖示我們需要修改 OcrQueuePage 中的卡片渲染邏輯 (OcrCard 組件或直接在渲染列表處修改)，以根據 syncStatus 顯示圖示。受影響範圍： src/OcrQueuePage.js在 OcrQueuePage.js 中，您渲染待辨識卡片的地方 (通常是在 pendingOcrCards.map(...) 內部)，請在卡片底部、運行時間的下面新增一個區塊來顯示狀態圖示。該檔案已引入 lucide-react 的圖示。src/OcrQueuePage.js 程式碼建議修改處：在卡片渲染邏輯的底部，找到顯示運行時間的 <p> 標籤，並在其下方新增一個狀態圖示元件。JavaScript// ... 在 OcrQueuePage 內部，卡片渲染的片段中 ...
// 假設您的卡片結構包含以下時間戳顯示 (或類似的)
{/* 運行時間顯示 (示例) */}
<p className="text-xs text-gray-500 mt-1">
    運行時間: {new Date(card.timestamp).toLocaleTimeString()}
</p>

{/* 新增狀態圖示區塊 - 位於運行時間下面 */}
<div className="absolute bottom-2 right-2">
    {card.syncStatus === 'pending' && (
        <Clock 
            className="w-4 h-4 text-yellow-500 animate-spin" 
            title="正在同步至 Firebase..." 
        />
    )}
    {card.syncStatus === 'success' && (
        <CheckCircle 
            className="w-4 h-4 text-green-500" 
            title="已成功同步至 Firebase" 
        />
    )}
    {card.syncStatus === 'error' && (
        <AlertCircle 
            className="w-4 h-4 text-red-500" 
            title="同步失敗，請檢查網路或重試" 
        />
    )}
</div>
// ...
最終審查與總結需求實作位置實作細節影響功能及範圍自動備份至 Firebasesrc/App.js新增 backupOcrCardToFirebase 函式，並修改 handleQueueNextCapture 以非同步寫入 pendingOcrCards 集合。App.js 的狀態管理和卡片新增邏輯；Firebase 的寫入操作。新增同步圖示src/OcrQueuePage.js根據卡片物件中的 syncStatus 欄位，渲染 Clock (pending)、CheckCircle (success) 或 AlertCircle (error) 圖示。OcrQueuePage.js 的卡片 UI 渲染。此實作方案遵循了最小影響原則，並將複雜的數據庫操作與 UI 邏輯解耦，同時利用了現有的 Firebase 設定與錯誤處理機制。
</file>

<file path="圖片裁剪範圍一致性說明.txt">
圖片裁剪範圍一致性說明
=====================

功能目標：
確保在擷取時顯示的照片範圍與預覽時的範圍一致，而不是顯示整張照片。

實作變更：

1. 圖片顯示區域更新：
   - 更新了主應用程式中的圖片顯示區域，使其與AIOcrCaptureModal中的顯示方式一致
   - 使用相同的寬高比（aspect-video）來保持一致性
   - 移除了裁剪範圍指示器（黃色框線），因為用戶不需要此視覺指示器

2. 圖片顯示邏輯：
   - 保持與AIOcrCaptureModal中相同的圖片顯示邏輯
   - 區分處理base64格式圖片和普通圖片路徑
   - 使用object-cover來確保圖片填滿顯示區域

測試方式：
1. 開啟應用程式
2. 點擊"開啟鏡頭擷取"按鈕
3. 確認預覽畫面中有黃色框線標示的75%中心區域
4. 點擊"擷取畫面"按鈕
5. 確認擷取的圖片顯示在"步驟 2: 檢查或手動輸入"區塊中
6. 確認顯示的圖片與擷取時的預覽範圍一致
7. 確認沒有顯示黃色框線指示器

技術細節：
- 使用相同的寬高比（aspect-video）來保持一致性
- 使用object-cover來確保圖片填滿顯示區域而不變形
- 裁剪範圍為75%的中心區域，與AIOcrCaptureModal中的邏輯一致
- 移除了視覺指示器（黃色框線），以符合用戶需求
- 保留了原有的說明文字
</file>

<file path="價格優先處理功能說明.txt">
價格優先處理功能說明
=====================

功能目標：
當辨識資料有特價和原價時，應優先在總價欄位填入特價價格

實作變更：

1. AI OCR 辨識功能增強：
   - 修改了 AI 分析的 JSON Schema，新增 originalPrice 和 specialPrice 欄位
   - 更新系統提示詞，明確指示當同時存在原價和特價時的處理方式
   - listedPrice 欄位現在會優先使用特價（如果存在）

2. 資料處理邏輯：
   - 在 handleAiCaptureSuccess 函數中，優先使用 specialPrice 作為最終價格
   - 保留 originalPrice 和 specialPrice 資訊以便後續顯示

3. UI 顯示優化：
   - 在 AI 辨識結果區塊顯示原價和特價信息
   - 在價格歷史記錄中以刪除線顯示原價，以突出顯示特價
   - 在所有記錄頁面中同樣顯示原價和特價信息

4. 編輯功能增強：
   - 在編輯模式中新增原價和特價的輸入欄位
   - 保持與新增記錄時一致的價格處理邏輯

5. 價格計算：
   - 單價計算仍然基於實際支付的價格（特價優先）
   - 確保比價功能基於消費者實際支付的價格進行計算

測試方式：
1. 使用「模擬 AI 分析成功」功能測試特價處理
2. 實際上傳包含原價和特價的圖片進行測試
3. 檢查歷史價格記錄中的顯示效果
4. 測試編輯功能中的價格輸入

技術細節：
- specialPrice 和 originalPrice 資料會儲存到 Firebase 中
- 價格顯示會根據是否存在特價來動態調整樣式
- 所有計算仍然使用實際支付價格（特價優先）以確保比價準確性
</file>

<file path="模擬圖片功能說明.txt">
模擬圖片功能說明
=====================

功能目標：
使用真實的產品圖片（士力架.png）來測試擷取畫面顯示功能，確保功能正確實作。

實作變更：

1. 圖片文件處理：
   - 將"士力架.png"從項目根目錄移動到public目錄，以便在應用程式中正確引用
   - 圖片現在可以通過"/士力架.png"路徑訪問

2. 模擬分析功能更新：
   - 修改handleSimulatedAnalysis函數，使用真實的產品圖片而不是生成的模擬圖片
   - 設定產品名稱為"士力架巧克力"以匹配圖片內容
   - 保持其他模擬數據的隨機性（價格、數量等）

3. 圖片顯示組件更新：
   - 更新圖片顯示邏輯，使其能夠正確處理不同類型的圖片URL
   - 區分處理base64格式圖片和普通圖片路徑

測試方式：
1. 開啟應用程式
2. 點擊"開啟鏡頭擷取"按鈕
3. 點擊"模擬 AI 分析成功 (測試用)"按鈕
4. 確認"士力架.png"圖片正確顯示在"步驟 2: 檢查或手動輸入"區塊中
5. 確認圖片顯示區域有適當的樣式和邊框
6. 確認圖片下方有說明文字"此圖片將持續顯示直到進行下一次辨識或退出應用程式"

技術細節：
- 圖片文件已移動到public目錄，這是Create React App推薦的靜態資源存放位置
- 圖片顯示組件能夠處理兩種圖片格式：
  1. base64格式的數據URL
  2. 普通的圖片路徑
- 圖片最大高度設置為60vh以確保不會佔用過多空間
- 圖片顯示區域有適當的邊框和背景色以區分內容
</file>

<file path="歷史價格與折線.txt">
實作指南：歷史價格與走勢圖表
我們將在 App 組件中新增一個狀態來儲存當前產品的歷史紀錄，並創建一個名為 PriceHistoryDisplay 的新組件來處理列表和圖表顯示。

階段一：數據準備與篩選 (在 App.jsx 內部)
您需要一個方法來獲取並篩選出當前產品的歷史價格。

1. 新增歷史紀錄狀態

在 App 組件中，新增一個狀態來儲存與當前 barcode 相關的歷史紀錄。

JavaScript

// 在 App() 組件內部, 與其他 useState 宣告放在一起
const [productHistory, setProductHistory] = useState([]);
// ...
2. 實現歷史數據篩選邏輯

修改您現有的 useEffect 區塊（即在 barcode 變化時觸發查詢產品名稱的那個 useEffect），讓它同時負責獲取和篩選歷史價格。

JavaScript

// App.jsx 內部的 lookupProduct 函數
const lookupProduct = useCallback(async (barcodeData) => {
    // ... (現有的條碼檢查邏輯) ...

    setLookupStatus('searching');
    const numericalID = djb2Hash(barcodeData);
    
    try {
        await new Promise(r => setTimeout(r, 200)); 
        
        // 1. 獲取所有歷史紀錄
        const allRecordsJson = localStorage.getItem('MVP_PRICE_RECORDS') || '[]';
        const allRecords = JSON.parse(allRecordsJson);
        
        // 2. 篩選出當前產品的紀錄
        const filteredRecords = allRecords
            .filter(r => r.numericalID === numericalID)
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // 依時間倒序排列

        setProductHistory(filteredRecords); // <-- 儲存歷史紀錄

        // 3. 產品主檔查找邏輯 (不變)
        const productsJson = localStorage.getItem('MVP_PRODUCTS') || '{}';
        const products = JSON.parse(productsJson);

        if (products[numericalID]) {
            setProductName(products[numericalID].productName);
            setLookupStatus('found');
        } else {
            setProductName('');
            setLookupStatus('new');
        }

    } catch (error) {
        console.error("查詢產品失敗 (Local Storage):", error);
        setLookupStatus('ready');
        setProductHistory([]); // 清空歷史紀錄
    }
}, []);
階段二：建立歷史紀錄顯示組件 (PriceHistoryDisplay)
在 BarcodeIDGenerator.jsx 檔案的頂部（App 組件之前），創建一個新的輔助組件。

1. 定義 PriceHistoryDisplay 組件

這個組件會接收 historyRecords 和 theme 作為屬性。

JavaScript

// 放在 App 組件定義之前
function PriceHistoryDisplay({ historyRecords, theme }) {
    if (historyRecords.length === 0) {
        return (
            <div className="text-center p-6 text-gray-500 bg-white rounded-xl shadow-md">
                尚無歷史價格紀錄。
            </div>
        );
    }

    // 2. 價格走勢圖表的邏輯 (將在階段三實現)
    // ... 圖表邏輯 ...

    return (
        <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${theme.border} mt-8`}>
            <h2 className={`text-xl font-semibold ${theme.text} mb-4`}>
                價格紀錄 ({historyRecords.length} 筆)
            </h2>
            
            {/* 放置圖表的位置 (圖表邏輯在下面) */}
            <div className="mb-6">
                <PriceTrendChart records={historyRecords} theme={theme} />
            </div>

            {/* 3. 歷史紀錄清單 */}
            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {historyRecords.map((record, index) => (
                    <div 
                        key={index} 
                        className={`p-3 rounded-lg shadow-sm border border-gray-100 ${index === 0 ? theme.light : 'bg-white'}`}
                    >
                        <div className="flex justify-between items-start font-bold">
                            <span className="text-2xl text-red-600">${record.price.toFixed(2)}</span>
                            <span className="text-xs text-gray-500">
                                {new Date(record.timestamp).toLocaleString()}
                            </span>
                        </div>
                        <p className="text-sm text-gray-700 mt-1">
                            商店: {record.storeName || '未標註'}
                        </p>
                        {record.discountDetails && (
                            <p className="text-xs text-indigo-600 italic">
                                優惠: {record.discountDetails}
                            </p>
                        )}
                        {/* 標示最新紀錄 */}
                        {index === 0 && (
                            <span className={`text-xs font-semibold px-2 py-0.5 rounded-full text-white ${theme.primary}`}>
                                最新紀錄
                            </span>
                        )}
                    </div>
                ))}
            </div>
        </div>
    );
}
4. 將新組件嵌入 App.jsx

在 App 組件的 <div className="max-w-xl mx-auto"> 內，比價結果區塊的下方，加入新的組件：

JavaScript

// App.jsx 內部的 render 區塊
// ... (比價結果顯示區 </div> 之後)
        
        {/* 歷史價格與走勢圖表顯示區 - 只有當找到產品時才顯示 */}
        {(lookupStatus === 'found' || lookupStatus === 'new') && barcode && (
            <PriceHistoryDisplay 
                historyRecords={productHistory} 
                theme={currentTheme} 
            />
        )}
        
// ...
階段三：實作價格走勢圖表 (PriceTrendChart)
我們將使用 Inline SVG 來繪製一個簡單的折線圖，避免引入大型圖表庫。

1. 創建 PriceTrendChart 組件

這個組件需要計算數據範圍，並將價格值映射到 SVG 座標上。

JavaScript

// 放在 PriceHistoryDisplay 組件定義之前
const CHART_WIDTH = 400; // SVG 寬度 (px)
const CHART_HEIGHT = 150; // SVG 高度 (px)
const PADDING = 20;

function PriceTrendChart({ records, theme }) {
    // 價格必須是數字，並且時間戳必須存在
    const validRecords = records.filter(r => !isNaN(r.price) && r.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    // 1. 計算數據範圍
    const prices = validRecords.map(r => r.price);
    const minPrice = Math.min(...prices) * 0.95; // 讓圖表底部留一點空間
    const maxPrice = Math.max(...prices) * 1.05; // 讓圖表頂部留一點空間
    const priceRange = maxPrice - minPrice;

    // 時間軸範圍
    const minTimestamp = new Date(validRecords[validRecords.length - 1].timestamp).getTime();
    const maxTimestamp = new Date(validRecords[0].timestamp).getTime();
    const timeRange = maxTimestamp - minTimestamp;
    
    if (priceRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格沒有波動，無法繪製趨勢圖。</p>;
    }

    // 2. 轉換為 SVG 座標點字串
    const points = validRecords.map(record => {
        const timestamp = new Date(record.timestamp).getTime();
        const price = record.price;

        // X 座標：將時間映射到 CHART_WIDTH 範圍
        const xRatio = (timestamp - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);

        // Y 座標：將價格映射到 CHART_HEIGHT 範圍 (注意：Y 軸在 SVG 中是倒置的)
        const yRatio = (price - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);

        return `${x},${y}`;
    }).join(' ');

    // 取得第一個和最後一個點的 Y 座標，用於繪製趨勢線
    const startPriceY = parseFloat(points.split(' ')[0].split(',')[1]);
    const endPriceY = parseFloat(points.split(' ').slice(-1)[0].split(',')[1]);


    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1 text-gray-500"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                價格走勢
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                
                {/* 輔助線 - Y軸 (價格標籤) */}
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                {/* 輔助線 - X軸 (時間標籤) */}
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                
                {/* Y 軸標籤 (Max Price) */}
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">
                    ${maxPrice.toFixed(0)}
                </text>

                {/* Y 軸標籤 (Min Price) */}
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">
                    ${minPrice.toFixed(0)}
                </text>


                {/* 折線圖 */}
                <polyline
                    fill="none"
                    stroke={theme.color === 'red' ? '#EF4444' : '#4F46E5'} // 使用主題色
                    strokeWidth="2"
                    points={points}
                />

                {/* 數據點 */}
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return (
                        <circle 
                            key={index} 
                            cx={x} 
                            cy={y} 
                            r="3" 
                            fill={index === 0 ? '#10B981' : theme.primary.split('-')[1]} // 最新點使用綠色
                            title={`$${record.price}`}
                        />
                    );
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>最早紀錄: {new Date(minTimestamp).toLocaleDateString()}</span>
                <span>最新紀錄: {new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}
</file>

<file path="擷取畫面顯示功能說明.txt">
擷取畫面顯示功能說明
=====================

功能目標：
在"步驟 2: 檢查或手動輸入"標題和"條碼數據"項目之間新增一個區塊來顯示擷取畫面，
以利消費者比對辨識資料是否正確。此圖片持續顯示到進行下一次辨識時清除，退出app時也清除。

實作變更：

1. 新增狀態管理：
   - 在 App 組件中新增 capturedImage 狀態來存儲捕獲的圖像
   - 在 AIOcrCaptureModal 組件中已有的 capturedImage 狀態基礎上進行擴展

2. 圖像捕獲流程：
   - 在 handleCapture 函數中設置 capturedImage 狀態
   - 在 handleAnalyze 函數中將捕獲的圖像包含在傳遞給父組件的數據中
   - 在 handleSimulatedAnalysis 函數中也包含捕獲的圖像

3. 圖像顯示：
   - 在"步驟 2: 檢查或手動輸入"標題和"條碼數據"項目之間新增一個區塊來顯示捕獲的圖像
   - 添加適當的標籤和說明文字

4. 圖像清理：
   - 在 clearForm 函數中清除 capturedImage 狀態
   - 在 handleRetake 函數中清除 capturedImage 狀態
   - 在組件卸載時的 useEffect 清理函數中清除 capturedImage 狀態

5. 數據傳遞：
   - 修改 handleAiCaptureSuccess 函數以接收並設置捕獲的圖像

測試方式：
1. 開啟應用程式
2. 點擊"開啟鏡頭擷取"按鈕
3. 擷取畫面
4. 確認擷取的圖像顯示在"步驟 2: 檢查或手動輸入"區塊中
5. 進行下一次辨識，確認之前的圖像被清除
6. 退出應用程式，確認圖像被清除

技術細節：
- 圖像以 base64 格式存儲和顯示
- 圖像顯示區域有適當的樣式和邊框以區分內容
- 添加了說明文字告訴用戶圖像將持續顯示直到進行下一次辨識或退出應用程式
- 圖像最大高度設置為 60vh 以確保不會佔用過多空間
</file>

<file path="鏡頭權限.txt">
import React, { useState, useEffect, useRef } from 'react';
// ... 其他依賴項 (如 Tailwind, API 呼叫等)

const AIOcrCaptureModal = ({ theme, onAnalysisSuccess, onClose }) => {
    // 儲存 MediaStream 物件
    const [stream, setStream] = useState(null);
    const videoRef = useRef(null);
    const [error, setError] = useState('');

    // 【核心邏輯：在 Modal 開啟時請求並啟動串流】
    useEffect(() => {
        const getCameraStream = async () => {
            try {
                // 1. 請求權限並取得串流 (這裡會觸發使用者授權提示)
                const mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment', // 優先使用後置鏡頭
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                // 2. 成功：將串流連接到 video 元素
                setStream(mediaStream);
                if (videoRef.current) {
                    videoRef.current.srcObject = mediaStream;
                    videoRef.current.play();
                }
                setError('');
            } catch (err) {
                // 3. 失敗：處理使用者拒絕或相機無法使用的錯誤
                console.error("無法存取相機:", err);
                setError('無法存取相機。請確認已授予權限或相機未被其他程式使用。');
            }
        };

        getCameraStream();

        // 【關鍵優化：在 Modal 關閉或組件卸載時立即停止串流】
        return () => {
            if (stream) {
                console.log("釋放相機串流資源...");
                stream.getTracks().forEach(track => {
                    track.stop(); // 停止所有軌道 (關閉相機燈)
                });
            }
        };
    }, [stream]); // 注意: 這裡的依賴項需要確保只在組件 mount 時執行一次

    // 捕捉圖像、分析等功能...
    // const handleCapture = () => { /* ... 擷取邏輯 ... */ };

    return (
        <div className={`fixed inset-0 z-50 overflow-y-auto ${theme.bg} bg-opacity-95`}>
            {/* ... Modal UI 結構 ... */}
            <div className="p-4 max-w-lg mx-auto">
                <h2 className="text-xl font-bold mb-4 text-white">AI 視覺擷取</h2>
                
                {/* 顯示錯誤或 Video 串流 */}
                {error ? (
                    <div className="bg-red-500 p-4 text-white rounded-lg">錯誤: {error}</div>
                ) : (
                    <video 
                        ref={videoRef} 
                        className="w-full rounded-lg shadow-xl" 
                        autoPlay 
                        playsInline 
                        muted // 建議在開發時靜音，避免不必要的聲音
                    />
                )}
                
                {/* 動作按鈕 */}
                <div className="mt-4 flex justify-between">
                    <button 
                        onClick={onClose} 
                        className={`px-4 py-2 rounded-full font-semibold ${theme.secondary.bg} hover:${theme.secondary.hover.bg} text-white`}
                    >
                        取消
                    </button>
                    {/* ... 擷取按鈕 ... */}
                </div>
            </div>
        </div>
    );
};

export default AIOcrCaptureModal;
</file>

<file path="AI辨識參考.txt">
import React, { useState, useEffect, useCallback } from 'react';

// 假設這些是您的主題顏色配置
const themeConfig = {
    'blue': { primary: 'indigo-600', hover: 'indigo-700', bg: 'indigo-50' },
    'red': { primary: 'red-600', hover: 'red-700', bg: 'red-50' },
    // ... 其他主題色
};

// 輔助函數：實現指數退避 (Exponential Backoff)
const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
        }
    }
};

// 輔助函數：從字串中提取數字 (例如: "$120.50" -> 120.50)
const cleanAndParseNumber = (str) => {
    if (typeof str !== 'string' || str === null || str === '') return 0;
    
    // 移除所有非數字、非小數點的字符 (保留負號以防萬一，但價格和容量應是非負的)
    // 這裡使用更保守的策略，移除貨幣符號和大部分非數字字元，然後解析
    const cleaned = str.replace(/[^\d.]/g, ''); 
    const num = parseFloat(cleaned);
    
    // 如果解析結果是 NaN (非數字)，則返回 0
    return isNaN(num) ? 0 : num;
};

// 輔助函數：從複雜字串計算總容量 (例如: "18克10入" -> 180)
const calculateTotalCapacity = (capacityString) => {
    if (typeof capacityString !== 'string') {
        return 0;
    }
    
    // 步驟 1: 處理複合格式 (X 單位 Y 入/瓶/袋)
    // 尋找 (數字A) (單位) (數字B) (入/瓶) 或 (數字A) x (數字B) 的模式
    const complexMatch = capacityString.match(/(\d+\.?\d*)\s*[^x\d]*\s*(\d+)\s*[入瓶袋]/i) ||
                         capacityString.match(/(\d+\.?\d*)\s*[xX*]\s*(\d+\.?\d*)/);

    if (complexMatch && complexMatch.length >= 3) {
        // 匹配到 Unit (單位容量/質量) 和 Count (數量)
        const unit = parseFloat(complexMatch[1]);
        const count = parseFloat(complexMatch[2]);
        if (!isNaN(unit) && !isNaN(count)) {
            return unit * count;
        }
    }
    
    // 步驟 2: 如果沒有複雜模式，就嘗試解析單一數字 (例如 "2000ml" -> 2000)
    return cleanAndParseNumber(capacityString);
}

const AIOcrCaptureModal = ({ theme, onAnalysisSuccess, onClose }) => {
    const [imageSrc, setImageSrc] = useState(null);
    const [base64Image, setBase64Image] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    // resultData 現在儲存 AI 傳回的原始純文字
    const [resultData, setResultData] = useState(null); 
    const [error, setError] = useState(null);

    const currentTheme = themeConfig[theme] || themeConfig['blue'];
    const apiKey = ""; // 保持空白，讓 Canvas 注入

    const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                setImageSrc(e.target.result);
                // 儲存 base64 字串供 API 使用
                const base64 = e.target.result.split(',')[1];
                setBase64Image(base64);
                setError(null);
                setResultData(null);
            };
            reader.readAsDataURL(file);
        }
    };

    const handleAnalyzeImage = useCallback(async () => {
        if (!base64Image) {
            setError("請先選擇一張包含價格或規格的圖片。");
            return;
        }

        setIsLoading(true);
        setError(null);
        setResultData(null);

        // ----------------------------------------------------------------------
        // **【核心修正 1】** 系統指令：要求 AI 輸出純文字格式
        // ----------------------------------------------------------------------
        const systemPrompt = `
            你是一個專業的價格數據分析助理。請根據圖像中的標價、產品名稱和規格，僅輸出以下四行資訊，每行使用 '::' 分隔標籤和值。
            **重要規則：**
            1. 不輸出任何 JSON、註釋、Markdown 格式（如星號或井字號）或 JSON 以外的文字。
            2. listedPrice 必須是 AI 辨識到的原始價格文字，包含貨幣或單位。
            3. totalCapacity 必須是 AI 辨識到的原始容量/數量文字，包含單位。
            4. baseUnit 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            
            --- 輸出格式（務必精準遵循）---
            productName::[產品名稱]
            listedPrice::[原始標價文字]
            totalCapacity::[原始容量/數量文字]
            baseUnit::[g, ml 或 pcs]
        `;
        
        const userQuery = "請根據這張圖片，提取產品名稱、價格、規格和基礎單位，並使用指定的純文字格式輸出。";

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: "image/jpeg",
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            // **【核心修正 2】** 移除 JSON 格式強制約束 (generationConfig)
        };

        try {
            const response = await withExponentialBackoff(async () => {
                const res = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) {
                    throw new Error(`API error: ${res.status} ${res.statusText}`);
                }
                return res.json();
            });

            const textResponse = response.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (textResponse) {
                // **【核心修正 3】** 新的解析邏輯：從純文字中提取數據
                const lines = textResponse.split('\n').filter(line => line.includes('::'));
                const parsedData = {};

                lines.forEach(line => {
                    const [key, value] = line.split('::').map(s => s.trim());
                    if (key) {
                        parsedData[key] = value;
                    }
                });
                
                setResultData(textResponse); // 儲存原始文字響應用於顯示

                // 檢查是否包含所有必須的字段
                if (!parsedData.listedPrice || !parsedData.totalCapacity || !parsedData.productName || !parsedData.baseUnit) {
                    setError("AI 分析成功，但未能返回所有關鍵數據（價格、容量、名稱、單位）或格式不符。原始輸出:\n" + textResponse);
                    setIsLoading(false);
                    return;
                }
                
                // 執行客戶端解析與計算
                const { 
                    listedPrice: priceStr = '0', 
                    totalCapacity: capacityStr = '0', 
                    baseUnit = '' 
                } = parsedData;
                
                // 將 AI 回傳的字串安全地轉換為數字
                const listedPrice = cleanAndParseNumber(priceStr);
                // 將 AI 回傳的容量字串安全地計算為總容量數字
                const totalCapacity = calculateTotalCapacity(capacityStr);

                let unitPrice = 0;
                
                if (listedPrice > 0 && totalCapacity > 0) {
                    if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的最終數據
                const finalData = {
                    ...parsedData,
                    listedPrice: listedPrice, // 傳遞解析後的數字
                    totalCapacity: totalCapacity, // 傳遞計算後的數字
                    unitPrice: unitPrice,
                    standard: (baseUnit === 'g' || baseUnit === 'ml') ? `每 100${baseUnit}` : `每個`,
                    timestamp: Date.now(),
                    storeName: '待定義店舖' 
                };
                
                // 檢查最終數據，如果價格或容量依然為 0，則顯示警告
                if (listedPrice === 0 || totalCapacity === 0) {
                    setError(`AI 辨識成功，但價格 (${listedPrice}) 或總容量 (${totalCapacity}) 提取失敗，請檢查原始圖片清晰度或 AI 原始輸出。`);
                    setIsLoading(false);
                    return;
                }

                onAnalysisSuccess(finalData);

            } else {
                setError("AI 分析失敗或未能返回任何文字數據。");
            }
        } catch (err) {
            console.error("API Call Failed:", err);
            const errorMessage = err.message || (err.toString && err.toString()) || "未知錯誤，請檢查主控台獲取詳細資訊。";
            setError(`分析過程中發生錯誤: ${errorMessage}`);
        } finally {
            setIsLoading(false);
        }
    }, [base64Image, onAnalysisSuccess]);


    return (
        <div className="fixed inset-0 z-50 overflow-y-auto bg-gray-900 bg-opacity-75 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-xl p-6 transform transition-all">
                <h2 className={`text-2xl font-bold mb-4 text-${currentTheme.primary}`}>AI 視覺擷取與單價分析</h2>
                
                {/* 1. 圖片上傳區 */}
                <div className="mb-4">
                    <label className={`block text-sm font-medium text-gray-700 mb-2`}>
                        上傳產品照片 (含價格與規格)
                    </label>
                    <input 
                        type="file" 
                        accept="image/*" 
                        onChange={handleImageChange} 
                        className="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                    />
                </div>
                
                {/* 2. 圖片預覽區 */}
                {imageSrc && (
                    <div className="mb-4">
                        <h3 className="text-lg font-semibold mb-2">預覽圖片：</h3>
                        <div className="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-2">
                            <img src={imageSrc} alt="上傳預覽" className="max-w-full h-auto rounded-lg shadow-md" />
                        </div>
                    </div>
                )}
                
                {/* 3. 操作按鈕與狀態 */}
                <div className="flex justify-end space-x-3 mb-4">
                    <button 
                        onClick={onClose} 
                        className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-full hover:bg-gray-200 transition duration-150"
                        disabled={isLoading}
                    >
                        取消/關閉
                    </button>
                    <button 
                        onClick={handleAnalyzeImage} 
                        className={`px-6 py-2 text-sm font-semibold text-white bg-${currentTheme.primary} rounded-full shadow-md hover:bg-${currentTheme.hover} transition duration-150 flex items-center justify-center`}
                        disabled={isLoading || !base64Image}
                    >
                        {isLoading ? (
                             <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        ) : '開始分析'}
                    </button>
                </div>

                {/* 4. 結果顯示/錯誤區 */}
                {error && (
                    <div className={`p-3 rounded-lg bg-red-100 border border-red-400 text-red-700 text-sm mb-4`}>
                        錯誤: {error}
                    </div>
                )}

                {resultData && (
                    <div className={`p-4 rounded-lg bg-${currentTheme.bg} border border-${currentTheme.primary} mb-4`}>
                        <h3 className="text-lg font-semibold mb-2">分析結果 (原始文字輸出)：</h3>
                        <pre className="text-xs overflow-auto bg-white p-3 rounded-md border border-gray-300">
                            {resultData}
                        </pre>
                        <p className="text-sm mt-2 font-medium text-gray-700">
                            **解析後的數字計算：**
                            <span className="block mt-1">
                                **標價 (已解析):** ${cleanAndParseNumber(resultData).toFixed(2)}
                            </span>
                            <span className="block">
                                **總容量 (已計算):** {calculateTotalCapacity(resultData)}
                            </span>
                        </p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default AIOcrCaptureModal;
</file>

<file path="netlify.toml">
# netlify.toml

# 這個設定告訴 Netlify 我們的 Serverless Functions 存放在哪個目錄
[functions]
  directory = "netlify/functions/"

# 這個設定告訴 Netlify 在建置專案時要執行的指令以及要發布的目錄
[build]
  command = "npm run build"
  publish = "build"
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="比價神器 - 條碼掃描與價格比較應用"
    />
    <title>比價神器</title>
  </head>
  <body>
    <noscript>您需要啟用JavaScript才能運行此應用程式。</noscript>
    <div id="root"></div>
  </body>
</html>
</file>

<file path="README.md">
"# Barcodepricing" 
"# Barcodepricing"
</file>

<file path="src/App.css">
/* 應用基本樣式 */
.App {
  text-align: center;
  min-height: 100vh;
}

/* 自定義樣式可以在這裡添加 */
</file>

<file path="src/components/AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path=".eslintignore">
# 打包文件
build/
dist/

# 依賴目錄
node_modules/

# 系統文件
.git/

# 大型輸出文件
repomix-output*.txt
*.jpg
</file>

<file path=".gitignore">
node_modules
build/
dist/
*.log
.env
.eslintcache
repomix-output*.txt
*.jpg
</file>

<file path="COLLABORATION_POLICY.md">
🤖 協作流程：執行前的差異確認政策

🎯 政策目標

為了確保程式碼變更的安全性、準確性與可控性，我們正式啟用「執行前的差異確認」機制。本政策的目標是將程式碼修改納入您 (使用者/開發者) 的高階工作流程（深度理解、頻繁驗證、嚴謹修正）中，確保所有變更都經過嚴格審核。

⚙️ 核心原則：無授權不變更

在未經使用者明確批准的情況下，我（Gemini）絕不會執行任何程式碼檔案的寫入或替換操作。

🛠️ 差異確認流程 (Diff Confirmation Workflow)

當我分析任務並得出需要修改現有程式碼的結論時，我將遵循以下嚴格的步驟：

步驟 1：提出變更請求（由 Gemini 執行）

我將以清晰的格式展示所有計劃中的變更。

變更位置識別：

明確指出要修改的檔案路徑（{filepath}）。

明確指出變更發生在檔案中的哪個函數或組件中（例如：App 組件中的 useEffect 鉤子）。

差異展示：

提供一個標註了行號的程式碼區塊，其中包含完整的舊程式碼片段（即將被移除的內容）。

提供一個標註了行號的程式碼區塊，其中包含完整的新程式碼片段（計劃替換進去的內容）。

等待確認：

在請求的最後，我會明確請求您的輸入，確認是否繼續執行變更。

步驟 2：使用者響應（由您執行）

作為使用者，您的回覆將決定下一步的動作。您有三個可接受的回應類型：

回應

效果

範例指令

批准 (Accept)

允許我立即執行所有提出的變更。

批准 / 同意 / 可以

拒絕 (Reject)

取消本次變更，我將保留現有程式碼，並重新評估我的解決方案。

拒絕 / 不要動

要求修正 (Modify)

允許我針對提出的差異進行迭代修改，然後重新進入「步驟 1」。

新程式碼中，請將變數名稱從 X 改為 Y。

🔗 與通用工作流程的連結

此政策直接支持您先前規定的通用工作流程：

深度理解與反思： 準備差異報告的過程，迫使我必須在執行前對變更的邏輯和影響進行最終的反思。

增量實施與頻繁驗證： 變更報告本身就是一個微小的、可驗證的步驟，允許您在程式碼被寫入前進行驗證。

修正與除錯： 透過差異確認，我們可以共同在變更部署到實際程式碼之前捕捉潛在的錯誤或邏輯缺陷。

本文件為我們協作的最高安全協議，我們將嚴格遵守。
</file>

<file path="ESLINT_CHECK_REQUIREMENT.md">
# ESLint 檢查要求

## 規範說明

為確保代碼品質和一致性，每次修改程式碼後都必須執行 ESLint 檢查。

## 操作步驟

1. 在修改任何程式碼文件後
2. 執行以下命令進行 ESLint 檢查整個項目：
   ```
   npx eslint .
   ```
3. 如果出現任何錯誤或警告，必須先修復再進行提交

## 目的

- 確保代碼符合項目規範
- 避免因 ESLint 警告導致 CI/CD 構建失敗
- 提高代碼可維護性
- 保持整個項目的代碼風格一致性

## 注意事項

- 檢查應涵蓋整個項目 (使用 `npx eslint .`)
- 所有 ESLint 錯誤和警告都必須修復
- 特別注意未使用的變量和函數
- 確保所有導入語句都正確且按規範放置
</file>

<file path="Firebase.txt">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAtaZL06wkWJHhOJdne2Z_h9fMIEYldgjM",
  authDomain: "barcodepricing-00898.firebaseapp.com",
  projectId: "barcodepricing-00898",
  storageBucket: "barcodepricing-00898.firebasestorage.app",
  messagingSenderId: "286146042453",
  appId: "1:286146042453:web:14a20a662dcf3d06f592dc",
  measurementId: "G-6GMRVJ4S52"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);
</file>

<file path="GEMINI.md">
## Gemini Agent 經驗總結

### 關於 `replace` 工具的使用注意事項

`replace` 工具要求 `old_string` 參數與目標檔案中的內容進行精確的字串匹配。即使是微小的差異（例如額外的空格、換行符或縮排）也會導致匹配失敗。

**為避免 `replace` 失敗，請遵循以下最佳實踐：**

1.  **始終先讀取檔案：** 在嘗試使用 `replace` 工具修改檔案之前，請務必使用 `read_file` 工具讀取目標檔案的最新內容。
2.  **精確複製 `old_string`：** 從 `read_file` 的輸出中，精確複製您要替換的程式碼塊作為 `old_string` 參數。確保包含所有空白、換行和縮排。
3.  **避免手動修改 `old_string`：** 不要手動修改從檔案中讀取的 `old_string`，因為這很可能會引入不匹配的差異。
4.  **分階段替換複雜程式碼：** 對於較大的程式碼塊或可能包含動態內容的區域，考慮將替換操作分解為更小、更具體的步驟。
5.  **驗證替換結果：** 在執行 `replace` 操作後，再次使用 `read_file` 驗證更改是否已成功應用。
</file>

<file path="package.json">
{
  "name": "barcode-pricing-comparator",
  "version": "1.0.0",
  "description": "比價神器 - 條碼掃描與價格比較應用",
  "main": "index.js",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "dependencies": {
    "autoprefixer": "^10.4.16",
    "axios": "^1.5.1",
    "firebase": "^10.14.1",
    "lucide-react": "^0.545.0",
    "node-fetch": "^2.7.0",
    "postcss": "^8.4.31",
    "quagga": "^0.12.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "tailwindcss": "^3.3.3",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@babel/plugin-transform-class-properties": "^7.23.3",
    "@babel/plugin-transform-nullish-coalescing-operator": "^7.23.3",
    "@babel/plugin-transform-numeric-separator": "^7.23.3",
    "@babel/plugin-transform-optional-chaining": "^7.23.3",
    "@babel/plugin-transform-private-methods": "^7.23.3",
    "@babel/plugin-transform-private-property-in-object": "^7.23.3",
    "@types/react": "^18.2.25",
    "@types/react-dom": "^18.2.10",
    "eslint": "^8.57.1",
    "eslint-config-react-app": "^7.0.1"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="README_ERROR_HANDLING.md">
# 錯誤處理機制說明

## 概述

本專案實現了一個全域的錯誤處理機制，位於 `src/utils/errorHandler.js`，提供更具體的錯誤訊息給使用者，並可讓整個程式調用。

## 主要功能

### 1. parseFirebaseError(error)
解析 Firebase 錯誤並返回使用者友好的錯誤訊息。

### 2. showUserFriendlyError(error, context)
顯示錯誤訊息給使用者，支援上下文資訊。

### 3. handleFirestoreSaveError(error, operation)
處理 Firestore 儲存操作的錯誤，提供操作類型的上下文。

## 使用方式

在任何需要錯誤處理的組件中，引入並使用：

```javascript
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler';

try {
  // 執行某些操作
  await someOperation();
} catch (error) {
  const userMessage = handleFirestoreSaveError(error, "執行某項操作");
  showUserFriendlyError(userMessage);
}
```

## 錯誤類型對應訊息

- `permission-denied`: 權限不足，無法儲存資料
- `unavailable`: Firebase 服務暫時無法使用
- `deadline-exceeded`: 請求超時
- `resource-exhausted`: 系統資源已滿
- `unauthenticated`: 身份驗證失敗
- 網路錯誤: 網路連線異常
- 其他: 通用錯誤訊息

## 已整合的組件

- App.js
- OcrQueuePage.js
- AllRecordsPage.js
- AIOcrCaptureModal.js
</file>

<file path="requirements_changes.md">
# 需求變更記錄

## 變更要求
根據用戶要求，需要針對特定需求進行處理，千萬不要更動其他功能或顯示。

## 處理原則
1. 只針對明確提出的要求進行修改
2. 不更動其他未提及的功能或顯示
3. 提供修改建議前，需一併提供會影響的功能及範圍供審查
4. 所有變更需清楚記錄在此文件中

## 注意事項
- 用戶強調提供建議後，需要一併提供會影響的功能及範圍供審查
- 用戶要求將此要求紀錄至.md文件中(已完成)
- 任何修改都必須遵循"最小影響原則"，只處理指定需求

## 核心要求確認
用戶明確要求：
1. **只針對具體需求處理** - 不對其他功能進行任何修改
2. **不更動其他功能或顯示** - 保持現有功能完整性
3. **提供影響範圍審查** - 在提供建議前需明確說明會影響的功能及範圍

## 待處理需求
目前尚未收到具體的修改需求內容，請用戶提供詳細的需求說明，我將根據需求進行分析並提供相應的修改建議和影響範圍評估。

## 新增需求 - 所有資料頁面編輯模式功能
用戶提出在"所有資料"頁面增加"編輯模式"功能，具體需求如下：

### 功能描述
1. 在排序功能的右方新增"編輯模式"按鈕
2. 按下按鈕後進入專用編輯模式
3. 編輯模式特性：
   - 暫停資料的即時更新
   - 畫面中央下方顯示"退出編輯模式"的漂浮按鍵
   - 可使用check box選擇要刪除的商品總項目（可複選）
   - 保留原本的左滑開啟價格紀錄詳情裡的單條歷史紀錄的編輯和刪除功能
   - 選擇項目後出現飄浮式刪除按鈕
   - 編輯或刪除完成時保持畫面顯示位置，直到按下退出編輯模式
   - 退出編輯模式時才進行與Firebase的資料更新和同步

### 現有功能分析
經過分析 [AllRecordsPage.js](file:///d%3A/Ai%20software%20DEV/BarcodePricing/001%20-%20DEV/src/AllRecordsPage.js) 文件，發現編輯模式功能已經實現，包含以下特性：

1. **編輯模式按鈕**：已存在於排序選項右側
2. **狀態管理**：
   - `isEditMode` - 編輯模式開關
   - `selectedItems` - 選中的項目集合
   - `localProducts` 和 `localRecords` - 編輯模式下的本地數據副本
3. **UI 變更**：
   - 編輯模式下為每個產品項目添加 checkbox
   - 添加批量刪除的漂浮按鈕
   - 添加退出編輯模式的漂浮按鈕
4. **數據處理**：
   - 進入編輯模式時，複製當前數據到本地狀態
   - 編輯期間所有操作只影響本地狀態
   - 退出編輯模式時，將變更同步到 Firebase

### 用戶提出的優化需求
根據用戶最新指示，需要對現有編輯模式功能進行以下優化：

1. **視覺反饋**：選中項目時可以增加更明顯的視覺效果
2. **位置固定**：確保漂浮按鈕在滾動時保持可見
3. **操作確認**：批量刪除前添加確認對話框

### 用戶新增需求
用戶希望在編輯模式下刪除價格紀錄詳情裡的單條紀錄時，畫面不要重整，但是在非編輯模式時需保持原本功能。

### 用戶最新需求
用戶希望在退出時檢查數據版本或提供衝突解決機制。

### 實作範圍確認
根據用戶最新指示，將針對上述優化需求和新增需求進行實作。

### 實作詳細說明

#### 1. 視覺反饋優化
- **修改內容**：為選中的項目添加增強的視覺反饋效果
- **實現方式**：當項目被選中時，添加藍色邊框和背景色
- **影響範圍**：產品項目的渲染邏輯

#### 2. 位置固定優化
- **修改內容**：確保漂浮按鈕在滾動時保持可見
- **實現方式**：使用 `fixed` 定位確保按鈕始終可見
- **影響範圍**：批量刪除按鈕和退出編輯模式按鈕的定位

#### 3. 操作確認優化
- **修改內容**：批量刪除前添加確認對話框
- **實現方式**：
  - 新增 `isBulkDeleteConfirmationOpen` 狀態管理對話框顯示
  - 新增 `BulkDeleteConfirmation` 組件
  - 修改 `handleBulkDeleteClick` 函數以顯示確認對話框
- **影響範圍**：批量刪除功能流程

#### 4. 編輯模式下單條記錄刪除不重整畫面
- **修改內容**：在編輯模式下刪除單條記錄時，不重新整理畫面，僅更新本地狀態
- **實現方式**：
  - 修改 `confirmDelete` 函數，根據是否為編輯模式採取不同行為
  - 在編輯模式下，直接更新本地狀態而不調用 `fetchData`
  - 在非編輯模式下，保持原有行為
- **影響範圍**：單條記錄刪除功能流程

#### 5. 數據版本檢查和衝突解決機制
- **修改內容**：在退出編輯模式時檢查數據版本或提供衝突解決機制
- **實現方式**：
  - 在進入編輯模式時保存原始數據的快照和時間戳
  - 在退出編輯模式時比較當前Firebase數據與原始快照
  - 如果檢測到衝突，顯示衝突解決對話框
  - 提供合併選項：保留本地變更、保留遠程變更或手動合併
- **影響範圍**：編輯模式的進入和退出流程

#### 6. 衝突解決機制實現細節
- **新增狀態**：
  - `originalDataSnapshot` - 保存進入編輯模式時的原始數據快照
  - `isConflictDialogOpen` - 衝突對話框顯示狀態
  - `conflictData` - 衝突數據詳細信息
- **新增功能**：
  - `checkForConflictsAndExit` - 檢查衝突並退出的函數
  - `checkForDataConflicts` - 數據衝突檢查函數
  - `ConflictResolutionDialog` - 衝突解決對話框組件
  - `handleConflictResolution` - 衝突解決處理函數
- **修改功能**：
  - 編輯模式按鈕的點擊處理函數，使其調用衝突檢查
  - `exitEditMode` 函數，增強其功能以處理衝突後的退出

### 修改文件列表
- [src/AllRecordsPage.js](file:///d%3A/Ai%20software%20DEV/BarcodePricing/001%20-%20DEV/src/AllRecordsPage.js)：實現所有優化功能

### 不影響的功能
- 主頁面 ([App.js](file:///d%3A/Ai%20software%20DEV/BarcodePricing/001%20-%20DEV/src/App.js)) 的任何功能
- Firebase 數據結構
- 價格趨勢圖表顯示
- 搜尋功能
- 編輯模式的核心邏輯
</file>

<file path="src/components/DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="src/components/SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

<file path="src/firebase-config.js">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAtaZL06wkWJHhOJdne2Z_h9fMIEYldgjM",
  authDomain: "barcodepricing-00898.firebaseapp.com",
  projectId: "barcodepricing-00898",
  storageBucket: "barcodepricing-00898.firebasestorage.app",
  messagingSenderId: "286146042453",
  appId: "1:286146042453:web:14a20a662dcf3d06f592dc",
  measurementId: "G-6GMRVJ4S52"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

export { db };
</file>

<file path="src/utils/errorHandler.js">
/**
 * 全域錯誤處理工具函數
 * 提供更具體的錯誤訊息給使用者
 */

/**
 * 解析 Firebase 錯誤並返回使用者友好的錯誤訊息
 * @param {Error} error - Firebase 錯誤物件
 * @returns {string} 使用者友好的錯誤訊息
 */
export function parseFirebaseError(error) {
    if (!error || !error.code) {
        return "發生未知錯誤，請稍後再試";
    }

    // 根據 Firebase 錯誤碼提供具體的錯誤訊息
    switch (error.code) {
        case 'permission-denied':
            return "權限不足，無法儲存資料。請聯繫系統管理員";
        
        case 'unavailable':
            return "Firebase 服務暫時無法使用，請檢查網路連線後再試";
            
        case 'deadline-exceeded':
            return "請求超時，請檢查網路連線後再試";
            
        case 'resource-exhausted':
            return "系統資源已滿，請稍後再試";
            
        case 'failed-precondition':
            return "資料格式錯誤，無法儲存";
            
        case 'aborted':
            return "操作被中斷，請重新嘗試";
            
        case 'out-of-range':
            return "資料超出允許範圍";
            
        case 'unimplemented':
            return "此功能尚未實作";
            
        case 'internal':
            return "系統內部錯誤，請稍後再試";
            
        case 'data-loss':
            return "資料遺失，請重新輸入";
            
        case 'unauthenticated':
            return "身份驗證失敗，請重新整理頁面";
            
        default:
            // 對於其他錯誤，提供通用但具體的訊息
            if (error.message.includes('offline') || error.message.includes('network')) {
                return "網路連線異常，請檢查網路設定後再試";
            }
            if (error.message.includes('quota')) {
                return "超過使用配額，請稍後再試";
            }
            return `操作失敗: ${error.message || '未知錯誤'}`;
    }
}

/**
 * 顯示錯誤訊息給使用者
 * @param {Error|string} error - 錯誤物件或錯誤訊息
 * @param {string} context - 錯誤發生的上下文（可選）
 */
export function showUserFriendlyError(error, context = '') {
    let message = '';
    
    if (typeof error === 'string') {
        message = error;
    } else if (error && error.message) {
        // 如果是 Firebase 錯誤，使用專門的解析函數
        if (error.code) {
            message = parseFirebaseError(error);
        } else {
            message = error.message;
        }
    } else {
        message = "發生未知錯誤，請稍後再試";
    }
    
    // 如果有上下文資訊，添加到訊息中
    if (context) {
        message = `[${context}] ${message}`;
    }
    
    // 顯示錯誤訊息給使用者
    alert(message);
}

/**
 * 處理 Firestore 儲存操作的錯誤
 * @param {Error} error - 錯誤物件
 * @param {string} operation - 操作類型（如 "儲存產品資訊"、"儲存價格記錄"）
 * @returns {string} 使用者友好的錯誤訊息
 */
export function handleFirestoreSaveError(error, operation = '儲存資料') {
    const userMessage = parseFirebaseError(error);
    const fullMessage = `${operation}失敗: ${userMessage}`;
    
    console.error(`[${operation}錯誤]`, error);
    return fullMessage;
}

// 建立一個導出物件而不是匿名導出
const errorHandler = {
    parseFirebaseError,
    showUserFriendlyError,
    handleFirestoreSaveError
};

export default errorHandler;
</file>

<file path="src/utils/errorHandler.test.js">
/**
 * 錯誤處理工具的測試檔案
 */

import { parseFirebaseError, handleFirestoreSaveError } from './errorHandler';

// 模擬 Firebase 錯誤物件
const mockFirebaseErrors = [
    { code: 'permission-denied', message: 'Missing or insufficient permissions.' },
    { code: 'unavailable', message: 'The service is currently unavailable.' },
    { code: 'deadline-exceeded', message: 'Deadline exceeded.' },
    { code: 'unknown', message: 'Network error' },
    { code: 'internal', message: 'Internal server error' }
];

// 測試 parseFirebaseError 函數
console.log('測試 parseFirebaseError 函數:');
mockFirebaseErrors.forEach((error, index) => {
    const result = parseFirebaseError(error);
    console.log(`測試 ${index + 1}:`, result);
});

// 測試 handleFirestoreSaveError 函數
console.log('\n測試 handleFirestoreSaveError 函數:');
const testError = { code: 'permission-denied', message: 'Missing or insufficient permissions.' };
const result = handleFirestoreSaveError(testError, "儲存產品資訊");
console.log('結果:', result);

console.log('\n所有測試完成');
</file>

<file path="tool_usage_notes.md">
# `replace` 工具使用注意事項

## 錯誤 1: `params must have required property 'new_string'`

當使用 `replace` 工具時，代表新內容的參數名稱是 `new_string`，而不是 `newContent`。如果用錯參數名稱，就會發生這個錯誤。

**錯誤範例:**
```python
print(default_api.replace(..., newContent="..."))
```

**正確範例:**
```python
print(default_api.replace(..., new_string="..."))
```

## 錯誤 2: `A secondary check determined that no changes were necessary...`

這個錯誤訊息表示 `replace` 工具判斷不需要做任何修改。這通常發生在 `old_string` 所指定的文字在檔案中找不到。

可能原因有：
1.  **目標文字不存在**: `old_string` 的內容與檔案中的內容不完全匹配（包含空格、換行、縮排）。
2.  **重複操作**: 嘗試執行的變更其實已經被先前的操作套用。即使上次操作後工具回報了錯誤，變更仍可能已經成功寫入檔案。

**解決方法:**
- 在執行 `replace` 前，先用 `read_file` 確認檔案的最新內容，確保 `old_string` 完全符合當前的檔案內容。
- 如果收到此錯誤，請再次用 `read_file` 檢查檔案，確認是否變更已存在。如果已存在，則無需再次執行 `replace`。
</file>

<file path="src/components/components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
components.xml
DataManagement.js
SettingsPage.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

</files>
</file>

<file path="DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

</files>
</file>

<file path="src/src.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AllRecordsPage.js
App.css
App.js
components/AIOcrCaptureModal.js
components/AIOcrCaptureModal備份
components/components.xml
components/DataManagement.js
components/SettingsPage.js
firebase-config.js
index.css
index.js
OcrQueuePage.js
src.xml
StoreSelector.js
utils/errorHandler.js
utils/errorHandler.test.js
utils/priceCalculations.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AllRecordsPage.js">
import React, { useState, useEffect, useMemo, useRef, useCallback, useLayoutEffect } from 'react';
import { ArrowLeft, Database, TrendingUp, Edit, Trash2, Save, X, CheckCircle, Search } from 'lucide-react';
import { collection, getDocs, query, orderBy, updateDoc, deleteDoc, doc } from 'firebase/firestore';
import { calculateUnitPrice, formatUnitPrice } from './utils/priceCalculations';
import StoreSelector from './StoreSelector';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 圖表組件
const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, productName }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp).sort((a, b) => a.timestamp - b.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間無足夠變化可繪圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <TrendingUp className="mr-1 text-gray-500" size={16} />
                單價走勢 - {productName}
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke="#4F46E5" strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === validRecords.length - 1 ? '#10B981' : '#4F46E5'} title={`${record.displayPrice.toFixed(2)} at ${record.timestamp.toLocaleDateString()}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>{new Date(minTimestamp).toLocaleDateString()}</span>
                <span>{new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

// Fuzzy search function
function fuzzyMatch(pattern, text) {
    const pattern_lower = pattern.toLowerCase();
    const text_lower = text.toLowerCase();
    let patternIdx = 0;
    let textIdx = 0;
    let score = 0;
    let consecutive = 0;
    let firstMatchIndex = -1;

    // Iterate through text to find pattern characters
    while (patternIdx < pattern_lower.length && textIdx < text_lower.length) {
        if (pattern_lower[patternIdx] === text_lower[textIdx]) {
            if (firstMatchIndex === -1) {
                firstMatchIndex = textIdx;
            }
            score += 1;
            // Add bonus for consecutive matches
            if (consecutive > 0) {
                score += consecutive;
            }
            consecutive++;
            patternIdx++;
        } else {
            consecutive = 0;
        }
        textIdx++;
    }

    // If the whole pattern was found
    if (patternIdx === pattern_lower.length) {
        // Add bonus for being a prefix
        if (firstMatchIndex === 0) {
            score += 5;
        }
        // Add bonus for tightness of the match
        const matchDensity = pattern.length / (textIdx - firstMatchIndex);
        score *= (1 + matchDensity);

        return score;
    }

    return 0;
}

// 可滑動的記錄項目
function SwipeableRecord({ children, onEdit, onDelete }) {
    const [translateX, setTranslateX] = useState(0);
    const touchStartX = useRef(0);
    const itemRef = useRef(null);
    const buttonsRef = useRef(null);

    const handleTouchStart = (e) => {
        touchStartX.current = e.touches[0].clientX;
    };

    const handleTouchMove = (e) => {
        const touchCurrentX = e.touches[0].clientX;
        const diff = touchCurrentX - touchStartX.current;
        if (diff < 0) { // 只允許向左滑動
            setTranslateX(Math.max(diff, -160)); // -160 是按鈕寬度的總和
        }
    };

    const handleTouchEnd = () => {
        if (translateX < -80) {
            setTranslateX(-160);
        } else {
            setTranslateX(0);
        }
    };

    useEffect(() => {
        const handleGlobalClick = (e) => {
            if (buttonsRef.current && !buttonsRef.current.contains(e.target)) {
                setTranslateX(0);
            }
        };

        if (translateX !== 0) {
            document.addEventListener('click', handleGlobalClick, true);
        }

        return () => {
            document.removeEventListener('click', handleGlobalClick, true);
        };
    }, [translateX]);

    const handleEdit = () => {
        onEdit();
        setTranslateX(0);
    };

    const handleDelete = () => {
        onDelete();
        setTranslateX(0);
    };

    return (
        <div className="relative overflow-hidden">
            <div ref={buttonsRef} className="absolute top-0 right-0 h-full flex items-center">
                <button onClick={handleEdit} className="bg-blue-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Edit size={20} />
                    <span>編輯</span>
                </button>
                <button onClick={handleDelete} className="bg-red-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Trash2 size={20} />
                    <span>刪除</span>
                </button>
            </div>
            <div
                ref={itemRef}
                className="transition-transform duration-300 ease-in-out"
                style={{ transform: `translateX(${translateX}px)` }}
                onTouchStart={handleTouchStart}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleTouchEnd}
            >
                {children}
            </div>
        </div>
    );
}


// 產品記錄組件
function ProductRecord({ product, records, theme, onEdit, onDelete }) {
    const formattedRecords = records.map(r => ({ ...r, timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp) })).sort((a, b) => b.timestamp - a.timestamp);
    
    const latestRecord = formattedRecords[0];
    if (!latestRecord) return null; // 如果沒有記錄，則不渲染此組件

    const validUnitPrices = formattedRecords.map(r => r.unitPrice).filter(p => !isNaN(p) && p !== undefined && p !== null);
    const lowestUnitPrice = validUnitPrices.length > 0 ? Math.min(...validUnitPrices) : 0;
    const highestUnitPrice = validUnitPrices.length > 0 ? Math.max(...validUnitPrices) : 0;
    const avgUnitPrice = validUnitPrices.length > 0 ? validUnitPrices.reduce((sum, p) => sum + p, 0) / validUnitPrices.length : 0;

    return (
        <div className={`p-4 rounded-xl shadow-lg bg-white border-t-4 ${theme.border} mb-6`}>
            <div className="flex justify-between items-start">
                <div>
                    <h3 className="text-lg font-bold text-gray-800">{product.productName}</h3>
                    <p className="text-sm text-gray-600">條碼: {product.barcodeData}</p>
                    <p className="text-xs text-gray-500">ID: {product.numericalID}</p>
                </div>
                <div className="text-right">
                    {/* 顯示原價和特價信息 */}
                    {latestRecord.specialPrice ? (
                        <div>
                            {latestRecord.originalPrice && (
                                <p className="text-lg text-gray-500 line-through">${latestRecord.originalPrice.toFixed(2)}</p>
                            )}
                            <p className="text-2xl font-bold text-indigo-600">${latestRecord.specialPrice.toFixed(2)}</p>
                            <p className="text-xs text-gray-500">@{formatUnitPrice(latestRecord.unitPrice)}</p>
                        </div>
                    ) : (
                        <p className="text-2xl font-bold text-indigo-600">{formatUnitPrice(latestRecord.unitPrice) === '--' ? (isNaN(latestRecord.price) ? 'N/A' : `$${(latestRecord.price || 0).toFixed(2)}`) : `$${(latestRecord.price || 0).toFixed(2)} @${formatUnitPrice(latestRecord.unitPrice)}`}</p>
                    )}
                    <p className="text-xs text-gray-500">{latestRecord.timestamp.toLocaleDateString()}</p>
                    {/* 顯示數量和單位 */}
                    {latestRecord.quantity && latestRecord.unitType && (
                        <p className="text-xs text-gray-500">數量: {latestRecord.quantity} {latestRecord.unitType}</p>
                    )}
                </div>
            </div>

            <div className="grid grid-cols-3 gap-2 my-3 text-center">
                <div className="bg-green-50 p-2 rounded"><p className="text-xs text-gray-500">最低單價</p><p className="font-bold text-green-600">{isNaN(lowestUnitPrice) ? 'N/A' : `${lowestUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-blue-50 p-2 rounded"><p className="text-xs text-gray-500">平均單價</p><p className="font-bold text-blue-600">{isNaN(avgUnitPrice) ? 'N/A' : `${avgUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-red-50 p-2 rounded"><p className="text-xs text-gray-500">最高單價</p><p className="font-bold text-red-600">{isNaN(highestUnitPrice) ? 'N/A' : `${highestUnitPrice.toFixed(2)}`}</p></div>
            </div>

            <div className="mb-4"><PriceTrendChart records={formattedRecords} productName={product.productName} /></div>

            <div className="mt-4">
                <h4 className="font-semibold text-gray-700 mb-2">價格記錄詳情</h4>
                <div className="space-y-2 max-h-40 overflow-y-auto">
                    {formattedRecords.map((record, index) => (
                        <SwipeableRecord
                            key={index}
                            onEdit={() => onEdit(record)}
                            onDelete={() => onDelete(record)}
                        >
                            <div className="flex justify-between items-center p-2 bg-gray-50 rounded">
                                <div>
                                    {/* 顯示原價和特價信息 */}
                                    {record.specialPrice ? (
                                        <p className="font-medium">
                                            {record.originalPrice && (
                                                <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                            )}
                                            <span className="text-red-600 ml-1">${record.specialPrice.toFixed(2)}</span>
                                            <span className="text-gray-500 ml-1">@{formatUnitPrice(record.unitPrice)}</span>
                                        </p>
                                    ) : (
                                        <p className="font-medium">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</p>
                                    )}
                                    {record.discountDetails && <p className="text-xs text-indigo-600">{record.discountDetails}</p>}
                                    {/* 顯示數量和單位 */}
                                    {record.quantity && record.unitType && (
                                        <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType}</p>
                                    )}
                                </div>
                                <div className="text-right">
                                    <p className="text-xs text-gray-500">{record.storeName || '未標註'}</p>
                                    <p className="text-xs text-gray-500">{record.timestamp.toLocaleDateString()}</p>
                                </div>
                            </div>
                        </SwipeableRecord>
                    ))}
                </div>
            </div>
        </div>
    );
}

// 主組件
function AllRecordsPage({ theme, onBack, db, userId, isAuthReady }) {
    const [allProducts, setAllProducts] = useState([]);
    const [allRecords, setAllRecords] = useState({});
    const [loading, setLoading] = useState(true);
    const [sortOption, setSortOption] = useState('latest'); // latest, name, price
    const [editingRecord, setEditingRecord] = useState(null);
    const [deletingRecord, setDeletingRecord] = useState(null);
    const [successMessage, setSuccessMessage] = useState('');
    const scrollPositionRef = useRef(0); // For scroll restoration
    const [isAfterDelete, setIsAfterDelete] = useState(false); // Signal for scroll restoration
    const [searchQuery, setSearchQuery] = useState('');
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const searchInputRef = useRef(null);
    
    // Edit mode states
    const [isEditMode, setIsEditMode] = useState(false);
    const [selectedItems, setSelectedItems] = useState(new Set());
    const [localProducts, setLocalProducts] = useState([]);
    const [localRecords, setLocalRecords] = useState({});
    // 新增狀態：批量刪除確認對話框
    const [isBulkDeleteConfirmationOpen, setIsBulkDeleteConfirmationOpen] = useState(false);
    // 新增狀態：原始數據快照和衝突解決
    const [originalDataSnapshot, setOriginalDataSnapshot] = useState(null);
    const [isConflictDialogOpen, setIsConflictDialogOpen] = useState(false);

    const fetchData = useCallback(async () => {
        if (!db) return;
        setLoading(true);
        try {
            // 1. Fetch all products
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const productsArray = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 2. Fetch all records
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const recordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // 3. Group records by product ID
            const recordsByProduct = {};
            recordsArray.forEach(record => {
                if (!recordsByProduct[record.numericalID]) {
                    recordsByProduct[record.numericalID] = [];
                }
                recordsByProduct[record.numericalID].push(record);
            });

            setAllProducts(productsArray);
            setAllRecords(recordsByProduct);

        } catch (error) {
            console.error('讀取 Firestore 數據失敗:', error);
            const userMessage = handleFirestoreSaveError(error, "讀取產品數據");
            showUserFriendlyError(userMessage);
        } finally {
            setLoading(false);
        }
    }, [db]);

    useEffect(() => {
        // 只有在 Firebase 已準備好時才執行查詢
        if (!isAuthReady || !userId) {
            // 如果 Firebase 尚未準備好，不應該顯示加載狀態
            // 讓用戶知道需要等待 Firebase 初始化
            return;
        }
        
        // Firebase 已準備好且有 userId，執行數據獲取
        fetchData();
    }, [fetchData, isAuthReady, userId]);

    useEffect(() => {
        if (isSearchOpen && searchInputRef.current) {
            setTimeout(() => searchInputRef.current.focus(), 100); // Shorter delay for responsiveness
        }
    }, [isSearchOpen]);

    useLayoutEffect(() => {
        if (isAfterDelete && !loading) {
            // Use requestAnimationFrame to ensure scroll happens after browser paints
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollPositionRef.current);
                setIsAfterDelete(false); // Reset the signal after scrolling
            });
        }
    }, [loading, isAfterDelete]);

    const filteredProducts = useMemo(() => {
        // Use local data in edit mode, otherwise use Firebase data
        const products = isEditMode ? localProducts : allProducts;
        const records = isEditMode ? localRecords : allRecords;

        if (searchQuery.trim() === '') {
            // No search query, just sort the products
            return [...products].sort((a, b) => {
                const recordsA = records[a.numericalID] || [];
                const recordsB = records[b.numericalID] || [];
                
                if (sortOption === 'name') {
                    return a.productName.localeCompare(b.productName);
                }
                
                const latestRecordA = recordsA[0];
                const latestRecordB = recordsB[0];

                if (sortOption === 'price') {
                    const priceA = latestRecordA?.price || -1;
                    const priceB = latestRecordB?.price || -1;
                    return priceB - priceA;
                }

                // Default to 'latest'
                const timeA = latestRecordA?.timestamp?.toDate ? latestRecordA.timestamp.toDate().getTime() : 0;
                const timeB = latestRecordB?.timestamp?.toDate ? latestRecordB.timestamp.toDate().getTime() : 0;
                return timeB - timeA;
            });
        }

        // Fuzzy search logic
        const scoredProducts = products
            .map(product => ({
                product,
                score: fuzzyMatch(searchQuery, product.productName)
            }))
            .filter(item => item.score > 0)
            .sort((a, b) => b.score - a.score);
        
        return scoredProducts.map(item => item.product);

    }, [allProducts, allRecords, sortOption, searchQuery, isEditMode, localProducts, localRecords]);

    const showSuccessMessage = (message) => {
        setSuccessMessage(message);
        setTimeout(() => {
            setSuccessMessage('');
        }, 2000);
    };

    const handleEdit = (record) => {
        setEditingRecord(record);
    };

    const handleDelete = (record) => {
        scrollPositionRef.current = window.scrollY; // Save scroll position
        setDeletingRecord(record);
    };

    // New function to handle checkbox selection
    const handleItemSelect = (productId) => {
        setSelectedItems(prev => {
            const newSet = new Set(prev);
            if (newSet.has(productId)) {
                newSet.delete(productId);
            } else {
                newSet.add(productId);
            }
            return newSet;
        });
    };

    // 修改批量刪除功能以使用確認對話框
    const handleBulkDeleteClick = () => {
        if (selectedItems.size === 0) return;
        setIsBulkDeleteConfirmationOpen(true);
    };

    // New function to delete selected items
    const deleteSelectedItems = async () => {
        if (selectedItems.size === 0) return;
        
        try {
            // Update local state
            setLocalProducts(prev => prev.filter(product => !selectedItems.has(product.numericalID)));
            setLocalRecords(prev => {
                const newRecords = {...prev};
                selectedItems.forEach(productId => {
                    delete newRecords[productId];
                });
                return newRecords;
            });
            
            // Clear selection
            setSelectedItems(new Set());
            setIsBulkDeleteConfirmationOpen(false);
        } catch (error) {
            console.error("Error deleting selected items:", error);
            const userMessage = handleFirestoreSaveError(error, "批量刪除產品");
            showUserFriendlyError(userMessage);
        }
    };

    // 新增函數：檢查衝突並退出編輯模式
    const checkForConflictsAndExit = async () => {
        if (!db || !originalDataSnapshot) return;
        
        try {
            // 獲取當前 Firebase 數據
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const currentProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 將記錄按產品 ID 分組
            const currentRecords = {};
            currentRecordsArray.forEach(record => {
                if (!currentRecords[record.numericalID]) {
                    currentRecords[record.numericalID] = [];
                }
                currentRecords[record.numericalID].push(record);
            });
            
            // 比較當前數據與原始快照
            const hasConflicts = checkForDataConflicts(originalDataSnapshot, {products: currentProducts, records: currentRecords});
            
            if (hasConflicts) {
                // 如果有衝突，顯示衝突解決對話框
                setIsConflictDialogOpen(true);
            } else {
                // 如果沒有衝突，直接退出編輯模式
                await exitEditMode(currentProducts, currentRecords);
            }
        } catch (error) {
            console.error("檢查數據衝突時出錯:", error);
            const userMessage = handleFirestoreSaveError(error, "檢查數據衝突");
            showUserFriendlyError(userMessage);
            // 出錯時仍然退出編輯模式
            await exitEditMode();
        }
    };
    
    // 新增函數：檢查數據衝突
    const checkForDataConflicts = (original, current) => {
        // 比較產品數量
        if (original.products.length !== current.products.length) {
            return true;
        }
        
        // 比較記錄數量
        const originalRecordCount = Object.values(original.records).reduce((count, records) => count + records.length, 0);
        const currentRecordCount = Object.values(current.records).reduce((count, records) => count + records.length, 0);
        
        if (originalRecordCount !== currentRecordCount) {
            return true;
        }
        
        // 更詳細的比較可以在此處添加
        // 為了簡化，我們只檢查數量變化
        
        return false;
    };
    
    // 修改 exitEditMode 函數以接受當前數據
    const exitEditMode = async (currentProducts = null, currentRecords = null) => {
        if (!db) return;
        
        try {
            // 如果沒有提供當前數據，則獲取最新數據
            let latestProducts = currentProducts;
            let latestRecords = currentRecords;
            
            if (!latestProducts || !latestRecords) {
                const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
                const productsSnap = await getDocs(productsQuery);
                latestProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
                const recordsSnap = await getDocs(recordsQuery);
                const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 將記錄按產品 ID 分組
                latestRecords = {};
                currentRecordsArray.forEach(record => {
                    if (!latestRecords[record.numericalID]) {
                        latestRecords[record.numericalID] = [];
                    }
                    latestRecords[record.numericalID].push(record);
                });
            }
            
            // 計算需要從 Firebase 刪除的產品
            const productsToDelete = latestProducts.filter(product => 
                !localProducts.some(localProduct => localProduct.numericalID === product.numericalID)
            );
            
            // 刪除 Firebase 中的產品及其記錄
            for (const product of productsToDelete) {
                // 刪除所有記錄
                const productRecords = latestRecords[product.numericalID] || [];
                for (const record of productRecords) {
                    const recordRef = doc(db, "priceRecords", record.id);
                    await deleteDoc(recordRef);
                }
            }
            
            // 計算需要從 Firebase 刪除的記錄（編輯模式下刪除的記錄）
            const recordsToDelete = [];
            for (const [productId, records] of Object.entries(latestRecords)) {
                const localRecordsForProduct = localRecords[productId] || [];
                // 找出在原始記錄中存在但在本地記錄中不存在的記錄
                const deletedRecords = records.filter(record => 
                    !localRecordsForProduct.some(localRecord => localRecord.id === record.id)
                );
                recordsToDelete.push(...deletedRecords);
            }
            
            // 刪除 Firebase 中的記錄
            for (const record of recordsToDelete) {
                const recordRef = doc(db, "priceRecords", record.id);
                await deleteDoc(recordRef);
            }
            
            // 重新從 Firebase 獲取數據
            await fetchData();
            setIsEditMode(false);
            setSelectedItems(new Set());
            setOriginalDataSnapshot(null);

        } catch (error) {
            console.error("Error syncing with Firebase:", error);
            const userMessage = handleFirestoreSaveError(error, "同步編輯數據");
            showUserFriendlyError(userMessage);
        }
    };

    const handleSaveEdit = async (updatedRecord) => {
        if (!db) return;
        try {
            const recordRef = doc(db, "priceRecords", updatedRecord.id);
            // 更新所有字段，不僅僅是價格和折扣詳情
            await updateDoc(recordRef, {
                price: updatedRecord.price,
                discountDetails: updatedRecord.discountDetails,
                productName: updatedRecord.productName,
                storeName: updatedRecord.storeName,
                quantity: updatedRecord.quantity,
                unitType: updatedRecord.unitType,
                unitPrice: updatedRecord.unitPrice,
                originalPrice: updatedRecord.originalPrice,
                specialPrice: updatedRecord.specialPrice
            });
            
            // 在編輯模式下，更新本地狀態而不是重新獲取所有數據
            if (isEditMode) {
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    
                    // 確保更新的記錄所屬的產品在 localRecords 中存在
                    if (!newRecords[updatedRecord.numericalID]) {
                        newRecords[updatedRecord.numericalID] = [];
                    }
                    
                    // 更新記錄
                    Object.keys(newRecords).forEach(productId => {
                        if (newRecords[productId]) {
                            newRecords[productId] = newRecords[productId].map(record => 
                                record.id === updatedRecord.id ? updatedRecord : record
                            ).filter(record => record !== undefined); // 過濾掉可能的 undefined 值
                        }
                    });
                    
                    // 確保當前更新的記錄存在於其對應的產品記錄中
                    if (!newRecords[updatedRecord.numericalID].some(record => record.id === updatedRecord.id)) {
                        newRecords[updatedRecord.numericalID].push(updatedRecord);
                    }
                    
                    return newRecords;
                });
                
                // 同時更新本地產品列表中的產品名稱
                setLocalProducts(prev => 
                    prev.map(product => 
                        product.numericalID === updatedRecord.numericalID 
                            ? {...product, productName: updatedRecord.productName} 
                            : product
                    )
                );
            } else {
                await fetchData(); // 非編輯模式下重新獲取數據以更新UI
            }
            
            showSuccessMessage('記錄已成功更新');
        } catch (error) {
            console.error("更新記錄失敗:", error);
            const userMessage = handleFirestoreSaveError(error, "更新價格記錄");
            showUserFriendlyError(userMessage);
        }
        setEditingRecord(null);
    };

    // 新增函數：處理衝突解決
    const handleConflictResolution = async (resolutionType) => {
        setIsConflictDialogOpen(false);
        
        switch (resolutionType) {
            case 'local':
                // 保留本地更改，直接退出編輯模式
                await exitEditMode();
                break;
            case 'remote':
                // 保留遠程數據，重新獲取最新數據並退出
                await fetchData();
                setIsEditMode(false);
                setSelectedItems(new Set());
                setOriginalDataSnapshot(null);

                break;
            case 'merge':
                // 手動合併，重新獲取數據並保持編輯模式
                await fetchData();
                setLocalProducts([...allProducts]);
                setLocalRecords({...allRecords});
                // 保持編輯模式開啟，讓用戶繼續編輯
                setOriginalDataSnapshot({
                    products: [...allProducts],
                    records: {...allRecords},
                    timestamp: Date.now()
                });

                break;
            default:
                // 默認情況下直接退出編輯模式
                await exitEditMode();
        }
    };

    const confirmDelete = async () => {
        if (!db || !deletingRecord) return;
        
        // 在編輯模式下，我們只需要更新本地狀態，不需要重新整理畫面
        if (isEditMode) {
            try {
                // 更新本地狀態而不是調用 Firebase
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    if (newRecords[deletingRecord.numericalID]) {
                        newRecords[deletingRecord.numericalID] = newRecords[deletingRecord.numericalID].filter(
                            record => record.id !== deletingRecord.id
                        );
                    }
                    return newRecords;
                });
                
                // 顯示成功消息
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            } finally {
                setDeletingRecord(null);
            }
        } else {
            // 非編輯模式下保持原有行為
            setIsAfterDelete(true); // Signal that the next data fetch is after a delete
            try {
                const recordRef = doc(db, "priceRecords", deletingRecord.id);
                await deleteDoc(recordRef);
                await fetchData(); // 重新獲取數據以更新UI
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            }
            setDeletingRecord(null);
        }
    };

    const handleSearchToggle = () => {
        if (isSearchOpen) {
            setSearchQuery('');
        }
        setIsSearchOpen(!isSearchOpen);
    };

    if (loading) {
        return (
            <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
                <div className="max-w-4xl mx-auto">
                    <div className="flex items-center mb-6">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800">所有記錄</h1>
                    </div>
                    <div className="text-center py-10">
                        {!isAuthReady ? (
                            <p>正在初始化雲端服務，請稍候...</p>
                        ) : !userId ? (
                            <p>正在獲取用戶信息，請稍候...</p>
                        ) : (
                            <p>正在從雲端加載數據...</p>
                        )}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
            <div className="max-w-4xl mx-auto pb-28"> {/* Added pb-28 for floating button */}
                <SuccessMessage message={successMessage} />
                <div className="flex flex-col sm:flex-row sm:items-center justify-between mb-6">
                    <div className="flex items-center mb-4 sm:mb-0">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800 flex items-center"><Database className="mr-2" />所有記錄</h1>
                    </div>
                    <div className="flex items-center">
                        <label className="mr-2 text-gray-700">排序:</label>
                        <select value={sortOption} onChange={(e) => setSortOption(e.target.value)} className="border border-gray-300 rounded p-2 mr-2">
                            <option value="latest">最新記錄</option>
                            <option value="name">產品名稱</option>
                            <option value="price">最新價格</option>
                        </select>
                        <button 
                            onClick={() => {
                                if (!isEditMode) {
                                    // Enter edit mode - copy current data to local state
                                    setLocalProducts([...allProducts]);
                                    setLocalRecords({...allRecords});
                                    // 保存原始數據快照和時間戳
                                    setOriginalDataSnapshot({
                                        products: [...allProducts],
                                        records: {...allRecords},
                                        timestamp: Date.now()
                                    });
                                } else {
                                    // Exit edit mode - 檢查數據版本衝突
                                    checkForConflictsAndExit();
                                }
                                setIsEditMode(!isEditMode);
                                setSelectedItems(new Set());
                            }}
                            className={`px-3 py-2 rounded text-white text-sm ${
                                isEditMode ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'
                            }`}
                        >
                            {isEditMode ? '退出編輯模式' : '編輯模式'}
                        </button>
                    </div>
                </div>

                {/* Floating Delete Button - 修改為固定位置 */}
                {isEditMode && selectedItems.size > 0 && (
                    <div className="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-4 shadow-lg z-50 flex items-center"
                         style={{bottom: '6rem'}}>
                        <button 
                            onClick={handleBulkDeleteClick}
                            className="flex items-center"
                        >
                            <Trash2 size={20} className="mr-2" />
                            刪除選取項目 ({selectedItems.size})
                        </button>
                    </div>
                )}

                {/* Floating Exit Edit Mode Button - 修改為固定位置 */}
                {isEditMode && (
                    <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white rounded-full p-4 shadow-lg z-50">
                        <button 
                            onClick={checkForConflictsAndExit}
                            className="flex items-center"
                        >
                            <X size={20} className="mr-2" />
                            退出編輯模式
                        </button>
                    </div>
                )}

                {filteredProducts.length === 0 ? (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <Database size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">{searchQuery ? '找不到結果' : '暫無記錄'}</h3>
                        <p className="text-gray-500">{searchQuery ? `找不到符合 "${searchQuery}" 的產品` : '還沒有任何產品和價格記錄'}</p>
                    </div>
                ) : (
                    <div>
                        <div className="mb-4 p-4 bg-white rounded-lg shadow">
                            <div className="flex justify-between">
                                <p className="text-gray-700">總共 <span className="font-bold">{filteredProducts.length}</span> 個產品</p>
                                <p className="text-gray-700">總共 <span className="font-bold">{Object.values(allRecords).flat().length}</span> 條記錄</p>
                            </div>
                        </div>
                        {filteredProducts.map(product => {
                            // 修復：確保 records 始終有默認值
                            const records = isEditMode ? (localRecords[product.numericalID] || []) : (allRecords[product.numericalID] || []);
                            // 修改：即使沒有記錄也顯示產品卡片，但只在編輯模式下
                            if (records.length === 0 && !isEditMode) return null;
                            return (
                                // 修改：為選中的項目添加增強的視覺反饋
                                <div key={product.numericalID} className={`relative transition-all duration-200 ${isEditMode && selectedItems.has(product.numericalID) ? 'bg-blue-50 border-2 border-blue-500 rounded-lg' : ''}`}>
                                    {isEditMode && (
                                        <div className="absolute top-4 left-4 z-10">
                                            <input
                                                type="checkbox"
                                                checked={selectedItems.has(product.numericalID)}
                                                onChange={() => handleItemSelect(product.numericalID)}
                                                className="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                                            />
                                        </div>
                                    )}
                                    <div className={isEditMode ? "pl-12" : ""}>
                                        <ProductRecord 
                                            product={product} 
                                            records={records} 
                                            theme={theme} 
                                            onEdit={handleEdit} 
                                            onDelete={handleDelete} 
                                        />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}

                {editingRecord && (
                    <EditModal
                        record={editingRecord}
                        onClose={() => setEditingRecord(null)}
                        onSave={handleSaveEdit}
                    />
                )}

                {deletingRecord && (
                    <DeleteConfirmation
                        record={deletingRecord}
                        onClose={() => setDeletingRecord(null)}
                        onConfirm={confirmDelete}
                    />
                )}

                {/* 新增批量刪除確認對話框 */}
                {isBulkDeleteConfirmationOpen && (
                    <BulkDeleteConfirmation
                        count={selectedItems.size}
                        onClose={() => setIsBulkDeleteConfirmationOpen(false)}
                        onConfirm={deleteSelectedItems}
                    />
                )}

                {/* 新增衝突解決對話框 */}
                {isConflictDialogOpen && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                            <h2 className="text-xl font-bold mb-4">檢測到數據衝突</h2>
                            <p className="mb-4">在您編輯期間，其他用戶修改了部分數據。請選擇如何解決衝突：</p>
                            
                            <div className="mb-6 p-4 bg-yellow-50 rounded-lg">
                                <h3 className="font-semibold text-yellow-800 mb-2">衝突詳情：</h3>
                                <ul className="list-disc pl-5 text-sm text-yellow-700">
                                    <li>數據可能已被人修改</li>
                                    <li>您的更改可能與其他用戶的更改衝突</li>
                                </ul>
                            </div>
                            
                            <div className="space-y-3">
                                <button 
                                    onClick={() => handleConflictResolution('local')}
                                    className="w-full p-3 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                                >
                                    保留我的更改
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('remote')}
                                    className="w-full p-3 bg-green-500 text-white rounded-md hover:bg-green-600"
                                >
                                    保留最新數據
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('merge')}
                                    className="w-full p-3 bg-purple-500 text-white rounded-md hover:bg-purple-600"
                                >
                                    手動合併（推薦）
                                </button>
                            </div>
                            
                            <div className="mt-6 flex justify-end">
                                <button 
                                    onClick={() => setIsConflictDialogOpen(false)}
                                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                                >
                                    取消
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- START: Revamped Search Component --- */}
                <div className="fixed top-6 right-6 z-30">
                    <div 
                        className={`flex items-center justify-end bg-white rounded-full shadow-xl transition-all duration-300 ease-in-out overflow-hidden ${isSearchOpen ? 'w-80' : 'w-16 h-16'}`}
                    >
                        <Search className={`absolute left-5 top-1/2 -translate-y-1/2 text-gray-400 transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`} size={22} />
                        <input
                            ref={searchInputRef}
                            type="text"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="輸入品名進行模糊搜尋..."
                            className={`w-full h-16 pl-14 pr-20 bg-transparent border-none rounded-full outline-none text-lg transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`}
                            style={{pointerEvents: isSearchOpen ? 'auto' : 'none'}}
                        />
                        <button
                            onClick={handleSearchToggle}
                            className="absolute right-0 top-0 w-16 h-16 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 flex items-center justify-center"
                            aria-label={isSearchOpen ? "關閉搜尋" : "開啟搜尋"}
                        >
                            {isSearchOpen ? <X size={28} /> : <Search size={28} />}
                        </button>
                    </div>
                </div>
                {/* --- END: Revamped Search Component --- */}
            </div>
        </div>
    );
}

function EditModal({ record, onClose, onSave }) {
    const [price, setPrice] = useState(record.price);
    const [quantity, setQuantity] = useState(record.quantity || '');
    const [unitType, setUnitType] = useState(record.unitType || 'pcs');
    const [discount, setDiscount] = useState(record.discountDetails || '');
    const [originalPrice, setOriginalPrice] = useState(record.originalPrice || '');
    const [specialPrice, setSpecialPrice] = useState(record.specialPrice || '');
    const [productName, setProductName] = useState(record.productName || '');
    const [storeName, setStoreName] = useState(record.storeName || '');
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);

    const handleSave = () => {
        const newUnitPrice = calculateUnitPrice(price, quantity, unitType);
        if (newUnitPrice === null) {
            alert("請輸入有效的價格和數量。");
            return;
        }
        onSave({ 
            ...record, 
            price: parseFloat(price),
            quantity: parseFloat(quantity),
            unitType: unitType,
            unitPrice: newUnitPrice,
            discountDetails: discount,
            originalPrice: originalPrice ? parseFloat(originalPrice) : null,
            specialPrice: specialPrice ? parseFloat(specialPrice) : null,
            productName: productName,
            storeName: storeName
        });
    };

    const currentUnitPrice = calculateUnitPrice(price, quantity, unitType);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 overflow-hidden">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">編輯記錄</h2>
                <div className="space-y-3">
                    {/* 產品名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">產品名稱</label>
                        <input
                            type="text"
                            value={productName}
                            onChange={(e) => setProductName(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 商店名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">商店名稱</label>
                        <div className="mt-1 flex">
                            <input
                                type="text"
                                value={storeName}
                                onChange={(e) => setStoreName(e.target.value)}
                                className="block flex-grow border border-gray-300 rounded-l-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                placeholder="點擊選擇商店或手動輸入"
                                readOnly
                            />
                            <button 
                                onClick={() => setIsStoreSelectorOpen(true)}
                                className="bg-indigo-600 text-white px-4 py-2 rounded-r-md hover:bg-indigo-700"
                            >
                                選擇
                            </button>
                        </div>
                    </div>
                    
                    {/* 原價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">原價 ($)</label>
                        <input
                            type="number"
                            value={originalPrice}
                            onChange={(e) => setOriginalPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 特價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">特價 ($)</label>
                        <input
                            type="number"
                            value={specialPrice}
                            onChange={(e) => setSpecialPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 總價輸入（實際支付價格） */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">總價 ($)</label>
                        <input
                            type="number"
                            value={price}
                            onChange={(e) => setPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    <div>
                        <label className="block text-sm font-medium text-gray-700">數量</label>
                        <input
                            type="number"
                            value={quantity}
                            onChange={(e) => setQuantity(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單位</label>
                        <select
                            value={unitType}
                            onChange={(e) => setUnitType(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        >
                            <option value="ml">ml (毫升)</option>
                            <option value="g">g (克)</option>
                            <option value="pcs">pcs (個/包/支/條)</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單價 (自動計算)</label>
                        <input
                            type="text"
                            value={currentUnitPrice === null ? 'N/A' : currentUnitPrice.toFixed(2)}
                            readOnly
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-gray-100"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">折扣詳情</label>
                        <input
                            type="text"
                            value={discount}
                            onChange={(e) => setDiscount(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                </div>
                <div className="mt-4 flex justify-between">
                    <button onClick={onClose} className="flex-1 mr-2 items-center bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 flex justify-center">
                        <X size={18} className="mr-1" />
                        取消
                    </button>
                    <button onClick={handleSave} className="flex-1 ml-2 items-center bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 flex justify-center">
                        <Save size={18} className="mr-1" />
                        保存
                    </button>
                </div>
            </div>
            
            {isStoreSelectorOpen && (
                <StoreSelector 
                    onSelect={(selectedStore) => {
                        setStoreName(selectedStore);
                        setIsStoreSelectorOpen(false);
                    }}
                    onClose={() => setIsStoreSelectorOpen(false)}
                    theme={{ primary: 'bg-indigo-600', hover: 'hover:bg-indigo-700', text: 'text-indigo-600' }}
                />
            )}
        </div>
    );
}

function DeleteConfirmation({ record, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p>您確定要刪除這條價格為 ${record.price.toFixed(2)} 的記錄嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}

function SuccessMessage({ message }) {
    if (!message) return null;

    return (
        <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center z-50">
            <CheckCircle size={20} className="mr-2" />
            <span>{message}</span>
        </div>
    );
}



// 新增批量刪除確認對話框組件
function BulkDeleteConfirmation({ count, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認批量刪除</h2>
                <p>您確定要刪除選中的 {count} 個產品項目嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}



export default AllRecordsPage;
</file>

<file path="App.css">
/* 應用基本樣式 */
.App {
  text-align: center;
  min-height: 100vh;
}

/* 自定義樣式可以在這裡添加 */
</file>

<file path="App.js">
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PaintBucket, DollarSign, Barcode, ClipboardCheck, X, Camera, Zap, FileText, RotateCcw, Database, Settings as SettingsIcon } from 'lucide-react';
import AllRecordsPage from './AllRecordsPage';
import StoreSelector from './StoreSelector';
import AIOcrCaptureModal from './components/AIOcrCaptureModal';
import SettingsPage from './components/SettingsPage'; // 新增導入
import { db } from './firebase-config.js'; // <-- 引入 Firebase
import { getAuth, signInAnonymously } from "firebase/auth";
import { doc, getDoc, setDoc, collection, query, where, getDocs, addDoc, orderBy, serverTimestamp } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import OcrQueuePage from './OcrQueuePage';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具
import { v4 as uuidv4 } from 'uuid'; // 引入 uuid 函式庫來生成本地 ID

// ----------------------------------------------------------------------------
// 1. 核心設定與工具函數 (Core Setup & Utilities)
// ----------------------------------------------------------------------------

function djb2Hash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
}

// 以下函數已移至 src/components/AIOcrCaptureModal.js
// callGeminiApiWithRetry
// withExponentialBackoff


function generateProductId(barcode, productName, storeName) {
    if (barcode) {
        return djb2Hash(barcode).toString();
    } else {
        // Combine productName and storeName to create a unique ID for products without barcodes
        // This assumes productName + storeName is sufficiently unique for non-barcoded items
        return djb2Hash(`${productName}-${storeName}`).toString();
    }
}

// ----------------------------------------------------------------------------
// 2. UI 元件 (UI Components)
// ----------------------------------------------------------------------------

const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, theme }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間沒有足夠的變化來繪製趨勢圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1 text-gray-500"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                單價走勢
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke={theme.color === 'red' ? '#EF4444' : '#4F46E5'} strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === 0 ? '#10B981' : theme.primary.split('-')[1]} title={`$${record.displayPrice.toFixed(2)}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>最早: {new Date(minTimestamp).toLocaleDateString()}</span>
                <span>最新: {new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

function PriceHistoryDisplay({ historyRecords, theme }) {
    if (historyRecords.length === 0) {
        return <div className="text-center p-6 text-gray-500 bg-white rounded-xl shadow-md">尚無歷史價格紀錄。</div>;
    }

    const formattedRecords = historyRecords.map(record => ({
        ...record,
        timestamp: record.timestamp?.toDate ? record.timestamp.toDate() : new Date(record.timestamp),
        displayPrice: record.unitPrice !== undefined && record.unitPrice !== null ? record.unitPrice : record.price // Use unitPrice if available, else price
    }));

    return (
        <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${theme.border} mt-8`}>
            <h2 className={`text-xl font-semibold ${theme.text} mb-4`}>價格紀錄 ({formattedRecords.length} 筆)</h2>
            <div className="mb-6"><PriceTrendChart records={formattedRecords} theme={theme} /></div>
            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {formattedRecords.map((record, index) => (
                    <div key={index} className={`p-3 rounded-lg shadow-sm border border-gray-100 ${index === 0 ? theme.light : 'bg-white'}`}>
                        <div className="flex justify-between items-start font-bold">
                            {/* 顯示原價和特價信息 */}
                            {record.specialPrice ? (
                                <span className="text-[22px]">
                                    {record.originalPrice && (
                                        <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                    )}
                                    <span className="text-red-600 ml-2">${record.specialPrice.toFixed(2)}</span>
                                    <span className="text-gray-500 ml-2">@{formatUnitPrice(record.unitPrice)}</span>
                                </span>
                            ) : (
                                <span className="text-[22px] text-red-600">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</span>
                            )}
                            <span className="text-xs text-gray-500">{record.timestamp.toLocaleString()}</span>
                        </div>
                        <p className="text-sm text-gray-700 mt-1">商店: {record.storeName || '未標註'}</p>
                        {/* 顯示數量和單位資訊 */}
                        {record.quantity && record.unitType && <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType} (總價: ${(record.price || 0).toFixed(2)})</p>}
                        {record.discountDetails && <p className="text-xs text-indigo-600 italic">優惠: {record.discountDetails}</p>}
                        {index === 0 && <span className={`text-xs font-semibold px-2 py-0.5 rounded-full text-white ${theme.primary}`}>最新紀錄</span>}
                    </div>
                ))}
            </div>
        </div>
    );
}

const THEMES = {
    'Default (Indigo)': { primary: 'bg-indigo-600', light: 'bg-indigo-100', hover: 'hover:bg-indigo-700', border: 'border-indigo-600', text: 'text-indigo-600', color: 'indigo' },
    '海洋藍 (Ocean Blue)': { primary: 'bg-blue-600', light: 'bg-blue-100', hover: 'hover:bg-blue-700', border: 'border-blue-600', text: 'text-blue-600', color: 'blue' },
    '森林綠 (Forest Green)': { primary: 'bg-green-600', light: 'bg-green-100', hover: 'hover:bg-green-700', border: 'border-green-600', text: 'text-green-600', color: 'green' },
    '夕陽紅 (Sunset Red)': { primary: 'bg-red-600', light: 'bg-red-100', hover: 'hover:bg-red-700', border: 'border-red-600', text: 'text-red-600', color: 'red' },
    '活力橙 (Vibrant Orange)': { primary: 'bg-orange-600', light: 'bg-orange-100', hover: 'hover:bg-orange-700', border: 'border-orange-600', text: 'text-orange-600', color: 'orange' },
    '薰衣草紫 (Lavender)': { primary: 'bg-purple-600', light: 'bg-purple-100', hover: 'hover:bg-purple-700', border: 'border-purple-600', text: 'text-purple-600', color: 'purple' },
};
const DEFAULT_THEME_KEY = 'Default (Indigo)';

function ThemeSelector({ theme, saveTheme, onClose }) {
    const handleThemeChange = (themeKey) => { saveTheme(themeKey); };
    const handleReset = () => { saveTheme(DEFAULT_THEME_KEY); };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 transform transition-all">
                <h3 className={`text-xl font-bold ${theme.text} mb-4 border-b pb-2`}><PaintBucket className="inline-block w-5 h-5 mr-2" />介面配色選項</h3>
                <div className="grid grid-cols-2 gap-4 mb-6">
                    {Object.keys(THEMES).map((themeKey) => {
                        const themeData = THEMES[themeKey];
                        const isSelected = theme.color === themeData.color;
                        return (
                            <button key={themeKey} onClick={() => handleThemeChange(themeKey)}
                                className={`p-3 rounded-lg text-white font-medium shadow-md transition-all ${themeData.primary} ${themeData.hover} ${isSelected ? 'ring-4 ring-offset-2 ring-opacity-70 ring-gray-400' : ''}`}
                                style={{ transform: isSelected ? 'scale(1.05)' : 'scale(1)' }}>
                                {themeKey}
                            </button>
                        );
                    })}
                </div>
                <div className="flex justify-between items-center pt-4 border-t">
                    <button onClick={handleReset} className="flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                        <RotateCcw className="w-4 h-4 mr-1" />清除還原 (預設)
                    </button>
                    <button onClick={onClose} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg ${theme.primary} ${theme.hover} transition-all`}>關閉</button>
                </div>
            </div>
        </div>
    );
}

// AIOcrCaptureModal 組件已移至獨立檔案 src/components/AIOcrCaptureModal.js


// ----------------------------------------------------------------------------
// 3. Firebase 身份驗證與主題設定 (Firebase Auth & Theming)
// ----------------------------------------------------------------------------

function useFirebaseAuthentication() {
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        const auth = getAuth();
        signInAnonymously(auth)
            .then((userCredential) => {
                setUserId(userCredential.user.uid);
                setIsAuthReady(true);
            })
            .catch((error) => {
                console.error("Firebase 匿名登入失敗:", error);
            });
    }, []);

    const [currentTheme, setCurrentTheme] = useState(() => {
        const savedKey = localStorage.getItem('appTheme') || DEFAULT_THEME_KEY;
        return THEMES[savedKey] || THEMES[DEFAULT_THEME_KEY];
    });

    const saveUserTheme = useCallback((themeKey) => {
        localStorage.setItem('appTheme', themeKey);
        setCurrentTheme(THEMES[themeKey] || THEMES[DEFAULT_THEME_KEY]);
    }, []);

    return { userId, isAuthReady, currentTheme, saveUserTheme };
}

// ----------------------------------------------------------------------------
// 4. 結果提示框 (Result Toast)
// ----------------------------------------------------------------------------
function SaveResultToast({ result, onClose }) {
    useEffect(() => {
        let timer;
        if (result) {
            timer = setTimeout(onClose, 5000);
        }
        return () => clearTimeout(timer);
    }, [result, onClose]);

    if (!result) {
        return null;
    }

    const { status, message, productName } = result;

    const theme = {
        success: { bg: 'bg-green-500', text: 'text-white', icon: <ClipboardCheck className="w-6 h-6 mr-3" /> },
        warning: { bg: 'bg-yellow-400', text: 'text-gray-800', icon: <DollarSign className="w-6 h-6 mr-3" /> },
        error: { bg: 'bg-red-500', text: 'text-white', icon: <X className="w-6 h-6 mr-3" /> },
    };

    const currentTheme = theme[status];

    return (
        <div className={`fixed top-20 left-1/2 -translate-x-1/2 max-w-md w-full p-4 rounded-xl shadow-2xl z-[100] ${currentTheme.bg} ${currentTheme.text} transition-all duration-300 ease-in-out`}>
            <div className="flex items-center">
                {currentTheme.icon}
                <div className="flex-grow">
                    <p className="font-bold text-lg">{productName}</p>
                    <p className="text-sm">{message}</p>
                    <p className="text-sm font-semibold mt-1">
                        資料儲存: {status === 'error' ? '失敗' : '成功'} | 
                        比價結果: {status === 'success' ? '是最低價' : (status === 'warning' ? '非最低價' : 'N/A')}
                    </p>
                </div>
                <button onClick={onClose} className="ml-4 p-1 rounded-full hover:bg-white/20"><X className="w-5 h-5" /></button>
            </div>
        </div>
    );
}


// ----------------------------------------------------------------------------
// 5. 主應用程式元件 (App Component)
// ----------------------------------------------------------------------------

function App() {
    const { userId, isAuthReady, currentTheme, saveUserTheme } = useFirebaseAuthentication();
    const streamRef = useRef(null);
    
    const [saveResultToast, setSaveResultToast] = useState(null);

    // UI 狀態
    const [barcode, setBarcode] = useState('');
    const [productName, setProductName] = useState('');
    const [currentPrice, setCurrentPrice] = useState('');
    const [quantity, setQuantity] = useState('');
    const [unitType, setUnitType] = useState('pcs'); // 'g', 'ml', 'pcs'
    const [unitPrice, setUnitPrice] = useState(null);
    const [discountDetails, setDiscountDetails] = useState('');
    const [storeName, setStoreName] = useState('');
    const [productHistory, setProductHistory] = useState([]);
    const [comparisonResult, setComparisonResult] = useState({ message: '等待比價數據...' });
    const [statusMessage, setStatusMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [lookupStatus, setLookupStatus] = useState('ready');
    
    // Modal and Page 狀態
    const [isThemeModalOpen, setIsThemeModalOpen] = useState(false);
    const [isCaptureModalOpen, setIsCaptureModalOpen] = useState(false);
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);
    const [isOcrQueueStoreSelectorOpen, setIsOcrQueueStoreSelectorOpen] = useState(false); // 新增狀態
    const [isSettingsOpen, setIsSettingsOpen] = useState(false); // 新增狀態
    const [editingOcrCard, setEditingOcrCard] = useState(null); // 新增狀態
    
    // 新增 useEffect 來自動清除狀態消息
    useEffect(() => {
        let timer;
        if (statusMessage) {
            timer = setTimeout(() => {
                setStatusMessage('');
            }, 3000); // 3秒後清除消息
        }
        return () => clearTimeout(timer);
    }, [statusMessage]);
    
    // 新增函數：處理數據刷新
    const handleDataRefresh = useCallback((key) => {
        // 如果清除的是 pendingOcrCards，需要更新狀態
        if (key === 'pendingOcrCards' || key === 'ALL') {
            const savedCards = localStorage.getItem('pendingOcrCards');
            setPendingOcrCards(savedCards ? JSON.parse(savedCards) : []);
        }
        // 可以在這裡添加其他需要刷新的狀態
    }, []);

    const [currentPage, setCurrentPage] = useState('main'); // 'main', 'allRecords', 'ocrQueue'
    const [ocrResult, setOcrResult] = useState(null);
    const [capturedImage, setCapturedImage] = useState(null); // 新增的狀態
    
    // 新增狀態：待辨識序列
    const [pendingOcrCards, setPendingOcrCards] = useState(() => {
        // 從 localStorage 恢復待辨識卡片
        const savedCards = localStorage.getItem('pendingOcrCards');
        return savedCards ? JSON.parse(savedCards) : [];
    });
    
    // 新增狀態：跟踪是否已從 Firebase 加載數據
    const [isFirebaseDataLoaded, setIsFirebaseDataLoaded] = useState(false);
    
    // 新增狀態：跟踪上次同步的數據哈希值
    const [lastSyncedDataHash, setLastSyncedDataHash] = useState('');
    
    // 新增狀態：跟踪上次同步時間
    const [lastSyncTime, setLastSyncTime] = useState(0);
    
    // 計算數據哈希值的函數
    const calculateDataHash = useCallback((data) => {
        // 將數據轉換為字符串並計算簡單哈希
        const str = JSON.stringify(data, Object.keys(data).sort());
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 轉換為32位整數
        }
        return hash.toString();
    }, []);
    
    // 新增函數：同步 pendingOcrCards 到 Firebase
    const syncPendingOcrCardsToFirebase = useCallback(async (cards) => {
        // 只有在用戶已認證時才同步（不需要等待 Firebase 數據加載完成）
        if (!isAuthReady || !userId) {
            console.log("Firebase 尚未準備好或無用戶 ID，跳過雲端同步。");
            return;
        }
        
        // 計算當前數據的哈希值
        const currentDataHash = calculateDataHash(cards);
        
        // 檢查是否在短時間內重複同步（頻率限制）
        const now = Date.now();
        const timeSinceLastSync = now - lastSyncTime;
        if (timeSinceLastSync < 5000) { // 5秒內不重複同步
            console.log("同步頻率過高，跳過本次同步。");
            return;
        }
        
        // 如果數據沒有變化，則跳過同步
        if (currentDataHash === lastSyncedDataHash) {
            console.log("數據未發生變化，跳過雲端同步。");
            return;
        }

        try {
            // 使用用戶 ID 作為 Document ID，在 ocrQueues Collection 中
            const queueRef = doc(db, "ocrQueues", userId);

            // 儲存整個卡片陣列 (如果陣列大小在 Firestore 限制內)
            await setDoc(queueRef, {
                cards: cards, // 整個 pendingOcrCards 陣列
                lastUpdated: serverTimestamp(), // 記錄最後更新時間
                userId: userId // 保存用戶 ID
            }, { merge: true });

            console.log("待辨識序列已成功同步至 Firebase 雲端。");
            
            // 更新最後同步的數據哈希值和時間
            setLastSyncedDataHash(currentDataHash);
            setLastSyncTime(now);
            
            // 更新卡片的同步狀態為成功（只更新那些狀態不是成功的卡片）
            const updatedCards = cards.map(card => ({
                ...card,
                syncStatus: card.syncStatus === 'success' ? 'success' : 'success'
            }));
            
            // 只有當有卡片狀態需要更新時才更新狀態
            const needsUpdate = cards.some(card => card.syncStatus !== 'success');
            if (needsUpdate) {
                setPendingOcrCards(updatedCards);
            }
        } catch (error) {
            console.error("Firebase 雲端同步失敗:", error);
            // 不再顯示錯誤給用戶，因為這可能會干擾用戶體驗
            
            // 更新卡片的同步狀態為錯誤（只更新那些狀態不是錯誤的卡片）
            const updatedCards = cards.map(card => ({
                ...card,
                syncStatus: card.syncStatus === 'error' ? 'error' : 'error'
            }));
            
            // 只有當有卡片狀態需要更新時才更新狀態
            const needsUpdate = cards.some(card => card.syncStatus !== 'error');
            if (needsUpdate) {
                setPendingOcrCards(updatedCards);
            }
        }
    }, [isAuthReady, userId, lastSyncedDataHash, lastSyncTime, calculateDataHash]);
    
    // 添加 useEffect 來保存 pendingOcrCards 到 localStorage 和雲端
    useEffect(() => {
        // 1. 本地持久化
        localStorage.setItem('pendingOcrCards', JSON.stringify(pendingOcrCards));
        
        // 2. 雲端同步（不需要等待 Firebase 數據加載完成）
        // 只有當有卡片時才觸發同步
        if (pendingOcrCards.length > 0) {
            syncPendingOcrCardsToFirebase(pendingOcrCards);
        }
    }, [pendingOcrCards, syncPendingOcrCardsToFirebase]);
    
    // 新增 useEffect：從 Firebase 載入數據
    useEffect(() => {
        if (isAuthReady && userId && !isFirebaseDataLoaded) {
            const loadCards = async () => {
                try {
                    const queueRef = doc(db, "ocrQueues", userId);
                    const docSnap = await getDoc(queueRef);

                    // 獲取本地數據
                    const savedLocalCards = localStorage.getItem('pendingOcrCards');
                    let localCards = [];
                    if (savedLocalCards) {
                         try {
                             localCards = JSON.parse(savedLocalCards);
                         } catch (parseError) {
                             console.error("解析本地數據失敗:", parseError);
                             localStorage.removeItem('pendingOcrCards'); // 清除損壞的數據
                         }
                    }
                    
                    // 獲取本地最後更新時間
                    const localLastUpdated = localStorage.getItem('pendingOcrCardsLastUpdated');
                    const localLastUpdatedDate = localLastUpdated ? new Date(localLastUpdated) : new Date(0);

                    if (docSnap.exists() && Array.isArray(docSnap.data().cards)) {
                        const firebaseCards = docSnap.data().cards;
                        const firebaseLastUpdated = docSnap.data().lastUpdated?.toDate?.() || new Date(0);
                        
                        // 比較本地和雲端數據的時間戳
                        // 如果雲端數據比本地新，則使用雲端數據
                        if (firebaseLastUpdated > localLastUpdatedDate) {
                            setPendingOcrCards(firebaseCards);
                            localStorage.setItem('pendingOcrCards', JSON.stringify(firebaseCards)); // 用雲端數據覆蓋本地
                            localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString()); // 更新時間戳
                            console.log("已從 Firebase 恢復待辨識序列。");
                        } 
                        // 如果本地數據比雲端新，則上傳本地數據到雲端
                        else if (firebaseLastUpdated < localLastUpdatedDate && localCards.length > 0) {
                            // 觸發一次同步到雲端
                            syncPendingOcrCardsToFirebase(localCards);
                            console.log("本地數據較新，已同步到 Firebase。");
                        }
                        // 如果數據數量不同，合併數據
                        else if (firebaseCards.length !== localCards.length) {
                            // 創建一個基於 ID 的映射來避免重複
                            const localCardMap = new Map(localCards.map(card => [card.id, card]));
                            const firebaseCardMap = new Map(firebaseCards.map(card => [card.id, card]));
                            
                            // 合併兩個集合
                            const mergedCards = [...localCards];
                            for (const [id, firebaseCard] of firebaseCardMap) {
                                if (!localCardMap.has(id)) {
                                    mergedCards.push(firebaseCard);
                                }
                            }
                            
                            // 按時間戳排序
                            mergedCards.sort((a, b) => a.timestamp - b.timestamp);
                            
                            setPendingOcrCards(mergedCards);
                            localStorage.setItem('pendingOcrCards', JSON.stringify(mergedCards)); // 用合併後的數據覆蓋本地
                            localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString()); // 更新時間戳
                            console.log("已從 Firebase 合併待辨識序列。");
                        }
                        // 如果數據相同，則不需要做任何事情
                        else {
                            console.log("本地和雲端數據一致，無需同步。");
                        }
                    } else {
                        // 如果雲端沒有數據但本地有數據，則上傳本地數據到雲端
                        if (localCards.length > 0) {
                            // 注意：這裡我們不直接調用 syncPendingOcrCardsToFirebase，因為 setPendingOcrCards 會觸發上面的 useEffect
                            // 這樣可以確保數據同步到雲端
                            console.log("雲端沒有數據，本地數據將在下次更新時同步到 Firebase。");
                        }
                    }
                    
                    // 標記 Firebase 數據已加載
                    setIsFirebaseDataLoaded(true);
                } catch (error) {
                    console.error("從 Firebase 載入序列失敗:", error);
                    // 即使加載失敗，也標記為已加載以允許本地操作
                    setIsFirebaseDataLoaded(true);
                }
            };
            loadCards();
        }
    }, [isAuthReady, userId, setPendingOcrCards, syncPendingOcrCardsToFirebase, isFirebaseDataLoaded]);
    
    useEffect(() => {
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const price = parseFloat(finalPrice);
        const qty = parseFloat(quantity);

        if (!isNaN(price) && !isNaN(qty) && qty > 0) {
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(price, qty, unitType);
            setUnitPrice(calculatedUnitPrice);
        } else {
            setUnitPrice(null);
        }
    }, [currentPrice, quantity, unitType, ocrResult]);
    
    // 提前定義所有會被使用的函數，避免 no-use-before-define 警告
    const clearForm = useCallback(() => {
        setBarcode('');
        setProductName('');
        setCurrentPrice('');
        setQuantity('');
        setUnitType('pcs'); // Reset to default unit type
        setUnitPrice(null);
        setDiscountDetails('');
        setStoreName('');
        setProductHistory([]);
        setComparisonResult({ message: '等待比價數據...' });
        setOcrResult(null);
        setLookupStatus('ready');
        setCapturedImage(null); // 清除擷取的圖片
    }, []);

    const stopCameraStream = useCallback(() => {
        console.log("stopCameraStream: Attempting to stop camera.");
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
            console.log("stopCameraStream: Camera stream stopped.");
        }
    }, []);
    
    const startCameraStream = async () => {
        console.log("startCameraStream: Attempting to start camera.");
        if (streamRef.current) {
            return streamRef.current;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
            streamRef.current = stream;
            console.log("startCameraStream: Camera started successfully.");
            return stream;
        } catch (err) {
            console.error("無法存取攝影機:", err);
            setStatusMessage(`無法存取攝影機: ${err.name}`);
            return null;
        }
    };

    const lookupProduct = useCallback(async (barcodeData, currentProductName, currentStoreName) => {
        // 如果 Firebase 尚未初始化，則不執行查詢
        if (!isAuthReady || !userId) {
            return;
        }
        
        const numericalID = generateProductId(barcodeData, currentProductName, currentStoreName);

        // Adjust early exit condition:
        // If no barcode and no product name, or if barcode is too short and no product name,
        // then we can't look up a product.
        if (!numericalID) { // If numericalID couldn't be generated, then we can't look up a product.
            setProductName('');
            setLookupStatus('ready');
            setProductHistory([]);
            return;
        }
        
        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);

            if (productSnap.exists()) {
                setProductName(productSnap.data().productName);
                setLookupStatus('found');
            } else {
                setLookupStatus('new');
            }

            const recordsQueryString = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID), // numericalID is already a string
                orderBy("timestamp", "desc")
            );
            const recordsSnapString = await getDocs(recordsQueryString);
            let records = recordsSnapString.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Attempt to query for numericalID as a number, if it's a valid number string
            const numericalIDAsNumber = parseInt(numericalID, 10);
            if (!isNaN(numericalIDAsNumber) && numericalIDAsNumber.toString() === numericalID) { // Check if it's a pure number string
                const recordsQueryNumber = query(
                    collection(db, "priceRecords"),
                    where("numericalID", "==", numericalIDAsNumber),
                    orderBy("timestamp", "desc")
                );
                const recordsSnapNumber = await getDocs(recordsQueryNumber);
                const recordsNumber = recordsSnapNumber.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Merge and deduplicate records
                const mergedRecordsMap = new Map();
                records.forEach(record => mergedRecordsMap.set(record.id, record));
                recordsNumber.forEach(record => mergedRecordsMap.set(record.id, record));
                records = Array.from(mergedRecordsMap.values()).sort((a, b) => (b.timestamp?.toDate ? b.timestamp.toDate().getTime() : 0) - (a.timestamp?.toDate ? a.timestamp.toDate().getTime() : 0));
            }
            setProductHistory(records);

        } catch (error) {
            console.error("查詢產品失敗 (Firestore):", error);
            setStatusMessage("查詢產品資料時發生錯誤。");
            setLookupStatus('ready');
            setProductHistory([]);
        }
    }, [isAuthReady, userId, setProductName, setLookupStatus, setProductHistory, setStatusMessage]);

    // 新增函數：處理 OCR 隊列的商店選擇
    const handleOcrQueueStoreSelect = useCallback((card) => {
        setEditingOcrCard(card);
        setIsOcrQueueStoreSelectorOpen(true);
    }, [setEditingOcrCard, setIsOcrQueueStoreSelectorOpen]);

    // 新增函數：處理 OCR 隊列的商店選擇確認
    const handleOcrQueueStoreSelectConfirm = useCallback((selectedStore) => {
        if (editingOcrCard) {
            // 更新待辨識卡片的商店名稱
            const updatedCards = pendingOcrCards.map(card => 
                card.id === editingOcrCard.id ? { ...card, storeName: selectedStore } : card
            );
            setPendingOcrCards(updatedCards);
        }
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [editingOcrCard, pendingOcrCards, setPendingOcrCards, setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 新增函數：處理 OCR 隊列的商店選擇器關閉
    const handleOcrQueueStoreSelectorClose = useCallback(() => {
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 正確地提前定義 performSaveAndCompare 函數（必須在 saveAndComparePrice 之前定義）
    const performSaveAndCompare = useCallback(async (selectedStore) => {
        const finalStoreName = selectedStore || storeName;
        const numericalID = generateProductId(barcode, productName, finalStoreName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const priceValue = parseFloat(finalPrice);

        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, quantity, unitType);

        if (!userId || !productName || isNaN(priceValue) || isNaN(parseFloat(quantity)) || parseFloat(quantity) <= 0 || calculatedUnitPrice === null) {
            showUserFriendlyError("請確保已輸入條碼、產品名稱、有效總價、數量和單位！", "資料驗證");
            setIsLoading(false);
            return;
        }
        if (!finalStoreName.trim()) {
            setIsStoreSelectorOpen(true);
            setIsLoading(false);
            return;
        }

        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);
            
            // 準備產品文檔數據
            const productData = {
                numericalID,
                barcodeData: barcode,
                productName,
                createdAt: productSnap.exists() ? productSnap.data().createdAt : serverTimestamp(),
                lastUpdatedBy: userId,
            };

            // 準備價格記錄數據
            const priceRecord = {
                numericalID,
                productName,
                storeName: finalStoreName,
                price: priceValue, // 總價
                quantity: parseFloat(quantity),
                unitType: unitType,
                unitPrice: calculatedUnitPrice, // 單價
                discountDetails: discountDetails || '',
                timestamp: serverTimestamp(),
                recordedBy: userId,
                // 保存原價和特價信息（如果有的話）
                originalPrice: ocrResult?.originalPrice ? parseFloat(ocrResult.originalPrice) : null,
                specialPrice: ocrResult?.specialPrice ? parseFloat(ocrResult.specialPrice) : null
            };

            // 儲存價格記錄
            const priceRecordDocRef = await addDoc(collection(db, "priceRecords"), priceRecord);
            
            // 檢查是否需要更新產品文檔中的最佳單價
            let isBestPrice = false;
            if (productSnap.exists()) {
                const existingProductData = productSnap.data();
                // 如果產品文檔中沒有 bestUnitPrice 或新價格更低，則更新
                if (existingProductData.bestUnitPrice === undefined || calculatedUnitPrice < existingProductData.bestUnitPrice) {
                    productData.bestUnitPrice = calculatedUnitPrice;
                    productData.bestPriceRecordRef = priceRecordDocRef.path; // 儲存指向最佳價格記錄的引用路徑
                    isBestPrice = true;
                } else {
                    // 保持現有的最佳價格信息
                    productData.bestUnitPrice = existingProductData.bestUnitPrice;
                    productData.bestPriceRecordRef = existingProductData.bestPriceRecordRef;
                }
            } else {
                // 新產品，當前價格就是最佳價格
                productData.bestUnitPrice = calculatedUnitPrice;
                productData.bestPriceRecordRef = priceRecordDocRef.path;
                isBestPrice = true;
            }
            
            // 儲存或更新產品文檔
            await setDoc(productRef, productData);

            // 準備比價結果
            let toastStatus, toastMessage, isBest, bestPrice, bestStore;

            if (isBestPrice) {
                isBest = true;
                bestPrice = calculatedUnitPrice;
                bestStore = finalStoreName;
                toastStatus = 'success';
                toastMessage = '恭喜！這是目前紀錄中的最低單價！';
            } else {
                isBest = false;
                bestPrice = productData.bestUnitPrice;
                
                // 從 Firestore 獲取最佳價格記錄的商店名稱
                try {
                    const bestPriceRecordDoc = await getDoc(doc(db, productData.bestPriceRecordRef));
                    if (bestPriceRecordDoc.exists()) {
                        bestStore = bestPriceRecordDoc.data().storeName;
                    } else {
                        bestStore = '未知商店';
                    }
                } catch (error) {
                    console.error("獲取最佳價格記錄失敗:", error);
                    bestStore = '未知商店';
                }
                
                toastStatus = 'warning';
                toastMessage = `非最低單價。歷史最低單價為 $${formatUnitPrice(productData.bestUnitPrice)} (${bestStore})`;
            }

            setComparisonResult({ isBest, bestPrice, bestStore, message: toastMessage });
            // 儲存成功時顯示提示訊息
            setSaveResultToast({ status: toastStatus, message: toastMessage, productName: productName });
            
            lookupProduct(barcode, productName, finalStoreName);

        } catch (error) {
            console.error("儲存或比價失敗 (Firestore):", error);
            const userMessage = handleFirestoreSaveError(error, "儲存價格資訊");
            showUserFriendlyError(userMessage);
        } finally {
            setIsLoading(false);
        }
    }, [userId, barcode, productName, currentPrice, discountDetails, storeName, lookupProduct, quantity, unitType, setSaveResultToast, setComparisonResult, setIsLoading, setIsStoreSelectorOpen, ocrResult]);

    // 正確地提前定義 saveAndComparePrice 函數
    const saveAndComparePrice = useCallback(async (selectedStore) => {
        // 確保 Firebase 已初始化，如果尚未完成初始化則強制初始化
        if (!isAuthReady) {
            // 顯示加載訊息並等待初始化完成
            setIsLoading(true);
            // 等待 Firebase 初始化完成
            const checkAuth = () => {
                if (isAuthReady) {
                    // 初始化完成後繼續執行
                    performSaveAndCompare(selectedStore);
                } else {
                    // 繼續等待
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
            return;
        }
        
        // 如果 Firebase 已準備好，直接執行保存操作
        performSaveAndCompare(selectedStore);
    }, [isAuthReady, performSaveAndCompare]);
    
    const handleAiCaptureSuccess = useCallback((result) => {
        const { scannedBarcode, productName, extractedPrice, storeName, discountDetails, quantity, unitType, specialPrice, capturedImage: receivedImage } = result;
        setOcrResult(result);
        
        // 設置捕獲的圖像
        if (receivedImage) {
            setCapturedImage(receivedImage);
        }
        
        const newBarcode = scannedBarcode || '';
        setBarcode(newBarcode);

        if (!newBarcode) {
            setStatusMessage("AI 未能識別條碼，請手動輸入或確保條碼清晰！");
        } else {
            setStatusMessage(`AI 分析成功！`);
        }

        setProductName(productName || '');
        
        // 優先使用特價，如果有的話
        const finalPrice = specialPrice && !isNaN(parseFloat(specialPrice)) ? specialPrice : extractedPrice;
        setCurrentPrice(finalPrice || '');
        
        setStoreName(storeName || '');
        setDiscountDetails(discountDetails || '');

        setQuantity(quantity || '');
        setUnitType(unitType || 'pcs');

        if (productName && newBarcode) {
            setLookupStatus('found');
        } else {
            setLookupStatus('new');
        }
    }, [setBarcode, setProductName, setCurrentPrice, setStoreName, setDiscountDetails, setOcrResult, setStatusMessage, setLookupStatus, setQuantity, setUnitType, setCapturedImage]);

    // 定義一個新的函式來處理 Firebase 備份
    const backupOcrCardToFirebase = useCallback(async (cardData) => {
        // 檢查 Firebase 是否準備好
        if (!isAuthReady || !userId) {
            // 由於功能要求是自動備份，若服務未準備好，則將其視為 pending 或 error (可選)
            console.warn("Firebase 服務尚未準備好，跳過備份。");
            // 由於此專案似乎有 MVP 階段屏蔽 Firebase 的歷史需求，
            // 這裡可以選擇將狀態設為 'error' 或保留 'pending'。
            // 為避免影響核心功能，建議在此處直接返回，讓卡片保持 'pending' 狀態。
            return;
        }

        const cardToSave = {
            ...cardData,
            userId: userId, // 儲存用戶 ID
            timestamp: serverTimestamp(), // 使用 Firebase 服務器時間戳
            // 移除本地 ID 和同步狀態，因為這些只用於本地 UI
            id: undefined, 
            syncStatus: undefined
        };

        try {
            // 將卡片數據儲存到 pendingOcrCards 集合
            const docRef = await addDoc(collection(db, "pendingOcrCards"), cardToSave);
            
            // 成功後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'success', fbDocId: docRef.id } : c
                )
            );

        } catch (error) {
            console.error("Firebase 待辨識卡片備份失敗:", error);
            handleFirestoreSaveError(error, "備份待辨識卡片"); // 使用錯誤處理機制
            
            // 失敗後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'error' } : c
                )
            );
        }
    }, [isAuthReady, userId, setPendingOcrCards]);

    // 新增函數：將辨識結果加入待確認序列
    const handleQueueNextCapture = useCallback((result) => {
        // 1. 建立具有初始同步狀態的新卡片物件
        const newCard = {
            ...result,
            id: uuidv4(), // 確保本地狀態有一個唯一 ID
            timestamp: Date.now(), // 本地時間戳 (用於排序/顯示)
            syncStatus: 'pending', // 初始狀態設為處理中
        };
        
        // 2. 更新本地狀態 (立即顯示卡片)
        setPendingOcrCards(prev => [...prev, newCard]);
        
        // 3. 更新本地時間戳
        localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString());

        // 4. 觸發 Firebase 備份
        backupOcrCardToFirebase(newCard); 
        
        setStatusMessage(`已將辨識結果加入待確認序列！`);
    }, [setPendingOcrCards, backupOcrCardToFirebase]);

    // 新增函數：移除待確認的辨識卡片
    const handleRemovePendingOcrCard = useCallback((cardId) => {
        setPendingOcrCards(prev => prev.filter(item => item.id !== cardId));
    }, []);

    const handleStoreSelect = useCallback((selectedStore) => {
        setStoreName(selectedStore);
        setIsStoreSelectorOpen(false);
        // 不再自動觸發保存操作，與其他頁面保持一致
    }, [setStoreName, setIsStoreSelectorOpen]);

    const handleCaptureModalClose = useCallback(() => {
        setIsCaptureModalOpen(false);
        stopCameraStream();
    }, [stopCameraStream]);

    const handleNewScanClick = async () => {
        clearForm();
        const stream = await startCameraStream();
        if (stream) {
            setIsCaptureModalOpen(true);
        } else {
            // 如果無法啟動相機，顯示錯誤訊息
            setStatusMessage("無法啟動相機，請檢查權限設置");
        }
    };

    const themePrimary = currentTheme.primary;
    const themeText = currentTheme.text;
    const themeLight = currentTheme.light;
    const themeBorder = currentTheme.border;
    const themeHover = currentTheme.hover; // 添加這一行來定義 themeHover

    const productNamePlaceholder = useMemo(() => {
        switch(lookupStatus) {
            case 'searching': return '正在查詢產品資料...';
            case 'found': return '產品名稱已自動載入';
            case 'new': return '產品不存在，請手動輸入名稱';
            default: return '請先輸入條碼或掃描條碼';
        }
    }, [lookupStatus]);

    if (!isAuthReady) {
        return <div className="flex items-center justify-center min-h-screen bg-gray-50"><p className="text-xl text-gray-700">正在連線至雲端服務...</p></div>;
    }

    if (currentPage === 'allRecords') {
        return <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />;
    }

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${themeLight}`}>
            <SaveResultToast result={saveResultToast} onClose={() => setSaveResultToast(null)} />
            
            {/* 新增 SettingsPage 的渲染 */}
            {isSettingsOpen && (
                <SettingsPage 
                    theme={currentTheme} 
                    onClose={() => setIsSettingsOpen(false)} 
                    onDataChange={handleDataRefresh}
                />
            )}

            {/* 根據 currentPage 狀態渲染不同頁面 */}
            {currentPage === 'main' && (
                <div className="max-w-xl mx-auto">
                    <header className="flex justify-between items-center mb-6 border-b pb-4">
                        <h1 className={`text-3xl font-extrabold ${themeText} flex items-center`}><Barcode className="w-8 h-8 mr-2" />條碼比價神器 (Cloud)</h1>
                        <div className="flex items-center space-x-3">
                            {/* 新增待辨識的按鈕 */}
                            <button 
                                onClick={() => setCurrentPage('ocrQueue')}
                                className={`relative p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`}
                                title={`待辨識 (${pendingOcrCards.length})`}
                            >
                                <Zap className="w-5 h-5" />
                                {pendingOcrCards.length > 0 && (
                                    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                                        {pendingOcrCards.length}
                                    </span>
                                )}
                            </button>
                            <button onClick={() => setCurrentPage('allRecords')} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="查看所有記錄"><Database className="w-5 h-5" /></button>
                            <button onClick={() => setIsThemeModalOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定介面主題"><PaintBucket className="w-5 h-5" /></button>
                            {/* 新增設定按鈕 */}
                            <button onClick={() => setIsSettingsOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定"><SettingsIcon className="w-5 h-5" /></button>
                            <p className="text-sm text-gray-500 hidden sm:block">User: {userId.slice(0, 8)}...</p>
                        </div>
                    </header>

                    {statusMessage && <div className="bg-blue-500 text-white p-3 rounded-lg shadow-md mb-4 text-center font-medium">{statusMessage}</div>}

                    {ocrResult && (
                        <div className="bg-yellow-100 border border-yellow-300 rounded-lg p-4 mb-6">
                            <h3 className="text-lg font-semibold text-yellow-800 mb-2">AI 辨識結果 (開發者確認區)</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm">
                                <div>條碼:</div><div>{ocrResult.scannedBarcode || 'N/A'}</div>
                                <div>品名:</div><div>{ocrResult.productName || 'N/A'}</div>
                                {/* 顯示原價和特價信息 */}
                                {ocrResult.specialPrice ? (
                                    <>
                                        {ocrResult.originalPrice && (
                                            <>
                                                <div>原價:</div><div className="line-through text-red-500">${ocrResult.originalPrice.toFixed(2)}</div>
                                            </>
                                        )}
                                        <div>特價:</div><div className="text-green-600 font-bold">${ocrResult.specialPrice.toFixed(2)}</div>
                                    </>
                                ) : (
                                    <>
                                        <div>價格:</div><div>${ocrResult.extractedPrice || 'N/A'}</div>
                                    </>
                                )}
                                <div>數量:</div><div>{ocrResult.quantity || 'N/A'}</div>
                                <div>商店:</div><div>{ocrResult.storeName || 'N/A'}</div>
                                <div>折扣:</div><div>{ocrResult.discountDetails || '無'}</div>
                            </div>
                            <button onClick={() => setOcrResult(null)} className="mt-3 px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 text-sm">關閉</button>
                        </div>
                    )}

                    <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${themeBorder}`}>
                        <h2 className={`text-xl font-semibold ${themeText} mb-6 flex items-center`}><Zap className="w-5 h-5 mr-2" />步驟 1: AI 視覺自動擷取</h2>
                        <button className={`w-full p-4 rounded-lg text-white font-bold text-lg shadow-xl transition-all ${themePrimary} hover:opacity-80 flex items-center justify-center`} onClick={handleNewScanClick}>
                            <Camera className="inline-block w-6 h-6 mr-3" />開啟鏡頭擷取
                        </button>
                        <hr className="my-6 border-gray-200" />
                        <h2 className={`text-xl font-semibold text-gray-700 mb-4 flex items-center`}><FileText className="w-5 h-5 mr-2" />步驟 2: 檢查或手動輸入</h2>
                        
                        {/* 新增的擷取畫面顯示區塊 */}
                        {capturedImage && (
                            <div className="mb-6">
                                <label className="block text-gray-700 font-medium mb-2">擷取畫面 (請確認辨識資料是否正確)</label>
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                    <div className="relative w-full aspect-video">
                                        {capturedImage.startsWith('data:image') ? (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        ) : (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        )}
                                    </div>
                                </div>
                                <p className="text-sm text-gray-500 mt-2">此圖片將持續顯示直到進行下一次辨識或退出應用程式</p>
                            </div>
                        )}
                        
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">條碼數據</label>
                            <input type="text" value={barcode} onChange={(e) => setBarcode(e.target.value)} placeholder="AI 自動填入，或手動輸入" className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" />
                        </div>
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">產品名稱</label>
                            <input type="text" value={productName} onChange={(e) => setProductName(e.target.value)} placeholder={productNamePlaceholder} className={`w-full p-3 border border-gray-300 rounded-lg ${lookupStatus === 'found' ? 'bg-green-50' : lookupStatus === 'new' ? 'bg-yellow-50' : ''}`} readOnly={lookupStatus === 'found' && !ocrResult} />
                            <p className="text-sm text-gray-500 mt-1">ID (Hash): {barcode ? djb2Hash(barcode) : 'N/A'}</p>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">總價 ($) <span className="text-red-500">*</span></label>
                                <input type="number" value={currentPrice} onChange={(e) => setCurrentPrice(e.target.value)} placeholder="AI 擷取" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">商店名稱</label>
                                <input 
                                    type="text" 
                                    value={storeName} 
                                    onFocus={() => setIsStoreSelectorOpen(true)}
                                    readOnly
                                    placeholder="點擊選擇商店"
                                    className="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 cursor-pointer"
                                />
                            </div>
                        </div>
                        <div className="grid grid-cols-3 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">數量 <span className="text-red-500">*</span></label>
                                <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="例如: 500" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單位 <span className="text-red-500">*</span></label>
                                <select value={unitType} onChange={(e) => setUnitType(e.target.value)} className="w-full p-3 border border-gray-300 rounded-lg">
                                    <option value="ml">ml (毫升)</option>
                                    <option value="g">g (克)</option>
                                    <option value="pcs">pcs (個/包/支/條)</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單價 (每100g/ml)</label>
                                <input type="text" value={formatUnitPrice(unitPrice)} readOnly className="w-full p-3 border border-gray-300 rounded-lg bg-gray-100" />
                            </div>
                        </div>
                        <div className="mb-6">
                            <label className="block text-gray-700 font-medium mb-1">優惠細節</label>
                            <input type="text" value={discountDetails} onChange={(e) => setDiscountDetails(e.target.value)} placeholder="例如: 買二送一" className="w-full p-3 border border-gray-300 rounded-lg" />
                        </div>
                        <button className={`w-full mt-4 p-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-emerald-500 hover:bg-emerald-600`} onClick={() => saveAndComparePrice()} disabled={isLoading}>
                            <ClipboardCheck className="inline-block w-5 h-5 mr-2" />{isLoading ? '處理中...' : '步驟 3: 儲存紀錄並比價'}
                        </button>
                    </div>

                    <div className="mt-8">
                        <h2 className={`text-xl font-semibold ${themeText} mb-4 flex items-center`}>
                            <DollarSign className="w-5 h-5 mr-2" />
                            比價結果 {productName && <span className="ml-2 font-normal text-gray-500">- {productName}</span>}
                        </h2>
                        <div className={`p-6 rounded-xl shadow-xl border-2 ${comparisonResult.isBest ? 'border-green-500 bg-green-50' : 'border-yellow-500 bg-yellow-50'}`}>
                            <p className={`text-lg font-bold ${comparisonResult.isBest ? 'text-green-700' : 'text-yellow-700'}`}>{comparisonResult.message}</p>
                            {comparisonResult.bestPrice && <p className="text-sm text-gray-600 mt-2">歷史最低標價: ${comparisonResult.bestPrice}</p>}
                            <p className="text-xs text-gray-500 mt-2">**附註:** 您的紀錄已安全儲存在雲端。</p>
                        </div>
                    </div>

                    {(lookupStatus === 'found' || lookupStatus === 'new') && <PriceHistoryDisplay historyRecords={productHistory} theme={currentTheme} />}
                    
                    {/* 在主介面添加一個快捷處理待辨識卡片的按鈕 */}
                    {pendingOcrCards.length > 0 && (
                        <div className="mt-4 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold text-yellow-800">有待辨識的項目</h3>
                                    <p className="text-sm text-yellow-600">您有 {pendingOcrCards.length} 個待辨識的項目等待處理</p>
                                </div>
                                <button 
                                    onClick={() => {
                                        // 處理第一個待辨識的卡片
                                        const firstCard = pendingOcrCards[0];
                                        
                                        // 設置表單數據
                                        setOcrResult(firstCard);
                                        setCapturedImage(firstCard.capturedImage);
                                        setBarcode(firstCard.scannedBarcode || '');
                                        setProductName(firstCard.productName || '');
                                        setCurrentPrice(firstCard.extractedPrice || '');
                                        setStoreName(firstCard.storeName || '');
                                        setDiscountDetails(firstCard.discountDetails || '');
                                        setQuantity(firstCard.quantity || '');
                                        setUnitType(firstCard.unitType || 'pcs');
                                        
                                        // 計算單價
                                        const priceValue = parseFloat(firstCard.extractedPrice);
                                        const qty = parseFloat(firstCard.quantity);
                                        if (!isNaN(priceValue) && !isNaN(qty) && qty > 0) {
                                            const calculatedUnitPrice = calculateUnitPrice(priceValue, qty, firstCard.unitType);
                                            setUnitPrice(calculatedUnitPrice);
                                        }
                                        
                                        // 更新狀態
                                        if (firstCard.productName && firstCard.scannedBarcode) {
                                            setLookupStatus('found');
                                        } else {
                                            setLookupStatus('new');
                                        }
                                        
                                        // 從待辨識序列中移除該卡片
                                        setPendingOcrCards(prev => prev.filter(item => item.id !== firstCard.id));
                                        
                                        // 顯示提示訊息
                                        setStatusMessage(`已載入待辨識項目: ${firstCard.productName || '未命名產品'}`);
                                    }}
                                    className={`px-4 py-2 rounded-lg text-white font-medium ${themePrimary} ${themeHover}`}
                                >
                                    處理第一個待辨識項目
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            )}
            
            {currentPage === 'allRecords' && (
                <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />
            )}
            
            {currentPage === 'ocrQueue' && (
                <OcrQueuePage 
                    theme={currentTheme} 
                    onBack={() => setCurrentPage('main')} 
                    pendingOcrCards={pendingOcrCards}
                    onRemoveCard={handleRemovePendingOcrCard}
                    onStoreSelect={setPendingOcrCards}
                    isStoreSelectorOpen={isOcrQueueStoreSelectorOpen}
                    onStoreSelectCallback={handleOcrQueueStoreSelect}
                    onCloseStoreSelector={handleOcrQueueStoreSelectorClose}
                />
            )}

            {isThemeModalOpen && <ThemeSelector theme={currentTheme} saveTheme={saveUserTheme} onClose={() => setIsThemeModalOpen(false)} />}
            {isCaptureModalOpen && <AIOcrCaptureModal theme={currentTheme} onAnalysisSuccess={handleAiCaptureSuccess} onClose={handleCaptureModalClose} stream={streamRef.current} onQueueNextCapture={handleQueueNextCapture} />}
            {isStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleStoreSelect} onClose={() => setIsStoreSelectorOpen(false)} />}
            {isOcrQueueStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleOcrQueueStoreSelectConfirm} onClose={handleOcrQueueStoreSelectorClose} />}
        </div>
    );
}

export default App;
</file>

<file path="components/AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        
        // 計算預覽框在視頻中的實際像素位置和尺寸 (75% 中心區域)
        const cropWidth = video.videoWidth * 0.75;
        const cropHeight = video.videoHeight * 0.75;
        const cropX = (video.videoWidth - cropWidth) / 2;
        const cropY = (video.videoHeight - cropHeight) / 2;
        
        // 創建最終的 canvas 來繪製裁切後的圖片
        const canvas = document.createElement('canvas');
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        const ctx = canvas.getContext('2d');
        
        // 從視頻中裁切並繪製 75% 中心區域
        ctx.drawImage(
            video, 
            cropX, cropY, cropWidth, cropHeight,  // source rectangle
            0, 0, cropWidth, cropHeight           // destination rectangle
        );
        
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片

        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
components.xml
DataManagement.js
SettingsPage.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

</files>
</file>

<file path="DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

</files>
</file>

<file path="components/DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="components/SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

<file path="firebase-config.js">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAtaZL06wkWJHhOJdne2Z_h9fMIEYldgjM",
  authDomain: "barcodepricing-00898.firebaseapp.com",
  projectId: "barcodepricing-00898",
  storageBucket: "barcodepricing-00898.firebasestorage.app",
  messagingSenderId: "286146042453",
  appId: "1:286146042453:web:14a20a662dcf3d06f592dc",
  measurementId: "G-6GMRVJ4S52"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

export { db };
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="OcrQueuePage.js">
import React, { useState, useEffect, useCallback } from 'react';
import { ArrowLeft, Trash2, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { db } from './firebase-config.js';
import { doc, setDoc, addDoc, collection, serverTimestamp, getDoc, query, where, getDocs } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 計算 localStorage 使用量的函數
function getLocalStorageUsage() {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += (localStorage[key].length + key.length) * 2; // 每個字符佔用 2 bytes
    }
  }
  const used = (total / 1024).toFixed(2); // 轉換為 KB
  const quota = 5120; // 大多数瀏覽器的 localStorage 限制約為 5MB
  const percentage = ((used / quota) * 100).toFixed(2);
  
  return {
    used: used,
    quota: quota,
    percentage: percentage
  };
}

// 刪除確認對話框組件
function DeleteConfirmation({ card, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p className="mb-4">您確定要刪除此待辨識項目嗎？</p>
                <p className="mb-4 font-semibold text-gray-800">{card.productName || '未命名產品'}</p>
                <div className="flex justify-end space-x-3">
                    <button 
                        onClick={onClose}
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                    >
                        取消
                    </button>
                    <button 
                        onClick={onConfirm}
                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                    >
                        確認刪除
                    </button>
                </div>
            </div>
        </div>
    );
}

function OcrQueuePage({ theme, onBack, pendingOcrCards, onRemoveCard, onStoreSelect, 
    isStoreSelectorOpen, onStoreSelectCallback, onCloseStoreSelector }) {
    const [queueStats, setQueueStats] = useState({
        total: 0,
        oldest: null,
        newest: null
    });
    
    // 新增狀態：localStorage 使用量
    const [localStorageUsage, setLocalStorageUsage] = useState({
        used: 0,
        quota: 5120,
        percentage: 0
    });
    
    // 新增狀態：刪除確認對話框
    const [deleteConfirmation, setDeleteConfirmation] = useState(null);
    
    // 新增狀態：正在編輯的卡片
    // 移除 editingCard 狀態，因為現在由父組件控制
    // const [editingCard, setEditingCard] = useState(null);
    
    // 新增狀態：比價結果
    const [priceComparisonResults, setPriceComparisonResults] = useState({});

    useEffect(() => {
        if (pendingOcrCards.length > 0) {
            const timestamps = pendingOcrCards.map(card => card.timestamp);
            setQueueStats({
                total: pendingOcrCards.length,
                oldest: Math.min(...timestamps),
                newest: Math.max(...timestamps)
            });
        } else {
            setQueueStats({
                total: 0,
                oldest: null,
                newest: null
            });
        }
        
        // 更新 localStorage 使用量
        setLocalStorageUsage(getLocalStorageUsage());
    }, [pendingOcrCards]);

    const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleString('zh-TW');
    };

    const calculateDuration = (timestamp) => {
        const now = Date.now();
        const diffMs = now - timestamp;
        const diffSecs = Math.floor(diffMs / 1000);
        const diffMins = Math.floor(diffSecs / 60);
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            return `${diffHours}小時前`;
        } else if (diffMins > 0) {
            return `${diffMins}分鐘前`;
        } else {
            return `${diffSecs}秒前`;
        }
    };

    // 處理刪除操作
    const handleDeleteClick = (card) => {
        setDeleteConfirmation(card);
    };

    // 確認刪除
    const confirmDelete = () => {
        if (deleteConfirmation) {
            onRemoveCard(deleteConfirmation.id);
            setDeleteConfirmation(null);
            // 刪除後更新 localStorage 使用量
            setTimeout(() => {
                setLocalStorageUsage(getLocalStorageUsage());
            }, 100);
        }
    };

    // 取消刪除
    const cancelDelete = () => {
        setDeleteConfirmation(null);
    };

    // 處理儲存操作 - 檢查商店名稱
    const handleSaveClick = async (card) => {
        // 檢查商店名稱是否為空白
        if (!card.storeName || card.storeName.trim() === '') {
            // 如果商店名稱為空白，顯示商店選擇器
            onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
        } else {
            // 如果商店名稱不為空白，直接儲存（不再彈出確認對話框）
            try {
                // 儲存到 Firebase
                await saveOcrCardToFirebase(card);
                
                // 從待辨識序列中移除
                onRemoveCard(card.id);
                
                // 儲存後更新 localStorage 使用量
                setTimeout(() => {
                    setLocalStorageUsage(getLocalStorageUsage());
                }, 100);
                
                // 儲存成功時不顯示任何訊息
            } catch (error) {
                console.error("儲存失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "儲存待辨識卡片");
                showUserFriendlyError(userMessage);
            }
        }
    };

    // 處理卡片欄位變更
    const handleCardChange = (cardId, field, value) => {
        const updatedCards = pendingOcrCards.map(card => 
            card.id === cardId ? { ...card, [field]: value } : card
        );
        onStoreSelect(updatedCards);
        
        // 當價格相關欄位變更時，重新計算比價結果
        if (field === 'extractedPrice' || field === 'specialPrice' || field === 'originalPrice' || field === 'quantity' || field === 'unitType') {
            // 延遲一點時間再重新計算，確保狀態已更新
            setTimeout(() => {
                const fetchPriceComparisonResults = async () => {
                    const results = {};
                    for (const card of updatedCards) {
                        const result = await checkIfBestPrice(card, updatedCards);
                        results[card.id] = result;
                    }
                    setPriceComparisonResults(results);
                };
                
                fetchPriceComparisonResults();
            }, 0);
        }
    };

    // 處理商店欄位點擊
    const handleStoreClick = (card) => {
        // 阻止默认行为，防止移动设备上弹出键盘
        onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
    };

    // 儲存 OCR 卡片到 Firebase
    const saveOcrCardToFirebase = async (card) => {
        // 生成產品 ID
        const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
        const priceValue = parseFloat(finalPrice);
        
        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
        
        // 儲存產品資訊
        const productRef = doc(db, "products", numericalID.toString());
        const productSnap = await getDoc(productRef);
        if (!productSnap.exists()) {
            await setDoc(productRef, {
                numericalID,
                barcodeData: card.scannedBarcode,
                productName: card.productName,
                createdAt: serverTimestamp(),
                lastUpdatedBy: "ocr-queue", // 標記為來自 OCR 隊列
            });
        }
        
        // 儲存價格記錄
        const priceRecord = {
            numericalID,
            productName: card.productName,
            storeName: card.storeName,
            price: priceValue, // 總價
            quantity: parseFloat(card.quantity),
            unitType: card.unitType,
            unitPrice: calculatedUnitPrice, // 單價
            discountDetails: card.discountDetails || '',
            timestamp: serverTimestamp(),
            recordedBy: "ocr-queue", // 標記為來自 OCR 隊列
            // 保存原價和特價信息（如果有的話）
            originalPrice: card.originalPrice ? parseFloat(card.originalPrice) : null,
            specialPrice: card.specialPrice ? parseFloat(card.specialPrice) : null
        };
        
        await addDoc(collection(db, "priceRecords"), priceRecord);
    };

    // 生成產品 ID 的函數
    function generateProductId(barcode, productName, storeName) {
        function djb2Hash(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i);
            }
            return hash >>> 0;
        }
        
        if (barcode) {
            return djb2Hash(barcode).toString();
        } else {
            // Combine productName and storeName to create a unique ID for products without barcodes
            return djb2Hash(`${productName}-${storeName}`).toString();
        }
    }

    // 新增函數：檢查價格是否為歷史最低（包含待辨識序列中的卡片）
    const checkIfBestPrice = useCallback(async (card, allCards) => {
        try {
            // 生成產品 ID
            const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
            
            if (!numericalID) return null;
            
            // 使用新的價格計算函數來確定最終價格
            const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
            const priceValue = parseFloat(finalPrice);
            
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
            
            if (calculatedUnitPrice === null) return null;
            
            // 查詢 Firebase 中該產品的所有價格記錄
            const recordsQuery = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID)
            );
            
            const recordsSnap = await getDocs(recordsQuery);
            const records = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 準備所有記錄以進行比較（包括當前記錄和待辨識序列中的相同產品）
            let allRecordsForCompare = [...records, { 
                unitPrice: calculatedUnitPrice,
                timestamp: new Date()
            }];
            
            // 添加待辨識序列中相同產品的卡片（排除當前卡片）
            const sameProductCards = allCards.filter(c => 
                c.id !== card.id && 
                generateProductId(c.scannedBarcode, c.productName, c.storeName) === numericalID
            );
            
            // 將相同產品的卡片添加到比較列表中
            sameProductCards.forEach(c => {
                const cardFinalPrice = calculateFinalPrice(c.extractedPrice, c.specialPrice);
                const cardPriceValue = parseFloat(cardFinalPrice);
                const cardUnitPrice = calculateUnitPrice(cardPriceValue, c.quantity, c.unitType);
                
                if (cardUnitPrice !== null) {
                    allRecordsForCompare.push({
                        unitPrice: cardUnitPrice,
                        timestamp: new Date(c.id) // 使用卡片 ID 作為時間戳
                    });
                }
            });

            // 如果沒有歷史記錄，則當前價格就是最低價
            if (allRecordsForCompare.length <= 1) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            }
            
            // 使用與主頁面相同的比價邏輯
            const bestDeal = allRecordsForCompare.reduce((best, cur) => {
                const curUnitPrice = cur.unitPrice !== undefined && cur.unitPrice !== null ? cur.unitPrice : Infinity;
                const bestUnitPrice = best.unitPrice !== undefined && best.unitPrice !== null ? best.unitPrice : Infinity;
                return curUnitPrice < bestUnitPrice ? cur : best;
            });

            const isBest = calculatedUnitPrice <= (bestDeal.unitPrice !== undefined && bestDeal.unitPrice !== null ? bestDeal.unitPrice : Infinity);
            
            if (isBest) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            } else {
                return { isBest: false, message: "非歷史最低價", backgroundColor: "bg-yellow-100" };
            }
        } catch (error) {
            console.error("比價檢查失敗:", error);
            return null;
        }
    }, []);

    // 當待辨識卡片列表改變時，重新計算比價結果
    useEffect(() => {
        const fetchPriceComparisonResults = async () => {
            const results = {};
            for (const card of pendingOcrCards) {
                const result = await checkIfBestPrice(card, pendingOcrCards);
                results[card.id] = result;
            }
            setPriceComparisonResults(results);
        };
        
        if (pendingOcrCards.length > 0) {
            fetchPriceComparisonResults();
        } else {
            setPriceComparisonResults({});
        }
    }, [pendingOcrCards, checkIfBestPrice]);

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${theme.bg}`}>
            <div className="max-w-2xl mx-auto">
                <div className="flex items-center mb-6 border-b pb-4">
                    <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4">
                        <ArrowLeft className="mr-1" size={20} />返回
                    </button>
                    <h1 className={`text-2xl font-bold ${theme.text} flex items-center`}>
                        <Clock className="w-6 h-6 mr-2" />待辨識序列管理
                    </h1>
                </div>

                {queueStats.total > 0 ? (
                    <div className="mb-6 p-4 bg-white rounded-lg shadow">
                        <h2 className="text-lg font-semibold mb-3">序列統計</h2>
                        {/* 改為橫式條列呈現 */}
                        <div className="flex flex-wrap gap-4">
                            <div className="flex items-center">
                                <div className="bg-blue-100 p-2 rounded-full mr-2">
                                    <span className="text-blue-600 font-bold">{queueStats.total}</span>
                                </div>
                                <span className="text-gray-600">總數</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-green-100 p-2 rounded-full mr-2">
                                    <span className="text-green-600 font-bold">{queueStats.oldest ? formatTime(queueStats.oldest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最早</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-purple-100 p-2 rounded-full mr-2">
                                    <span className="text-purple-600 font-bold">{queueStats.newest ? formatTime(queueStats.newest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最新</span>
                            </div>
                        </div>
                        
                        {/* localStorage 使用量顯示 */}
                        <div className="mt-4 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                ) : (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <AlertCircle size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">無待辨識項目</h3>
                        <p className="text-gray-500">目前沒有任何待確認的辨識卡片</p>
                        
                        {/* localStorage 使用量顯示（即使沒有項目也顯示） */}
                        <div className="mt-6 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                )}

                <div className="space-y-4">
                    {pendingOcrCards.map((card) => (
                        <div 
                            key={card.id} 
                            className={`bg-white p-4 rounded-lg shadow border-4 relative ${
                                priceComparisonResults[card.id]?.isBest 
                                    ? 'border-green-500' 
                                    : 'border-yellow-500'
                            }`}
                        >
                            <div className="flex justify-between items-start">
                                <div className="flex-1">
                                    {/* 將比價結果移到卡片頂部 */}
                                    {priceComparisonResults[card.id] && (
                                        <div className={`mb-3 p-2 rounded text-center text-base font-bold ${
                                            priceComparisonResults[card.id].isBest 
                                                ? 'bg-green-500 text-white' 
                                                : 'bg-yellow-500 text-pink-800'
                                        }`}>
                                            {priceComparisonResults[card.id].message}
                                        </div>
                                    )}
                                    
                                    <input
                                        type="text"
                                        value={card.productName || ''}
                                        onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                        className="font-bold text-lg text-gray-800 w-full p-1 mb-2 border-b border-gray-300 focus:border-blue-500 focus:outline-none"
                                        placeholder="產品名稱"
                                    />
                                    
                                    {/* 擷取畫面顯示 */}
                                    {card.capturedImage && (
                                        <div className="mt-3 mb-3">
                                            <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                                <div className="relative w-full aspect-video">
                                                    {card.capturedImage.startsWith('data:image') ? (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    ) : (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-1 mt-1 text-sm">
                                        {/* 條碼欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">條碼數據</label>
                                            <input
                                                type="text"
                                                value={card.scannedBarcode || ''}
                                                onChange={(e) => handleCardChange(card.id, 'scannedBarcode', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="條碼"
                                            />
                                        </div>
                                        
                                        {/* 產品名稱欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">產品名稱</label>
                                            <input
                                                type="text"
                                                value={card.productName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="產品名稱"
                                            />
                                        </div>
                                        
                                        {/* 商店欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">商店名稱</label>
                                            <input
                                                type="text"
                                                value={card.storeName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'storeName', e.target.value)}
                                                onClick={(e) => {
                                                    e.preventDefault();
                                                    handleStoreClick(card);
                                                }}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 bg-gray-50 cursor-pointer"
                                                placeholder="點擊選擇商店"
                                            />
                                        </div>
                                        
                                        {/* 價格欄位 */}
                                        {card.specialPrice !== undefined ? (
                                            <>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">原價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.originalPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'originalPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                        placeholder="原價"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">特價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.specialPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'specialPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 text-green-600 font-bold"
                                                        placeholder="特價"
                                                    />
                                                </div>
                                            </>
                                        ) : (
                                            <div className="col-span-2">
                                                <label className="block text-gray-700 font-medium mb-0.5">總價 ($)</label>
                                                <input
                                                    type="number"
                                                    value={card.extractedPrice || ''}
                                                    onChange={(e) => handleCardChange(card.id, 'extractedPrice', e.target.value)}
                                                    className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                    placeholder="價格"
                                                />
                                            </div>
                                        )}
                                        
                                        {/* 數量和單位 */}
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">數量</label>
                                            <input
                                                type="text"
                                                value={card.quantity || ''}
                                                onChange={(e) => handleCardChange(card.id, 'quantity', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="數量"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">單位</label>
                                            <select
                                                value={card.unitType || 'pcs'}
                                                onChange={(e) => handleCardChange(card.id, 'unitType', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                            >
                                                <option value="ml">ml (毫升)</option>
                                                <option value="g">g (克)</option>
                                                <option value="pcs">pcs (個/包/支/條)</option>
                                            </select>
                                        </div>
                                        
                                        {/* 單價 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">單價 (每100g/ml)</label>
                                            <input
                                                type="text"
                                                value={formatUnitPrice(card.unitPrice)}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded bg-gray-100"
                                            />
                                        </div>
                                        
                                        {/* 優惠資訊 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">優惠細節</label>
                                            <input
                                                type="text"
                                                value={card.discountDetails || ''}
                                                onChange={(e) => handleCardChange(card.id, 'discountDetails', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="優惠資訊"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>加入時間: {formatTime(card.timestamp)}</p>
                                        <p>運行時間: {calculateDuration(card.timestamp)}</p>
                                    </div>
                                    
                                    {/* 新增狀態圖示區塊 - 位於運行時間下面 */}
                                    <div className="absolute bottom-2 right-2">
                                        {card.syncStatus === 'pending' && (
                                            <Clock 
                                                className="w-4 h-4 text-yellow-500 animate-spin" 
                                                title="正在同步至 Firebase..." 
                                            />
                                        )}
                                        {card.syncStatus === 'success' && (
                                            <CheckCircle 
                                                className="w-4 h-4 text-green-500" 
                                                title="已成功同步至 Firebase" 
                                            />
                                        )}
                                        {card.syncStatus === 'error' && (
                                            <AlertCircle 
                                                className="w-4 h-4 text-red-500" 
                                                title="同步失敗，請檢查網路或重試" 
                                            />
                                        )}
                                    </div>
                                </div>
                                <div className="flex flex-col">
                                    <button 
                                        onClick={() => handleSaveClick(card)}
                                        className="p-2 text-green-500 hover:text-green-700 hover:bg-green-50 rounded-full"
                                        title="確認儲存"
                                    >
                                        <CheckCircle size={20} />
                                    </button>
                                    <button 
                                        onClick={() => handleDeleteClick(card)}
                                        className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full mt-5"
                                        title="刪除"
                                    >
                                        <Trash2 size={20} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            
            {/* 刪除確認對話框 - 保留 */}
            {deleteConfirmation && (
                <DeleteConfirmation 
                    card={deleteConfirmation}
                    onClose={cancelDelete}
                    onConfirm={confirmDelete}
                />
            )}
        </div>
    );
}

export default OcrQueuePage;
</file>

<file path="src.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AllRecordsPage.js
App.css
App.js
components/AIOcrCaptureModal.js
components/AIOcrCaptureModal備份
components/components.xml
components/DataManagement.js
components/SettingsPage.js
firebase-config.js
index.css
index.js
OcrQueuePage.js
src.xml
StoreSelector.js
utils/errorHandler.js
utils/errorHandler.test.js
utils/priceCalculations.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AllRecordsPage.js">
import React, { useState, useEffect, useMemo, useRef, useCallback, useLayoutEffect } from 'react';
import { ArrowLeft, Database, TrendingUp, Edit, Trash2, Save, X, CheckCircle, Search } from 'lucide-react';
import { collection, getDocs, query, orderBy, updateDoc, deleteDoc, doc } from 'firebase/firestore';
import { calculateUnitPrice, formatUnitPrice } from './utils/priceCalculations';
import StoreSelector from './StoreSelector';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 圖表組件
const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, productName }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp).sort((a, b) => a.timestamp - b.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間無足夠變化可繪圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <TrendingUp className="mr-1 text-gray-500" size={16} />
                單價走勢 - {productName}
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke="#4F46E5" strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === validRecords.length - 1 ? '#10B981' : '#4F46E5'} title={`${record.displayPrice.toFixed(2)} at ${record.timestamp.toLocaleDateString()}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>{new Date(minTimestamp).toLocaleDateString()}</span>
                <span>{new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

// Fuzzy search function
function fuzzyMatch(pattern, text) {
    const pattern_lower = pattern.toLowerCase();
    const text_lower = text.toLowerCase();
    let patternIdx = 0;
    let textIdx = 0;
    let score = 0;
    let consecutive = 0;
    let firstMatchIndex = -1;

    // Iterate through text to find pattern characters
    while (patternIdx < pattern_lower.length && textIdx < text_lower.length) {
        if (pattern_lower[patternIdx] === text_lower[textIdx]) {
            if (firstMatchIndex === -1) {
                firstMatchIndex = textIdx;
            }
            score += 1;
            // Add bonus for consecutive matches
            if (consecutive > 0) {
                score += consecutive;
            }
            consecutive++;
            patternIdx++;
        } else {
            consecutive = 0;
        }
        textIdx++;
    }

    // If the whole pattern was found
    if (patternIdx === pattern_lower.length) {
        // Add bonus for being a prefix
        if (firstMatchIndex === 0) {
            score += 5;
        }
        // Add bonus for tightness of the match
        const matchDensity = pattern.length / (textIdx - firstMatchIndex);
        score *= (1 + matchDensity);

        return score;
    }

    return 0;
}

// 可滑動的記錄項目
function SwipeableRecord({ children, onEdit, onDelete }) {
    const [translateX, setTranslateX] = useState(0);
    const touchStartX = useRef(0);
    const itemRef = useRef(null);
    const buttonsRef = useRef(null);

    const handleTouchStart = (e) => {
        touchStartX.current = e.touches[0].clientX;
    };

    const handleTouchMove = (e) => {
        const touchCurrentX = e.touches[0].clientX;
        const diff = touchCurrentX - touchStartX.current;
        if (diff < 0) { // 只允許向左滑動
            setTranslateX(Math.max(diff, -160)); // -160 是按鈕寬度的總和
        }
    };

    const handleTouchEnd = () => {
        if (translateX < -80) {
            setTranslateX(-160);
        } else {
            setTranslateX(0);
        }
    };

    useEffect(() => {
        const handleGlobalClick = (e) => {
            if (buttonsRef.current && !buttonsRef.current.contains(e.target)) {
                setTranslateX(0);
            }
        };

        if (translateX !== 0) {
            document.addEventListener('click', handleGlobalClick, true);
        }

        return () => {
            document.removeEventListener('click', handleGlobalClick, true);
        };
    }, [translateX]);

    const handleEdit = () => {
        onEdit();
        setTranslateX(0);
    };

    const handleDelete = () => {
        onDelete();
        setTranslateX(0);
    };

    return (
        <div className="relative overflow-hidden">
            <div ref={buttonsRef} className="absolute top-0 right-0 h-full flex items-center">
                <button onClick={handleEdit} className="bg-blue-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Edit size={20} />
                    <span>編輯</span>
                </button>
                <button onClick={handleDelete} className="bg-red-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Trash2 size={20} />
                    <span>刪除</span>
                </button>
            </div>
            <div
                ref={itemRef}
                className="transition-transform duration-300 ease-in-out"
                style={{ transform: `translateX(${translateX}px)` }}
                onTouchStart={handleTouchStart}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleTouchEnd}
            >
                {children}
            </div>
        </div>
    );
}


// 產品記錄組件
function ProductRecord({ product, records, theme, onEdit, onDelete }) {
    const formattedRecords = records.map(r => ({ ...r, timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp) })).sort((a, b) => b.timestamp - a.timestamp);
    
    const latestRecord = formattedRecords[0];
    if (!latestRecord) return null; // 如果沒有記錄，則不渲染此組件

    const validUnitPrices = formattedRecords.map(r => r.unitPrice).filter(p => !isNaN(p) && p !== undefined && p !== null);
    const lowestUnitPrice = validUnitPrices.length > 0 ? Math.min(...validUnitPrices) : 0;
    const highestUnitPrice = validUnitPrices.length > 0 ? Math.max(...validUnitPrices) : 0;
    const avgUnitPrice = validUnitPrices.length > 0 ? validUnitPrices.reduce((sum, p) => sum + p, 0) / validUnitPrices.length : 0;

    return (
        <div className={`p-4 rounded-xl shadow-lg bg-white border-t-4 ${theme.border} mb-6`}>
            <div className="flex justify-between items-start">
                <div>
                    <h3 className="text-lg font-bold text-gray-800">{product.productName}</h3>
                    <p className="text-sm text-gray-600">條碼: {product.barcodeData}</p>
                    <p className="text-xs text-gray-500">ID: {product.numericalID}</p>
                </div>
                <div className="text-right">
                    {/* 顯示原價和特價信息 */}
                    {latestRecord.specialPrice ? (
                        <div>
                            {latestRecord.originalPrice && (
                                <p className="text-lg text-gray-500 line-through">${latestRecord.originalPrice.toFixed(2)}</p>
                            )}
                            <p className="text-2xl font-bold text-indigo-600">${latestRecord.specialPrice.toFixed(2)}</p>
                            <p className="text-xs text-gray-500">@{formatUnitPrice(latestRecord.unitPrice)}</p>
                        </div>
                    ) : (
                        <p className="text-2xl font-bold text-indigo-600">{formatUnitPrice(latestRecord.unitPrice) === '--' ? (isNaN(latestRecord.price) ? 'N/A' : `$${(latestRecord.price || 0).toFixed(2)}`) : `$${(latestRecord.price || 0).toFixed(2)} @${formatUnitPrice(latestRecord.unitPrice)}`}</p>
                    )}
                    <p className="text-xs text-gray-500">{latestRecord.timestamp.toLocaleDateString()}</p>
                    {/* 顯示數量和單位 */}
                    {latestRecord.quantity && latestRecord.unitType && (
                        <p className="text-xs text-gray-500">數量: {latestRecord.quantity} {latestRecord.unitType}</p>
                    )}
                </div>
            </div>

            <div className="grid grid-cols-3 gap-2 my-3 text-center">
                <div className="bg-green-50 p-2 rounded"><p className="text-xs text-gray-500">最低單價</p><p className="font-bold text-green-600">{isNaN(lowestUnitPrice) ? 'N/A' : `${lowestUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-blue-50 p-2 rounded"><p className="text-xs text-gray-500">平均單價</p><p className="font-bold text-blue-600">{isNaN(avgUnitPrice) ? 'N/A' : `${avgUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-red-50 p-2 rounded"><p className="text-xs text-gray-500">最高單價</p><p className="font-bold text-red-600">{isNaN(highestUnitPrice) ? 'N/A' : `${highestUnitPrice.toFixed(2)}`}</p></div>
            </div>

            <div className="mb-4"><PriceTrendChart records={formattedRecords} productName={product.productName} /></div>

            <div className="mt-4">
                <h4 className="font-semibold text-gray-700 mb-2">價格記錄詳情</h4>
                <div className="space-y-2 max-h-40 overflow-y-auto">
                    {formattedRecords.map((record, index) => (
                        <SwipeableRecord
                            key={index}
                            onEdit={() => onEdit(record)}
                            onDelete={() => onDelete(record)}
                        >
                            <div className="flex justify-between items-center p-2 bg-gray-50 rounded">
                                <div>
                                    {/* 顯示原價和特價信息 */}
                                    {record.specialPrice ? (
                                        <p className="font-medium">
                                            {record.originalPrice && (
                                                <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                            )}
                                            <span className="text-red-600 ml-1">${record.specialPrice.toFixed(2)}</span>
                                            <span className="text-gray-500 ml-1">@{formatUnitPrice(record.unitPrice)}</span>
                                        </p>
                                    ) : (
                                        <p className="font-medium">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</p>
                                    )}
                                    {record.discountDetails && <p className="text-xs text-indigo-600">{record.discountDetails}</p>}
                                    {/* 顯示數量和單位 */}
                                    {record.quantity && record.unitType && (
                                        <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType}</p>
                                    )}
                                </div>
                                <div className="text-right">
                                    <p className="text-xs text-gray-500">{record.storeName || '未標註'}</p>
                                    <p className="text-xs text-gray-500">{record.timestamp.toLocaleDateString()}</p>
                                </div>
                            </div>
                        </SwipeableRecord>
                    ))}
                </div>
            </div>
        </div>
    );
}

// 主組件
function AllRecordsPage({ theme, onBack, db, userId, isAuthReady }) {
    const [allProducts, setAllProducts] = useState([]);
    const [allRecords, setAllRecords] = useState({});
    const [loading, setLoading] = useState(true);
    const [sortOption, setSortOption] = useState('latest'); // latest, name, price
    const [editingRecord, setEditingRecord] = useState(null);
    const [deletingRecord, setDeletingRecord] = useState(null);
    const [successMessage, setSuccessMessage] = useState('');
    const scrollPositionRef = useRef(0); // For scroll restoration
    const [isAfterDelete, setIsAfterDelete] = useState(false); // Signal for scroll restoration
    const [searchQuery, setSearchQuery] = useState('');
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const searchInputRef = useRef(null);
    
    // Edit mode states
    const [isEditMode, setIsEditMode] = useState(false);
    const [selectedItems, setSelectedItems] = useState(new Set());
    const [localProducts, setLocalProducts] = useState([]);
    const [localRecords, setLocalRecords] = useState({});
    // 新增狀態：批量刪除確認對話框
    const [isBulkDeleteConfirmationOpen, setIsBulkDeleteConfirmationOpen] = useState(false);
    // 新增狀態：原始數據快照和衝突解決
    const [originalDataSnapshot, setOriginalDataSnapshot] = useState(null);
    const [isConflictDialogOpen, setIsConflictDialogOpen] = useState(false);

    const fetchData = useCallback(async () => {
        if (!db) return;
        setLoading(true);
        try {
            // 1. Fetch all products
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const productsArray = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 2. Fetch all records
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const recordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // 3. Group records by product ID
            const recordsByProduct = {};
            recordsArray.forEach(record => {
                if (!recordsByProduct[record.numericalID]) {
                    recordsByProduct[record.numericalID] = [];
                }
                recordsByProduct[record.numericalID].push(record);
            });

            setAllProducts(productsArray);
            setAllRecords(recordsByProduct);

        } catch (error) {
            console.error('讀取 Firestore 數據失敗:', error);
            const userMessage = handleFirestoreSaveError(error, "讀取產品數據");
            showUserFriendlyError(userMessage);
        } finally {
            setLoading(false);
        }
    }, [db]);

    useEffect(() => {
        // 只有在 Firebase 已準備好時才執行查詢
        if (!isAuthReady || !userId) {
            // 如果 Firebase 尚未準備好，不應該顯示加載狀態
            // 讓用戶知道需要等待 Firebase 初始化
            return;
        }
        
        // Firebase 已準備好且有 userId，執行數據獲取
        fetchData();
    }, [fetchData, isAuthReady, userId]);

    useEffect(() => {
        if (isSearchOpen && searchInputRef.current) {
            setTimeout(() => searchInputRef.current.focus(), 100); // Shorter delay for responsiveness
        }
    }, [isSearchOpen]);

    useLayoutEffect(() => {
        if (isAfterDelete && !loading) {
            // Use requestAnimationFrame to ensure scroll happens after browser paints
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollPositionRef.current);
                setIsAfterDelete(false); // Reset the signal after scrolling
            });
        }
    }, [loading, isAfterDelete]);

    const filteredProducts = useMemo(() => {
        // Use local data in edit mode, otherwise use Firebase data
        const products = isEditMode ? localProducts : allProducts;
        const records = isEditMode ? localRecords : allRecords;

        if (searchQuery.trim() === '') {
            // No search query, just sort the products
            return [...products].sort((a, b) => {
                const recordsA = records[a.numericalID] || [];
                const recordsB = records[b.numericalID] || [];
                
                if (sortOption === 'name') {
                    return a.productName.localeCompare(b.productName);
                }
                
                const latestRecordA = recordsA[0];
                const latestRecordB = recordsB[0];

                if (sortOption === 'price') {
                    const priceA = latestRecordA?.price || -1;
                    const priceB = latestRecordB?.price || -1;
                    return priceB - priceA;
                }

                // Default to 'latest'
                const timeA = latestRecordA?.timestamp?.toDate ? latestRecordA.timestamp.toDate().getTime() : 0;
                const timeB = latestRecordB?.timestamp?.toDate ? latestRecordB.timestamp.toDate().getTime() : 0;
                return timeB - timeA;
            });
        }

        // Fuzzy search logic
        const scoredProducts = products
            .map(product => ({
                product,
                score: fuzzyMatch(searchQuery, product.productName)
            }))
            .filter(item => item.score > 0)
            .sort((a, b) => b.score - a.score);
        
        return scoredProducts.map(item => item.product);

    }, [allProducts, allRecords, sortOption, searchQuery, isEditMode, localProducts, localRecords]);

    const showSuccessMessage = (message) => {
        setSuccessMessage(message);
        setTimeout(() => {
            setSuccessMessage('');
        }, 2000);
    };

    const handleEdit = (record) => {
        setEditingRecord(record);
    };

    const handleDelete = (record) => {
        scrollPositionRef.current = window.scrollY; // Save scroll position
        setDeletingRecord(record);
    };

    // New function to handle checkbox selection
    const handleItemSelect = (productId) => {
        setSelectedItems(prev => {
            const newSet = new Set(prev);
            if (newSet.has(productId)) {
                newSet.delete(productId);
            } else {
                newSet.add(productId);
            }
            return newSet;
        });
    };

    // 修改批量刪除功能以使用確認對話框
    const handleBulkDeleteClick = () => {
        if (selectedItems.size === 0) return;
        setIsBulkDeleteConfirmationOpen(true);
    };

    // New function to delete selected items
    const deleteSelectedItems = async () => {
        if (selectedItems.size === 0) return;
        
        try {
            // Update local state
            setLocalProducts(prev => prev.filter(product => !selectedItems.has(product.numericalID)));
            setLocalRecords(prev => {
                const newRecords = {...prev};
                selectedItems.forEach(productId => {
                    delete newRecords[productId];
                });
                return newRecords;
            });
            
            // Clear selection
            setSelectedItems(new Set());
            setIsBulkDeleteConfirmationOpen(false);
        } catch (error) {
            console.error("Error deleting selected items:", error);
            const userMessage = handleFirestoreSaveError(error, "批量刪除產品");
            showUserFriendlyError(userMessage);
        }
    };

    // 新增函數：檢查衝突並退出編輯模式
    const checkForConflictsAndExit = async () => {
        if (!db || !originalDataSnapshot) return;
        
        try {
            // 獲取當前 Firebase 數據
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const currentProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 將記錄按產品 ID 分組
            const currentRecords = {};
            currentRecordsArray.forEach(record => {
                if (!currentRecords[record.numericalID]) {
                    currentRecords[record.numericalID] = [];
                }
                currentRecords[record.numericalID].push(record);
            });
            
            // 比較當前數據與原始快照
            const hasConflicts = checkForDataConflicts(originalDataSnapshot, {products: currentProducts, records: currentRecords});
            
            if (hasConflicts) {
                // 如果有衝突，顯示衝突解決對話框
                setIsConflictDialogOpen(true);
            } else {
                // 如果沒有衝突，直接退出編輯模式
                await exitEditMode(currentProducts, currentRecords);
            }
        } catch (error) {
            console.error("檢查數據衝突時出錯:", error);
            const userMessage = handleFirestoreSaveError(error, "檢查數據衝突");
            showUserFriendlyError(userMessage);
            // 出錯時仍然退出編輯模式
            await exitEditMode();
        }
    };
    
    // 新增函數：檢查數據衝突
    const checkForDataConflicts = (original, current) => {
        // 比較產品數量
        if (original.products.length !== current.products.length) {
            return true;
        }
        
        // 比較記錄數量
        const originalRecordCount = Object.values(original.records).reduce((count, records) => count + records.length, 0);
        const currentRecordCount = Object.values(current.records).reduce((count, records) => count + records.length, 0);
        
        if (originalRecordCount !== currentRecordCount) {
            return true;
        }
        
        // 更詳細的比較可以在此處添加
        // 為了簡化，我們只檢查數量變化
        
        return false;
    };
    
    // 修改 exitEditMode 函數以接受當前數據
    const exitEditMode = async (currentProducts = null, currentRecords = null) => {
        if (!db) return;
        
        try {
            // 如果沒有提供當前數據，則獲取最新數據
            let latestProducts = currentProducts;
            let latestRecords = currentRecords;
            
            if (!latestProducts || !latestRecords) {
                const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
                const productsSnap = await getDocs(productsQuery);
                latestProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
                const recordsSnap = await getDocs(recordsQuery);
                const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 將記錄按產品 ID 分組
                latestRecords = {};
                currentRecordsArray.forEach(record => {
                    if (!latestRecords[record.numericalID]) {
                        latestRecords[record.numericalID] = [];
                    }
                    latestRecords[record.numericalID].push(record);
                });
            }
            
            // 計算需要從 Firebase 刪除的產品
            const productsToDelete = latestProducts.filter(product => 
                !localProducts.some(localProduct => localProduct.numericalID === product.numericalID)
            );
            
            // 刪除 Firebase 中的產品及其記錄
            for (const product of productsToDelete) {
                // 刪除所有記錄
                const productRecords = latestRecords[product.numericalID] || [];
                for (const record of productRecords) {
                    const recordRef = doc(db, "priceRecords", record.id);
                    await deleteDoc(recordRef);
                }
            }
            
            // 計算需要從 Firebase 刪除的記錄（編輯模式下刪除的記錄）
            const recordsToDelete = [];
            for (const [productId, records] of Object.entries(latestRecords)) {
                const localRecordsForProduct = localRecords[productId] || [];
                // 找出在原始記錄中存在但在本地記錄中不存在的記錄
                const deletedRecords = records.filter(record => 
                    !localRecordsForProduct.some(localRecord => localRecord.id === record.id)
                );
                recordsToDelete.push(...deletedRecords);
            }
            
            // 刪除 Firebase 中的記錄
            for (const record of recordsToDelete) {
                const recordRef = doc(db, "priceRecords", record.id);
                await deleteDoc(recordRef);
            }
            
            // 重新從 Firebase 獲取數據
            await fetchData();
            setIsEditMode(false);
            setSelectedItems(new Set());
            setOriginalDataSnapshot(null);

        } catch (error) {
            console.error("Error syncing with Firebase:", error);
            const userMessage = handleFirestoreSaveError(error, "同步編輯數據");
            showUserFriendlyError(userMessage);
        }
    };

    const handleSaveEdit = async (updatedRecord) => {
        if (!db) return;
        try {
            const recordRef = doc(db, "priceRecords", updatedRecord.id);
            // 更新所有字段，不僅僅是價格和折扣詳情
            await updateDoc(recordRef, {
                price: updatedRecord.price,
                discountDetails: updatedRecord.discountDetails,
                productName: updatedRecord.productName,
                storeName: updatedRecord.storeName,
                quantity: updatedRecord.quantity,
                unitType: updatedRecord.unitType,
                unitPrice: updatedRecord.unitPrice,
                originalPrice: updatedRecord.originalPrice,
                specialPrice: updatedRecord.specialPrice
            });
            
            // 在編輯模式下，更新本地狀態而不是重新獲取所有數據
            if (isEditMode) {
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    
                    // 確保更新的記錄所屬的產品在 localRecords 中存在
                    if (!newRecords[updatedRecord.numericalID]) {
                        newRecords[updatedRecord.numericalID] = [];
                    }
                    
                    // 更新記錄
                    Object.keys(newRecords).forEach(productId => {
                        if (newRecords[productId]) {
                            newRecords[productId] = newRecords[productId].map(record => 
                                record.id === updatedRecord.id ? updatedRecord : record
                            ).filter(record => record !== undefined); // 過濾掉可能的 undefined 值
                        }
                    });
                    
                    // 確保當前更新的記錄存在於其對應的產品記錄中
                    if (!newRecords[updatedRecord.numericalID].some(record => record.id === updatedRecord.id)) {
                        newRecords[updatedRecord.numericalID].push(updatedRecord);
                    }
                    
                    return newRecords;
                });
                
                // 同時更新本地產品列表中的產品名稱
                setLocalProducts(prev => 
                    prev.map(product => 
                        product.numericalID === updatedRecord.numericalID 
                            ? {...product, productName: updatedRecord.productName} 
                            : product
                    )
                );
            } else {
                await fetchData(); // 非編輯模式下重新獲取數據以更新UI
            }
            
            showSuccessMessage('記錄已成功更新');
        } catch (error) {
            console.error("更新記錄失敗:", error);
            const userMessage = handleFirestoreSaveError(error, "更新價格記錄");
            showUserFriendlyError(userMessage);
        }
        setEditingRecord(null);
    };

    // 新增函數：處理衝突解決
    const handleConflictResolution = async (resolutionType) => {
        setIsConflictDialogOpen(false);
        
        switch (resolutionType) {
            case 'local':
                // 保留本地更改，直接退出編輯模式
                await exitEditMode();
                break;
            case 'remote':
                // 保留遠程數據，重新獲取最新數據並退出
                await fetchData();
                setIsEditMode(false);
                setSelectedItems(new Set());
                setOriginalDataSnapshot(null);

                break;
            case 'merge':
                // 手動合併，重新獲取數據並保持編輯模式
                await fetchData();
                setLocalProducts([...allProducts]);
                setLocalRecords({...allRecords});
                // 保持編輯模式開啟，讓用戶繼續編輯
                setOriginalDataSnapshot({
                    products: [...allProducts],
                    records: {...allRecords},
                    timestamp: Date.now()
                });

                break;
            default:
                // 默認情況下直接退出編輯模式
                await exitEditMode();
        }
    };

    const confirmDelete = async () => {
        if (!db || !deletingRecord) return;
        
        // 在編輯模式下，我們只需要更新本地狀態，不需要重新整理畫面
        if (isEditMode) {
            try {
                // 更新本地狀態而不是調用 Firebase
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    if (newRecords[deletingRecord.numericalID]) {
                        newRecords[deletingRecord.numericalID] = newRecords[deletingRecord.numericalID].filter(
                            record => record.id !== deletingRecord.id
                        );
                    }
                    return newRecords;
                });
                
                // 顯示成功消息
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            } finally {
                setDeletingRecord(null);
            }
        } else {
            // 非編輯模式下保持原有行為
            setIsAfterDelete(true); // Signal that the next data fetch is after a delete
            try {
                const recordRef = doc(db, "priceRecords", deletingRecord.id);
                await deleteDoc(recordRef);
                await fetchData(); // 重新獲取數據以更新UI
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            }
            setDeletingRecord(null);
        }
    };

    const handleSearchToggle = () => {
        if (isSearchOpen) {
            setSearchQuery('');
        }
        setIsSearchOpen(!isSearchOpen);
    };

    if (loading) {
        return (
            <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
                <div className="max-w-4xl mx-auto">
                    <div className="flex items-center mb-6">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800">所有記錄</h1>
                    </div>
                    <div className="text-center py-10">
                        {!isAuthReady ? (
                            <p>正在初始化雲端服務，請稍候...</p>
                        ) : !userId ? (
                            <p>正在獲取用戶信息，請稍候...</p>
                        ) : (
                            <p>正在從雲端加載數據...</p>
                        )}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
            <div className="max-w-4xl mx-auto pb-28"> {/* Added pb-28 for floating button */}
                <SuccessMessage message={successMessage} />
                <div className="flex flex-col sm:flex-row sm:items-center justify-between mb-6">
                    <div className="flex items-center mb-4 sm:mb-0">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800 flex items-center"><Database className="mr-2" />所有記錄</h1>
                    </div>
                    <div className="flex items-center">
                        <label className="mr-2 text-gray-700">排序:</label>
                        <select value={sortOption} onChange={(e) => setSortOption(e.target.value)} className="border border-gray-300 rounded p-2 mr-2">
                            <option value="latest">最新記錄</option>
                            <option value="name">產品名稱</option>
                            <option value="price">最新價格</option>
                        </select>
                        <button 
                            onClick={() => {
                                if (!isEditMode) {
                                    // Enter edit mode - copy current data to local state
                                    setLocalProducts([...allProducts]);
                                    setLocalRecords({...allRecords});
                                    // 保存原始數據快照和時間戳
                                    setOriginalDataSnapshot({
                                        products: [...allProducts],
                                        records: {...allRecords},
                                        timestamp: Date.now()
                                    });
                                } else {
                                    // Exit edit mode - 檢查數據版本衝突
                                    checkForConflictsAndExit();
                                }
                                setIsEditMode(!isEditMode);
                                setSelectedItems(new Set());
                            }}
                            className={`px-3 py-2 rounded text-white text-sm ${
                                isEditMode ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'
                            }`}
                        >
                            {isEditMode ? '退出編輯模式' : '編輯模式'}
                        </button>
                    </div>
                </div>

                {/* Floating Delete Button - 修改為固定位置 */}
                {isEditMode && selectedItems.size > 0 && (
                    <div className="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-4 shadow-lg z-50 flex items-center"
                         style={{bottom: '6rem'}}>
                        <button 
                            onClick={handleBulkDeleteClick}
                            className="flex items-center"
                        >
                            <Trash2 size={20} className="mr-2" />
                            刪除選取項目 ({selectedItems.size})
                        </button>
                    </div>
                )}

                {/* Floating Exit Edit Mode Button - 修改為固定位置 */}
                {isEditMode && (
                    <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white rounded-full p-4 shadow-lg z-50">
                        <button 
                            onClick={checkForConflictsAndExit}
                            className="flex items-center"
                        >
                            <X size={20} className="mr-2" />
                            退出編輯模式
                        </button>
                    </div>
                )}

                {filteredProducts.length === 0 ? (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <Database size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">{searchQuery ? '找不到結果' : '暫無記錄'}</h3>
                        <p className="text-gray-500">{searchQuery ? `找不到符合 "${searchQuery}" 的產品` : '還沒有任何產品和價格記錄'}</p>
                    </div>
                ) : (
                    <div>
                        <div className="mb-4 p-4 bg-white rounded-lg shadow">
                            <div className="flex justify-between">
                                <p className="text-gray-700">總共 <span className="font-bold">{filteredProducts.length}</span> 個產品</p>
                                <p className="text-gray-700">總共 <span className="font-bold">{Object.values(allRecords).flat().length}</span> 條記錄</p>
                            </div>
                        </div>
                        {filteredProducts.map(product => {
                            // 修復：確保 records 始終有默認值
                            const records = isEditMode ? (localRecords[product.numericalID] || []) : (allRecords[product.numericalID] || []);
                            // 修改：即使沒有記錄也顯示產品卡片，但只在編輯模式下
                            if (records.length === 0 && !isEditMode) return null;
                            return (
                                // 修改：為選中的項目添加增強的視覺反饋
                                <div key={product.numericalID} className={`relative transition-all duration-200 ${isEditMode && selectedItems.has(product.numericalID) ? 'bg-blue-50 border-2 border-blue-500 rounded-lg' : ''}`}>
                                    {isEditMode && (
                                        <div className="absolute top-4 left-4 z-10">
                                            <input
                                                type="checkbox"
                                                checked={selectedItems.has(product.numericalID)}
                                                onChange={() => handleItemSelect(product.numericalID)}
                                                className="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                                            />
                                        </div>
                                    )}
                                    <div className={isEditMode ? "pl-12" : ""}>
                                        <ProductRecord 
                                            product={product} 
                                            records={records} 
                                            theme={theme} 
                                            onEdit={handleEdit} 
                                            onDelete={handleDelete} 
                                        />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}

                {editingRecord && (
                    <EditModal
                        record={editingRecord}
                        onClose={() => setEditingRecord(null)}
                        onSave={handleSaveEdit}
                    />
                )}

                {deletingRecord && (
                    <DeleteConfirmation
                        record={deletingRecord}
                        onClose={() => setDeletingRecord(null)}
                        onConfirm={confirmDelete}
                    />
                )}

                {/* 新增批量刪除確認對話框 */}
                {isBulkDeleteConfirmationOpen && (
                    <BulkDeleteConfirmation
                        count={selectedItems.size}
                        onClose={() => setIsBulkDeleteConfirmationOpen(false)}
                        onConfirm={deleteSelectedItems}
                    />
                )}

                {/* 新增衝突解決對話框 */}
                {isConflictDialogOpen && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                            <h2 className="text-xl font-bold mb-4">檢測到數據衝突</h2>
                            <p className="mb-4">在您編輯期間，其他用戶修改了部分數據。請選擇如何解決衝突：</p>
                            
                            <div className="mb-6 p-4 bg-yellow-50 rounded-lg">
                                <h3 className="font-semibold text-yellow-800 mb-2">衝突詳情：</h3>
                                <ul className="list-disc pl-5 text-sm text-yellow-700">
                                    <li>數據可能已被人修改</li>
                                    <li>您的更改可能與其他用戶的更改衝突</li>
                                </ul>
                            </div>
                            
                            <div className="space-y-3">
                                <button 
                                    onClick={() => handleConflictResolution('local')}
                                    className="w-full p-3 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                                >
                                    保留我的更改
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('remote')}
                                    className="w-full p-3 bg-green-500 text-white rounded-md hover:bg-green-600"
                                >
                                    保留最新數據
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('merge')}
                                    className="w-full p-3 bg-purple-500 text-white rounded-md hover:bg-purple-600"
                                >
                                    手動合併（推薦）
                                </button>
                            </div>
                            
                            <div className="mt-6 flex justify-end">
                                <button 
                                    onClick={() => setIsConflictDialogOpen(false)}
                                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                                >
                                    取消
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- START: Revamped Search Component --- */}
                <div className="fixed top-6 right-6 z-30">
                    <div 
                        className={`flex items-center justify-end bg-white rounded-full shadow-xl transition-all duration-300 ease-in-out overflow-hidden ${isSearchOpen ? 'w-80' : 'w-16 h-16'}`}
                    >
                        <Search className={`absolute left-5 top-1/2 -translate-y-1/2 text-gray-400 transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`} size={22} />
                        <input
                            ref={searchInputRef}
                            type="text"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="輸入品名進行模糊搜尋..."
                            className={`w-full h-16 pl-14 pr-20 bg-transparent border-none rounded-full outline-none text-lg transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`}
                            style={{pointerEvents: isSearchOpen ? 'auto' : 'none'}}
                        />
                        <button
                            onClick={handleSearchToggle}
                            className="absolute right-0 top-0 w-16 h-16 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 flex items-center justify-center"
                            aria-label={isSearchOpen ? "關閉搜尋" : "開啟搜尋"}
                        >
                            {isSearchOpen ? <X size={28} /> : <Search size={28} />}
                        </button>
                    </div>
                </div>
                {/* --- END: Revamped Search Component --- */}
            </div>
        </div>
    );
}

function EditModal({ record, onClose, onSave }) {
    const [price, setPrice] = useState(record.price);
    const [quantity, setQuantity] = useState(record.quantity || '');
    const [unitType, setUnitType] = useState(record.unitType || 'pcs');
    const [discount, setDiscount] = useState(record.discountDetails || '');
    const [originalPrice, setOriginalPrice] = useState(record.originalPrice || '');
    const [specialPrice, setSpecialPrice] = useState(record.specialPrice || '');
    const [productName, setProductName] = useState(record.productName || '');
    const [storeName, setStoreName] = useState(record.storeName || '');
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);

    const handleSave = () => {
        const newUnitPrice = calculateUnitPrice(price, quantity, unitType);
        if (newUnitPrice === null) {
            alert("請輸入有效的價格和數量。");
            return;
        }
        onSave({ 
            ...record, 
            price: parseFloat(price),
            quantity: parseFloat(quantity),
            unitType: unitType,
            unitPrice: newUnitPrice,
            discountDetails: discount,
            originalPrice: originalPrice ? parseFloat(originalPrice) : null,
            specialPrice: specialPrice ? parseFloat(specialPrice) : null,
            productName: productName,
            storeName: storeName
        });
    };

    const currentUnitPrice = calculateUnitPrice(price, quantity, unitType);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 overflow-hidden">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">編輯記錄</h2>
                <div className="space-y-3">
                    {/* 產品名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">產品名稱</label>
                        <input
                            type="text"
                            value={productName}
                            onChange={(e) => setProductName(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 商店名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">商店名稱</label>
                        <div className="mt-1 flex">
                            <input
                                type="text"
                                value={storeName}
                                onChange={(e) => setStoreName(e.target.value)}
                                className="block flex-grow border border-gray-300 rounded-l-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                placeholder="點擊選擇商店或手動輸入"
                                readOnly
                            />
                            <button 
                                onClick={() => setIsStoreSelectorOpen(true)}
                                className="bg-indigo-600 text-white px-4 py-2 rounded-r-md hover:bg-indigo-700"
                            >
                                選擇
                            </button>
                        </div>
                    </div>
                    
                    {/* 原價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">原價 ($)</label>
                        <input
                            type="number"
                            value={originalPrice}
                            onChange={(e) => setOriginalPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 特價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">特價 ($)</label>
                        <input
                            type="number"
                            value={specialPrice}
                            onChange={(e) => setSpecialPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 總價輸入（實際支付價格） */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">總價 ($)</label>
                        <input
                            type="number"
                            value={price}
                            onChange={(e) => setPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    <div>
                        <label className="block text-sm font-medium text-gray-700">數量</label>
                        <input
                            type="number"
                            value={quantity}
                            onChange={(e) => setQuantity(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單位</label>
                        <select
                            value={unitType}
                            onChange={(e) => setUnitType(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        >
                            <option value="ml">ml (毫升)</option>
                            <option value="g">g (克)</option>
                            <option value="pcs">pcs (個/包/支/條)</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單價 (自動計算)</label>
                        <input
                            type="text"
                            value={currentUnitPrice === null ? 'N/A' : currentUnitPrice.toFixed(2)}
                            readOnly
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-gray-100"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">折扣詳情</label>
                        <input
                            type="text"
                            value={discount}
                            onChange={(e) => setDiscount(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                </div>
                <div className="mt-4 flex justify-between">
                    <button onClick={onClose} className="flex-1 mr-2 items-center bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 flex justify-center">
                        <X size={18} className="mr-1" />
                        取消
                    </button>
                    <button onClick={handleSave} className="flex-1 ml-2 items-center bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 flex justify-center">
                        <Save size={18} className="mr-1" />
                        保存
                    </button>
                </div>
            </div>
            
            {isStoreSelectorOpen && (
                <StoreSelector 
                    onSelect={(selectedStore) => {
                        setStoreName(selectedStore);
                        setIsStoreSelectorOpen(false);
                    }}
                    onClose={() => setIsStoreSelectorOpen(false)}
                    theme={{ primary: 'bg-indigo-600', hover: 'hover:bg-indigo-700', text: 'text-indigo-600' }}
                />
            )}
        </div>
    );
}

function DeleteConfirmation({ record, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p>您確定要刪除這條價格為 ${record.price.toFixed(2)} 的記錄嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}

function SuccessMessage({ message }) {
    if (!message) return null;

    return (
        <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center z-50">
            <CheckCircle size={20} className="mr-2" />
            <span>{message}</span>
        </div>
    );
}



// 新增批量刪除確認對話框組件
function BulkDeleteConfirmation({ count, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認批量刪除</h2>
                <p>您確定要刪除選中的 {count} 個產品項目嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}



export default AllRecordsPage;
</file>

<file path="App.css">
/* 應用基本樣式 */
.App {
  text-align: center;
  min-height: 100vh;
}

/* 自定義樣式可以在這裡添加 */
</file>

<file path="App.js">
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PaintBucket, DollarSign, Barcode, ClipboardCheck, X, Camera, Zap, FileText, RotateCcw, Database, Settings as SettingsIcon } from 'lucide-react';
import AllRecordsPage from './AllRecordsPage';
import StoreSelector from './StoreSelector';
import AIOcrCaptureModal from './components/AIOcrCaptureModal';
import SettingsPage from './components/SettingsPage'; // 新增導入
import { db } from './firebase-config.js'; // <-- 引入 Firebase
import { getAuth, signInAnonymously } from "firebase/auth";
import { doc, getDoc, setDoc, collection, query, where, getDocs, addDoc, orderBy, serverTimestamp } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import OcrQueuePage from './OcrQueuePage';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具
import { v4 as uuidv4 } from 'uuid'; // 引入 uuid 函式庫來生成本地 ID

// ----------------------------------------------------------------------------
// 1. 核心設定與工具函數 (Core Setup & Utilities)
// ----------------------------------------------------------------------------

function djb2Hash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
}

// 以下函數已移至 src/components/AIOcrCaptureModal.js
// callGeminiApiWithRetry
// withExponentialBackoff


function generateProductId(barcode, productName, storeName) {
    if (barcode) {
        return djb2Hash(barcode).toString();
    } else {
        // Combine productName and storeName to create a unique ID for products without barcodes
        // This assumes productName + storeName is sufficiently unique for non-barcoded items
        return djb2Hash(`${productName}-${storeName}`).toString();
    }
}

// ----------------------------------------------------------------------------
// 2. UI 元件 (UI Components)
// ----------------------------------------------------------------------------

const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, theme }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間沒有足夠的變化來繪製趨勢圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1 text-gray-500"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                單價走勢
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke={theme.color === 'red' ? '#EF4444' : '#4F46E5'} strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === 0 ? '#10B981' : theme.primary.split('-')[1]} title={`$${record.displayPrice.toFixed(2)}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>最早: {new Date(minTimestamp).toLocaleDateString()}</span>
                <span>最新: {new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

function PriceHistoryDisplay({ historyRecords, theme }) {
    if (historyRecords.length === 0) {
        return <div className="text-center p-6 text-gray-500 bg-white rounded-xl shadow-md">尚無歷史價格紀錄。</div>;
    }

    const formattedRecords = historyRecords.map(record => ({
        ...record,
        timestamp: record.timestamp?.toDate ? record.timestamp.toDate() : new Date(record.timestamp),
        displayPrice: record.unitPrice !== undefined && record.unitPrice !== null ? record.unitPrice : record.price // Use unitPrice if available, else price
    }));

    return (
        <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${theme.border} mt-8`}>
            <h2 className={`text-xl font-semibold ${theme.text} mb-4`}>價格紀錄 ({formattedRecords.length} 筆)</h2>
            <div className="mb-6"><PriceTrendChart records={formattedRecords} theme={theme} /></div>
            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {formattedRecords.map((record, index) => (
                    <div key={index} className={`p-3 rounded-lg shadow-sm border border-gray-100 ${index === 0 ? theme.light : 'bg-white'}`}>
                        <div className="flex justify-between items-start font-bold">
                            {/* 顯示原價和特價信息 */}
                            {record.specialPrice ? (
                                <span className="text-[22px]">
                                    {record.originalPrice && (
                                        <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                    )}
                                    <span className="text-red-600 ml-2">${record.specialPrice.toFixed(2)}</span>
                                    <span className="text-gray-500 ml-2">@{formatUnitPrice(record.unitPrice)}</span>
                                </span>
                            ) : (
                                <span className="text-[22px] text-red-600">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</span>
                            )}
                            <span className="text-xs text-gray-500">{record.timestamp.toLocaleString()}</span>
                        </div>
                        <p className="text-sm text-gray-700 mt-1">商店: {record.storeName || '未標註'}</p>
                        {/* 顯示數量和單位資訊 */}
                        {record.quantity && record.unitType && <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType} (總價: ${(record.price || 0).toFixed(2)})</p>}
                        {record.discountDetails && <p className="text-xs text-indigo-600 italic">優惠: {record.discountDetails}</p>}
                        {index === 0 && <span className={`text-xs font-semibold px-2 py-0.5 rounded-full text-white ${theme.primary}`}>最新紀錄</span>}
                    </div>
                ))}
            </div>
        </div>
    );
}

const THEMES = {
    'Default (Indigo)': { primary: 'bg-indigo-600', light: 'bg-indigo-100', hover: 'hover:bg-indigo-700', border: 'border-indigo-600', text: 'text-indigo-600', color: 'indigo' },
    '海洋藍 (Ocean Blue)': { primary: 'bg-blue-600', light: 'bg-blue-100', hover: 'hover:bg-blue-700', border: 'border-blue-600', text: 'text-blue-600', color: 'blue' },
    '森林綠 (Forest Green)': { primary: 'bg-green-600', light: 'bg-green-100', hover: 'hover:bg-green-700', border: 'border-green-600', text: 'text-green-600', color: 'green' },
    '夕陽紅 (Sunset Red)': { primary: 'bg-red-600', light: 'bg-red-100', hover: 'hover:bg-red-700', border: 'border-red-600', text: 'text-red-600', color: 'red' },
    '活力橙 (Vibrant Orange)': { primary: 'bg-orange-600', light: 'bg-orange-100', hover: 'hover:bg-orange-700', border: 'border-orange-600', text: 'text-orange-600', color: 'orange' },
    '薰衣草紫 (Lavender)': { primary: 'bg-purple-600', light: 'bg-purple-100', hover: 'hover:bg-purple-700', border: 'border-purple-600', text: 'text-purple-600', color: 'purple' },
};
const DEFAULT_THEME_KEY = 'Default (Indigo)';

function ThemeSelector({ theme, saveTheme, onClose }) {
    const handleThemeChange = (themeKey) => { saveTheme(themeKey); };
    const handleReset = () => { saveTheme(DEFAULT_THEME_KEY); };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 transform transition-all">
                <h3 className={`text-xl font-bold ${theme.text} mb-4 border-b pb-2`}><PaintBucket className="inline-block w-5 h-5 mr-2" />介面配色選項</h3>
                <div className="grid grid-cols-2 gap-4 mb-6">
                    {Object.keys(THEMES).map((themeKey) => {
                        const themeData = THEMES[themeKey];
                        const isSelected = theme.color === themeData.color;
                        return (
                            <button key={themeKey} onClick={() => handleThemeChange(themeKey)}
                                className={`p-3 rounded-lg text-white font-medium shadow-md transition-all ${themeData.primary} ${themeData.hover} ${isSelected ? 'ring-4 ring-offset-2 ring-opacity-70 ring-gray-400' : ''}`}
                                style={{ transform: isSelected ? 'scale(1.05)' : 'scale(1)' }}>
                                {themeKey}
                            </button>
                        );
                    })}
                </div>
                <div className="flex justify-between items-center pt-4 border-t">
                    <button onClick={handleReset} className="flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                        <RotateCcw className="w-4 h-4 mr-1" />清除還原 (預設)
                    </button>
                    <button onClick={onClose} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg ${theme.primary} ${theme.hover} transition-all`}>關閉</button>
                </div>
            </div>
        </div>
    );
}

// AIOcrCaptureModal 組件已移至獨立檔案 src/components/AIOcrCaptureModal.js


// ----------------------------------------------------------------------------
// 3. Firebase 身份驗證與主題設定 (Firebase Auth & Theming)
// ----------------------------------------------------------------------------

function useFirebaseAuthentication() {
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        const auth = getAuth();
        signInAnonymously(auth)
            .then((userCredential) => {
                setUserId(userCredential.user.uid);
                setIsAuthReady(true);
            })
            .catch((error) => {
                console.error("Firebase 匿名登入失敗:", error);
            });
    }, []);

    const [currentTheme, setCurrentTheme] = useState(() => {
        const savedKey = localStorage.getItem('appTheme') || DEFAULT_THEME_KEY;
        return THEMES[savedKey] || THEMES[DEFAULT_THEME_KEY];
    });

    const saveUserTheme = useCallback((themeKey) => {
        localStorage.setItem('appTheme', themeKey);
        setCurrentTheme(THEMES[themeKey] || THEMES[DEFAULT_THEME_KEY]);
    }, []);

    return { userId, isAuthReady, currentTheme, saveUserTheme };
}

// ----------------------------------------------------------------------------
// 4. 結果提示框 (Result Toast)
// ----------------------------------------------------------------------------
function SaveResultToast({ result, onClose }) {
    useEffect(() => {
        let timer;
        if (result) {
            timer = setTimeout(onClose, 5000);
        }
        return () => clearTimeout(timer);
    }, [result, onClose]);

    if (!result) {
        return null;
    }

    const { status, message, productName } = result;

    const theme = {
        success: { bg: 'bg-green-500', text: 'text-white', icon: <ClipboardCheck className="w-6 h-6 mr-3" /> },
        warning: { bg: 'bg-yellow-400', text: 'text-gray-800', icon: <DollarSign className="w-6 h-6 mr-3" /> },
        error: { bg: 'bg-red-500', text: 'text-white', icon: <X className="w-6 h-6 mr-3" /> },
    };

    const currentTheme = theme[status];

    return (
        <div className={`fixed top-20 left-1/2 -translate-x-1/2 max-w-md w-full p-4 rounded-xl shadow-2xl z-[100] ${currentTheme.bg} ${currentTheme.text} transition-all duration-300 ease-in-out`}>
            <div className="flex items-center">
                {currentTheme.icon}
                <div className="flex-grow">
                    <p className="font-bold text-lg">{productName}</p>
                    <p className="text-sm">{message}</p>
                    <p className="text-sm font-semibold mt-1">
                        資料儲存: {status === 'error' ? '失敗' : '成功'} | 
                        比價結果: {status === 'success' ? '是最低價' : (status === 'warning' ? '非最低價' : 'N/A')}
                    </p>
                </div>
                <button onClick={onClose} className="ml-4 p-1 rounded-full hover:bg-white/20"><X className="w-5 h-5" /></button>
            </div>
        </div>
    );
}


// ----------------------------------------------------------------------------
// 5. 主應用程式元件 (App Component)
// ----------------------------------------------------------------------------

function App() {
    const { userId, isAuthReady, currentTheme, saveUserTheme } = useFirebaseAuthentication();
    const streamRef = useRef(null);
    
    const [saveResultToast, setSaveResultToast] = useState(null);

    // UI 狀態
    const [barcode, setBarcode] = useState('');
    const [productName, setProductName] = useState('');
    const [currentPrice, setCurrentPrice] = useState('');
    const [quantity, setQuantity] = useState('');
    const [unitType, setUnitType] = useState('pcs'); // 'g', 'ml', 'pcs'
    const [unitPrice, setUnitPrice] = useState(null);
    const [discountDetails, setDiscountDetails] = useState('');
    const [storeName, setStoreName] = useState('');
    const [productHistory, setProductHistory] = useState([]);
    const [comparisonResult, setComparisonResult] = useState({ message: '等待比價數據...' });
    const [statusMessage, setStatusMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [lookupStatus, setLookupStatus] = useState('ready');
    
    // Modal and Page 狀態
    const [isThemeModalOpen, setIsThemeModalOpen] = useState(false);
    const [isCaptureModalOpen, setIsCaptureModalOpen] = useState(false);
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);
    const [isOcrQueueStoreSelectorOpen, setIsOcrQueueStoreSelectorOpen] = useState(false); // 新增狀態
    const [isSettingsOpen, setIsSettingsOpen] = useState(false); // 新增狀態
    const [editingOcrCard, setEditingOcrCard] = useState(null); // 新增狀態
    
    // 新增函數：處理數據刷新
    const handleDataRefresh = useCallback((key) => {
        // 如果清除的是 pendingOcrCards，需要更新狀態
        if (key === 'pendingOcrCards' || key === 'ALL') {
            const savedCards = localStorage.getItem('pendingOcrCards');
            setPendingOcrCards(savedCards ? JSON.parse(savedCards) : []);
        }
        // 可以在這裡添加其他需要刷新的狀態
    }, []);

    const [currentPage, setCurrentPage] = useState('main'); // 'main', 'allRecords', 'ocrQueue'
    const [ocrResult, setOcrResult] = useState(null);
    const [capturedImage, setCapturedImage] = useState(null); // 新增的狀態
    
    // 新增狀態：待辨識序列
    const [pendingOcrCards, setPendingOcrCards] = useState(() => {
        // 從 localStorage 恢復待辨識卡片
        const savedCards = localStorage.getItem('pendingOcrCards');
        return savedCards ? JSON.parse(savedCards) : [];
    });
    
    // 添加 useEffect 來保存 pendingOcrCards 到 localStorage
    useEffect(() => {
        localStorage.setItem('pendingOcrCards', JSON.stringify(pendingOcrCards));
    }, [pendingOcrCards]);
    
    useEffect(() => {
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const price = parseFloat(finalPrice);
        const qty = parseFloat(quantity);

        if (!isNaN(price) && !isNaN(qty) && qty > 0) {
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(price, qty, unitType);
            setUnitPrice(calculatedUnitPrice);
        } else {
            setUnitPrice(null);
        }
    }, [currentPrice, quantity, unitType, ocrResult]);
    
    // 提前定義所有會被使用的函數，避免 no-use-before-define 警告
    const clearForm = useCallback(() => {
        setBarcode('');
        setProductName('');
        setCurrentPrice('');
        setQuantity('');
        setUnitType('pcs'); // Reset to default unit type
        setUnitPrice(null);
        setDiscountDetails('');
        setStoreName('');
        setProductHistory([]);
        setComparisonResult({ message: '等待比價數據...' });
        setOcrResult(null);
        setLookupStatus('ready');
        setCapturedImage(null); // 清除擷取的圖片
    }, []);

    const stopCameraStream = useCallback(() => {
        console.log("stopCameraStream: Attempting to stop camera.");
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
            console.log("stopCameraStream: Camera stream stopped.");
        }
    }, []);
    
    const startCameraStream = async () => {
        console.log("startCameraStream: Attempting to start camera.");
        if (streamRef.current) {
            return streamRef.current;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
            streamRef.current = stream;
            console.log("startCameraStream: Camera started successfully.");
            return stream;
        } catch (err) {
            console.error("無法存取攝影機:", err);
            setStatusMessage(`無法存取攝影機: ${err.name}`);
            return null;
        }
    };

    const lookupProduct = useCallback(async (barcodeData, currentProductName, currentStoreName) => {
        // 如果 Firebase 尚未初始化，則不執行查詢
        if (!isAuthReady || !userId) {
            return;
        }
        
        const numericalID = generateProductId(barcodeData, currentProductName, currentStoreName);

        // Adjust early exit condition:
        // If no barcode and no product name, or if barcode is too short and no product name,
        // then we can't look up a product.
        if (!numericalID) { // If numericalID couldn't be generated, then we can't look up a product.
            setProductName('');
            setLookupStatus('ready');
            setProductHistory([]);
            return;
        }
        
        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);

            if (productSnap.exists()) {
                setProductName(productSnap.data().productName);
                setLookupStatus('found');
            } else {
                setLookupStatus('new');
            }

            const recordsQueryString = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID), // numericalID is already a string
                orderBy("timestamp", "desc")
            );
            const recordsSnapString = await getDocs(recordsQueryString);
            let records = recordsSnapString.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Attempt to query for numericalID as a number, if it's a valid number string
            const numericalIDAsNumber = parseInt(numericalID, 10);
            if (!isNaN(numericalIDAsNumber) && numericalIDAsNumber.toString() === numericalID) { // Check if it's a pure number string
                const recordsQueryNumber = query(
                    collection(db, "priceRecords"),
                    where("numericalID", "==", numericalIDAsNumber),
                    orderBy("timestamp", "desc")
                );
                const recordsSnapNumber = await getDocs(recordsQueryNumber);
                const recordsNumber = recordsSnapNumber.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Merge and deduplicate records
                const mergedRecordsMap = new Map();
                records.forEach(record => mergedRecordsMap.set(record.id, record));
                recordsNumber.forEach(record => mergedRecordsMap.set(record.id, record));
                records = Array.from(mergedRecordsMap.values()).sort((a, b) => (b.timestamp?.toDate ? b.timestamp.toDate().getTime() : 0) - (a.timestamp?.toDate ? a.timestamp.toDate().getTime() : 0));
            }
            setProductHistory(records);

        } catch (error) {
            console.error("查詢產品失敗 (Firestore):", error);
            setStatusMessage("查詢產品資料時發生錯誤。");
            setLookupStatus('ready');
            setProductHistory([]);
        }
    }, [isAuthReady, userId, setProductName, setLookupStatus, setProductHistory, setStatusMessage]);

    // 新增函數：處理 OCR 隊列的商店選擇
    const handleOcrQueueStoreSelect = useCallback((card) => {
        setEditingOcrCard(card);
        setIsOcrQueueStoreSelectorOpen(true);
    }, [setEditingOcrCard, setIsOcrQueueStoreSelectorOpen]);

    // 新增函數：處理 OCR 隊列的商店選擇確認
    const handleOcrQueueStoreSelectConfirm = useCallback((selectedStore) => {
        if (editingOcrCard) {
            // 更新待辨識卡片的商店名稱
            const updatedCards = pendingOcrCards.map(card => 
                card.id === editingOcrCard.id ? { ...card, storeName: selectedStore } : card
            );
            setPendingOcrCards(updatedCards);
        }
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [editingOcrCard, pendingOcrCards, setPendingOcrCards, setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 新增函數：處理 OCR 隊列的商店選擇器關閉
    const handleOcrQueueStoreSelectorClose = useCallback(() => {
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 正確地提前定義 performSaveAndCompare 函數（必須在 saveAndComparePrice 之前定義）
    const performSaveAndCompare = useCallback(async (selectedStore) => {
        const finalStoreName = selectedStore || storeName;
        const numericalID = generateProductId(barcode, productName, finalStoreName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const priceValue = parseFloat(finalPrice);

        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, quantity, unitType);

        if (!userId || !productName || isNaN(priceValue) || isNaN(parseFloat(quantity)) || parseFloat(quantity) <= 0 || calculatedUnitPrice === null) {
            showUserFriendlyError("請確保已輸入條碼、產品名稱、有效總價、數量和單位！", "資料驗證");
            setIsLoading(false);
            return;
        }
        if (!finalStoreName.trim()) {
            setIsStoreSelectorOpen(true);
            setIsLoading(false);
            return;
        }

        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);
            
            // 準備產品文檔數據
            const productData = {
                numericalID,
                barcodeData: barcode,
                productName,
                createdAt: productSnap.exists() ? productSnap.data().createdAt : serverTimestamp(),
                lastUpdatedBy: userId,
            };

            // 準備價格記錄數據
            const priceRecord = {
                numericalID,
                productName,
                storeName: finalStoreName,
                price: priceValue, // 總價
                quantity: parseFloat(quantity),
                unitType: unitType,
                unitPrice: calculatedUnitPrice, // 單價
                discountDetails: discountDetails || '',
                timestamp: serverTimestamp(),
                recordedBy: userId,
                // 保存原價和特價信息（如果有的話）
                originalPrice: ocrResult?.originalPrice ? parseFloat(ocrResult.originalPrice) : null,
                specialPrice: ocrResult?.specialPrice ? parseFloat(ocrResult.specialPrice) : null
            };

            // 儲存價格記錄
            const priceRecordDocRef = await addDoc(collection(db, "priceRecords"), priceRecord);
            
            // 檢查是否需要更新產品文檔中的最佳單價
            let isBestPrice = false;
            if (productSnap.exists()) {
                const existingProductData = productSnap.data();
                // 如果產品文檔中沒有 bestUnitPrice 或新價格更低，則更新
                if (existingProductData.bestUnitPrice === undefined || calculatedUnitPrice < existingProductData.bestUnitPrice) {
                    productData.bestUnitPrice = calculatedUnitPrice;
                    productData.bestPriceRecordRef = priceRecordDocRef.path; // 儲存指向最佳價格記錄的引用路徑
                    isBestPrice = true;
                } else {
                    // 保持現有的最佳價格信息
                    productData.bestUnitPrice = existingProductData.bestUnitPrice;
                    productData.bestPriceRecordRef = existingProductData.bestPriceRecordRef;
                }
            } else {
                // 新產品，當前價格就是最佳價格
                productData.bestUnitPrice = calculatedUnitPrice;
                productData.bestPriceRecordRef = priceRecordDocRef.path;
                isBestPrice = true;
            }
            
            // 儲存或更新產品文檔
            await setDoc(productRef, productData);

            // 準備比價結果
            let toastStatus, toastMessage, isBest, bestPrice, bestStore;

            if (isBestPrice) {
                isBest = true;
                bestPrice = calculatedUnitPrice;
                bestStore = finalStoreName;
                toastStatus = 'success';
                toastMessage = '恭喜！這是目前紀錄中的最低單價！';
            } else {
                isBest = false;
                bestPrice = productData.bestUnitPrice;
                
                // 從 Firestore 獲取最佳價格記錄的商店名稱
                try {
                    const bestPriceRecordDoc = await getDoc(doc(db, productData.bestPriceRecordRef));
                    if (bestPriceRecordDoc.exists()) {
                        bestStore = bestPriceRecordDoc.data().storeName;
                    } else {
                        bestStore = '未知商店';
                    }
                } catch (error) {
                    console.error("獲取最佳價格記錄失敗:", error);
                    bestStore = '未知商店';
                }
                
                toastStatus = 'warning';
                toastMessage = `非最低單價。歷史最低單價為 $${formatUnitPrice(productData.bestUnitPrice)} (${bestStore})`;
            }

            setComparisonResult({ isBest, bestPrice, bestStore, message: toastMessage });
            // 儲存成功時顯示提示訊息
            setSaveResultToast({ status: toastStatus, message: toastMessage, productName: productName });
            
            lookupProduct(barcode, productName, finalStoreName);

        } catch (error) {
            console.error("儲存或比價失敗 (Firestore):", error);
            const userMessage = handleFirestoreSaveError(error, "儲存價格資訊");
            showUserFriendlyError(userMessage);
        } finally {
            setIsLoading(false);
        }
    }, [userId, barcode, productName, currentPrice, discountDetails, storeName, lookupProduct, quantity, unitType, setSaveResultToast, setComparisonResult, setIsLoading, setIsStoreSelectorOpen, ocrResult]);

    // 正確地提前定義 saveAndComparePrice 函數
    const saveAndComparePrice = useCallback(async (selectedStore) => {
        // 確保 Firebase 已初始化，如果尚未完成初始化則強制初始化
        if (!isAuthReady) {
            // 顯示加載訊息並等待初始化完成
            setIsLoading(true);
            // 等待 Firebase 初始化完成
            const checkAuth = () => {
                if (isAuthReady) {
                    // 初始化完成後繼續執行
                    performSaveAndCompare(selectedStore);
                } else {
                    // 繼續等待
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
            return;
        }
        
        // 如果 Firebase 已準備好，直接執行保存操作
        performSaveAndCompare(selectedStore);
    }, [isAuthReady, performSaveAndCompare]);
    
    const handleAiCaptureSuccess = useCallback((result) => {
        const { scannedBarcode, productName, extractedPrice, storeName, discountDetails, quantity, unitType, specialPrice, capturedImage: receivedImage } = result;
        setOcrResult(result);
        
        // 設置捕獲的圖像
        if (receivedImage) {
            setCapturedImage(receivedImage);
        }
        
        const newBarcode = scannedBarcode || '';
        setBarcode(newBarcode);

        if (!newBarcode) {
            setStatusMessage("AI 未能識別條碼，請手動輸入或確保條碼清晰！");
        } else {
            setStatusMessage(`AI 分析成功！`);
        }

        setProductName(productName || '');
        
        // 優先使用特價，如果有的話
        const finalPrice = specialPrice && !isNaN(parseFloat(specialPrice)) ? specialPrice : extractedPrice;
        setCurrentPrice(finalPrice || '');
        
        setStoreName(storeName || '');
        setDiscountDetails(discountDetails || '');

        setQuantity(quantity || '');
        setUnitType(unitType || 'pcs');

        if (productName && newBarcode) {
            setLookupStatus('found');
        } else {
            setLookupStatus('new');
        }
    }, [setBarcode, setProductName, setCurrentPrice, setStoreName, setDiscountDetails, setOcrResult, setStatusMessage, setLookupStatus, setQuantity, setUnitType, setCapturedImage]);

    // 定義一個新的函式來處理 Firebase 備份
    const backupOcrCardToFirebase = useCallback(async (cardData) => {
        // 檢查 Firebase 是否準備好
        if (!isAuthReady || !userId) {
            // 由於功能要求是自動備份，若服務未準備好，則將其視為 pending 或 error (可選)
            console.warn("Firebase 服務尚未準備好，跳過備份。");
            // 由於此專案似乎有 MVP 階段屏蔽 Firebase 的歷史需求，
            // 這裡可以選擇將狀態設為 'error' 或保留 'pending'。
            // 為避免影響核心功能，建議在此處直接返回，讓卡片保持 'pending' 狀態。
            return;
        }

        const cardToSave = {
            ...cardData,
            userId: userId, // 儲存用戶 ID
            timestamp: serverTimestamp(), // 使用 Firebase 服務器時間戳
            // 移除本地 ID 和同步狀態，因為這些只用於本地 UI
            id: undefined, 
            syncStatus: undefined
        };

        try {
            // 將卡片數據儲存到 pendingOcrCards 集合
            const docRef = await addDoc(collection(db, "pendingOcrCards"), cardToSave);
            
            // 成功後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'success', fbDocId: docRef.id } : c
                )
            );

        } catch (error) {
            console.error("Firebase 待辨識卡片備份失敗:", error);
            handleFirestoreSaveError(error, "備份待辨識卡片"); // 使用錯誤處理機制
            
            // 失敗後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'error' } : c
                )
            );
        }
    }, [isAuthReady, userId, setPendingOcrCards]);

    // 新增函數：將辨識結果加入待確認序列
    const handleQueueNextCapture = useCallback((result) => {
        // 1. 建立具有初始同步狀態的新卡片物件
        const newCard = {
            ...result,
            id: uuidv4(), // 確保本地狀態有一個唯一 ID
            timestamp: Date.now(), // 本地時間戳 (用於排序/顯示)
            syncStatus: 'pending', // 初始狀態設為處理中
        };
        
        // 2. 更新本地狀態 (立即顯示卡片)
        setPendingOcrCards(prev => [...prev, newCard]);

        // 3. 觸發 Firebase 備份
        backupOcrCardToFirebase(newCard); 
        
        setStatusMessage(`已將辨識結果加入待確認序列！`);
    }, [setPendingOcrCards, backupOcrCardToFirebase]);

    // 新增函數：移除待確認的辨識卡片
    const handleRemovePendingOcrCard = useCallback((cardId) => {
        setPendingOcrCards(prev => prev.filter(item => item.id !== cardId));
    }, []);

    const handleStoreSelect = useCallback((selectedStore) => {
        setStoreName(selectedStore);
        setIsStoreSelectorOpen(false);
        // 不再自動觸發保存操作，與其他頁面保持一致
    }, [setStoreName, setIsStoreSelectorOpen]);

    const handleCaptureModalClose = useCallback(() => {
        setIsCaptureModalOpen(false);
        stopCameraStream();
    }, [stopCameraStream]);

    const handleNewScanClick = async () => {
        clearForm();
        const stream = await startCameraStream();
        if (stream) {
            setIsCaptureModalOpen(true);
        } else {
            // 如果無法啟動相機，顯示錯誤訊息
            setStatusMessage("無法啟動相機，請檢查權限設置");
        }
    };

    const themePrimary = currentTheme.primary;
    const themeText = currentTheme.text;
    const themeLight = currentTheme.light;
    const themeBorder = currentTheme.border;
    const themeHover = currentTheme.hover; // 添加這一行來定義 themeHover

    const productNamePlaceholder = useMemo(() => {
        switch(lookupStatus) {
            case 'searching': return '正在查詢產品資料...';
            case 'found': return '產品名稱已自動載入';
            case 'new': return '產品不存在，請手動輸入名稱';
            default: return '請先輸入條碼或掃描條碼';
        }
    }, [lookupStatus]);

    if (!isAuthReady) {
        return <div className="flex items-center justify-center min-h-screen bg-gray-50"><p className="text-xl text-gray-700">正在連線至雲端服務...</p></div>;
    }

    if (currentPage === 'allRecords') {
        return <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />;
    }

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${themeLight}`}>
            <SaveResultToast result={saveResultToast} onClose={() => setSaveResultToast(null)} />
            
            {/* 新增 SettingsPage 的渲染 */}
            {isSettingsOpen && (
                <SettingsPage 
                    theme={currentTheme} 
                    onClose={() => setIsSettingsOpen(false)} 
                    onDataChange={handleDataRefresh}
                />
            )}

            {/* 根據 currentPage 狀態渲染不同頁面 */}
            {currentPage === 'main' && (
                <div className="max-w-xl mx-auto">
                    <header className="flex justify-between items-center mb-6 border-b pb-4">
                        <h1 className={`text-3xl font-extrabold ${themeText} flex items-center`}><Barcode className="w-8 h-8 mr-2" />條碼比價神器 (Cloud)</h1>
                        <div className="flex items-center space-x-3">
                            {/* 新增待辨識的按鈕 */}
                            <button 
                                onClick={() => setCurrentPage('ocrQueue')}
                                className={`relative p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`}
                                title={`待辨識 (${pendingOcrCards.length})`}
                            >
                                <Zap className="w-5 h-5" />
                                {pendingOcrCards.length > 0 && (
                                    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                                        {pendingOcrCards.length}
                                    </span>
                                )}
                            </button>
                            <button onClick={() => setCurrentPage('allRecords')} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="查看所有記錄"><Database className="w-5 h-5" /></button>
                            <button onClick={() => setIsThemeModalOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定介面主題"><PaintBucket className="w-5 h-5" /></button>
                            {/* 新增設定按鈕 */}
                            <button onClick={() => setIsSettingsOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定"><SettingsIcon className="w-5 h-5" /></button>
                            <p className="text-sm text-gray-500 hidden sm:block">User: {userId.slice(0, 8)}...</p>
                        </div>
                    </header>

                    {statusMessage && <div className="bg-blue-500 text-white p-3 rounded-lg shadow-md mb-4 text-center font-medium">{statusMessage}</div>}

                    {ocrResult && (
                        <div className="bg-yellow-100 border border-yellow-300 rounded-lg p-4 mb-6">
                            <h3 className="text-lg font-semibold text-yellow-800 mb-2">AI 辨識結果 (開發者確認區)</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm">
                                <div>條碼:</div><div>{ocrResult.scannedBarcode || 'N/A'}</div>
                                <div>品名:</div><div>{ocrResult.productName || 'N/A'}</div>
                                {/* 顯示原價和特價信息 */}
                                {ocrResult.specialPrice ? (
                                    <>
                                        {ocrResult.originalPrice && (
                                            <>
                                                <div>原價:</div><div className="line-through text-red-500">${ocrResult.originalPrice.toFixed(2)}</div>
                                            </>
                                        )}
                                        <div>特價:</div><div className="text-green-600 font-bold">${ocrResult.specialPrice.toFixed(2)}</div>
                                    </>
                                ) : (
                                    <>
                                        <div>價格:</div><div>${ocrResult.extractedPrice || 'N/A'}</div>
                                    </>
                                )}
                                <div>數量:</div><div>{ocrResult.quantity || 'N/A'}</div>
                                <div>商店:</div><div>{ocrResult.storeName || 'N/A'}</div>
                                <div>折扣:</div><div>{ocrResult.discountDetails || '無'}</div>
                            </div>
                            <button onClick={() => setOcrResult(null)} className="mt-3 px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 text-sm">關閉</button>
                        </div>
                    )}

                    <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${themeBorder}`}>
                        <h2 className={`text-xl font-semibold ${themeText} mb-6 flex items-center`}><Zap className="w-5 h-5 mr-2" />步驟 1: AI 視覺自動擷取</h2>
                        <button className={`w-full p-4 rounded-lg text-white font-bold text-lg shadow-xl transition-all ${themePrimary} hover:opacity-80 flex items-center justify-center`} onClick={handleNewScanClick}>
                            <Camera className="inline-block w-6 h-6 mr-3" />開啟鏡頭擷取
                        </button>
                        <hr className="my-6 border-gray-200" />
                        <h2 className={`text-xl font-semibold text-gray-700 mb-4 flex items-center`}><FileText className="w-5 h-5 mr-2" />步驟 2: 檢查或手動輸入</h2>
                        
                        {/* 新增的擷取畫面顯示區塊 */}
                        {capturedImage && (
                            <div className="mb-6">
                                <label className="block text-gray-700 font-medium mb-2">擷取畫面 (請確認辨識資料是否正確)</label>
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                    <div className="relative w-full aspect-video">
                                        {capturedImage.startsWith('data:image') ? (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        ) : (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        )}
                                    </div>
                                </div>
                                <p className="text-sm text-gray-500 mt-2">此圖片將持續顯示直到進行下一次辨識或退出應用程式</p>
                            </div>
                        )}
                        
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">條碼數據</label>
                            <input type="text" value={barcode} onChange={(e) => setBarcode(e.target.value)} placeholder="AI 自動填入，或手動輸入" className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" />
                        </div>
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">產品名稱</label>
                            <input type="text" value={productName} onChange={(e) => setProductName(e.target.value)} placeholder={productNamePlaceholder} className={`w-full p-3 border border-gray-300 rounded-lg ${lookupStatus === 'found' ? 'bg-green-50' : lookupStatus === 'new' ? 'bg-yellow-50' : ''}`} readOnly={lookupStatus === 'found' && !ocrResult} />
                            <p className="text-sm text-gray-500 mt-1">ID (Hash): {barcode ? djb2Hash(barcode) : 'N/A'}</p>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">總價 ($) <span className="text-red-500">*</span></label>
                                <input type="number" value={currentPrice} onChange={(e) => setCurrentPrice(e.target.value)} placeholder="AI 擷取" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">商店名稱</label>
                                <input 
                                    type="text" 
                                    value={storeName} 
                                    onFocus={() => setIsStoreSelectorOpen(true)}
                                    readOnly
                                    placeholder="點擊選擇商店"
                                    className="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 cursor-pointer"
                                />
                            </div>
                        </div>
                        <div className="grid grid-cols-3 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">數量 <span className="text-red-500">*</span></label>
                                <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="例如: 500" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單位 <span className="text-red-500">*</span></label>
                                <select value={unitType} onChange={(e) => setUnitType(e.target.value)} className="w-full p-3 border border-gray-300 rounded-lg">
                                    <option value="ml">ml (毫升)</option>
                                    <option value="g">g (克)</option>
                                    <option value="pcs">pcs (個/包/支/條)</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單價 (每100g/ml)</label>
                                <input type="text" value={formatUnitPrice(unitPrice)} readOnly className="w-full p-3 border border-gray-300 rounded-lg bg-gray-100" />
                            </div>
                        </div>
                        <div className="mb-6">
                            <label className="block text-gray-700 font-medium mb-1">優惠細節</label>
                            <input type="text" value={discountDetails} onChange={(e) => setDiscountDetails(e.target.value)} placeholder="例如: 買二送一" className="w-full p-3 border border-gray-300 rounded-lg" />
                        </div>
                        <button className={`w-full mt-4 p-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-emerald-500 hover:bg-emerald-600`} onClick={() => saveAndComparePrice()} disabled={isLoading}>
                            <ClipboardCheck className="inline-block w-5 h-5 mr-2" />{isLoading ? '處理中...' : '步驟 3: 儲存紀錄並比價'}
                        </button>
                    </div>

                    <div className="mt-8">
                        <h2 className={`text-xl font-semibold ${themeText} mb-4 flex items-center`}>
                            <DollarSign className="w-5 h-5 mr-2" />
                            比價結果 {productName && <span className="ml-2 font-normal text-gray-500">- {productName}</span>}
                        </h2>
                        <div className={`p-6 rounded-xl shadow-xl border-2 ${comparisonResult.isBest ? 'border-green-500 bg-green-50' : 'border-yellow-500 bg-yellow-50'}`}>
                            <p className={`text-lg font-bold ${comparisonResult.isBest ? 'text-green-700' : 'text-yellow-700'}`}>{comparisonResult.message}</p>
                            {comparisonResult.bestPrice && <p className="text-sm text-gray-600 mt-2">歷史最低標價: ${comparisonResult.bestPrice}</p>}
                            <p className="text-xs text-gray-500 mt-2">**附註:** 您的紀錄已安全儲存在雲端。</p>
                        </div>
                    </div>

                    {(lookupStatus === 'found' || lookupStatus === 'new') && <PriceHistoryDisplay historyRecords={productHistory} theme={currentTheme} />}
                    
                    {/* 在主介面添加一個快捷處理待辨識卡片的按鈕 */}
                    {pendingOcrCards.length > 0 && (
                        <div className="mt-4 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold text-yellow-800">有待辨識的項目</h3>
                                    <p className="text-sm text-yellow-600">您有 {pendingOcrCards.length} 個待辨識的項目等待處理</p>
                                </div>
                                <button 
                                    onClick={() => {
                                        // 處理第一個待辨識的卡片
                                        const firstCard = pendingOcrCards[0];
                                        
                                        // 設置表單數據
                                        setOcrResult(firstCard);
                                        setCapturedImage(firstCard.capturedImage);
                                        setBarcode(firstCard.scannedBarcode || '');
                                        setProductName(firstCard.productName || '');
                                        setCurrentPrice(firstCard.extractedPrice || '');
                                        setStoreName(firstCard.storeName || '');
                                        setDiscountDetails(firstCard.discountDetails || '');
                                        setQuantity(firstCard.quantity || '');
                                        setUnitType(firstCard.unitType || 'pcs');
                                        
                                        // 計算單價
                                        const priceValue = parseFloat(firstCard.extractedPrice);
                                        const qty = parseFloat(firstCard.quantity);
                                        if (!isNaN(priceValue) && !isNaN(qty) && qty > 0) {
                                            const calculatedUnitPrice = calculateUnitPrice(priceValue, qty, firstCard.unitType);
                                            setUnitPrice(calculatedUnitPrice);
                                        }
                                        
                                        // 更新狀態
                                        if (firstCard.productName && firstCard.scannedBarcode) {
                                            setLookupStatus('found');
                                        } else {
                                            setLookupStatus('new');
                                        }
                                        
                                        // 從待辨識序列中移除該卡片
                                        setPendingOcrCards(prev => prev.filter(item => item.id !== firstCard.id));
                                        
                                        // 顯示提示訊息
                                        setStatusMessage(`已載入待辨識項目: ${firstCard.productName || '未命名產品'}`);
                                    }}
                                    className={`px-4 py-2 rounded-lg text-white font-medium ${themePrimary} ${themeHover}`}
                                >
                                    處理第一個待辨識項目
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            )}
            
            {currentPage === 'allRecords' && (
                <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />
            )}
            
            {currentPage === 'ocrQueue' && (
                <OcrQueuePage 
                    theme={currentTheme} 
                    onBack={() => setCurrentPage('main')} 
                    pendingOcrCards={pendingOcrCards}
                    onRemoveCard={handleRemovePendingOcrCard}
                    onStoreSelect={setPendingOcrCards}
                    isStoreSelectorOpen={isOcrQueueStoreSelectorOpen}
                    onStoreSelectCallback={handleOcrQueueStoreSelect}
                    onCloseStoreSelector={handleOcrQueueStoreSelectorClose}
                />
            )}

            {isThemeModalOpen && <ThemeSelector theme={currentTheme} saveTheme={saveUserTheme} onClose={() => setIsThemeModalOpen(false)} />}
            {isCaptureModalOpen && <AIOcrCaptureModal theme={currentTheme} onAnalysisSuccess={handleAiCaptureSuccess} onClose={handleCaptureModalClose} stream={streamRef.current} onQueueNextCapture={handleQueueNextCapture} />}
            {isStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleStoreSelect} onClose={() => setIsStoreSelectorOpen(false)} />}
            {isOcrQueueStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleOcrQueueStoreSelectConfirm} onClose={handleOcrQueueStoreSelectorClose} />}
        </div>
    );
}

export default App;
</file>

<file path="components/AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

</files>
</file>

<file path="components/DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="components/SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

<file path="firebase-config.js">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAtaZL06wkWJHhOJdne2Z_h9fMIEYldgjM",
  authDomain: "barcodepricing-00898.firebaseapp.com",
  projectId: "barcodepricing-00898",
  storageBucket: "barcodepricing-00898.firebasestorage.app",
  messagingSenderId: "286146042453",
  appId: "1:286146042453:web:14a20a662dcf3d06f592dc",
  measurementId: "G-6GMRVJ4S52"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

export { db };
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="OcrQueuePage.js">
import React, { useState, useEffect, useCallback } from 'react';
import { ArrowLeft, Trash2, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { db } from './firebase-config.js';
import { doc, setDoc, addDoc, collection, serverTimestamp, getDoc, query, where, getDocs } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 計算 localStorage 使用量的函數
function getLocalStorageUsage() {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += (localStorage[key].length + key.length) * 2; // 每個字符佔用 2 bytes
    }
  }
  const used = (total / 1024).toFixed(2); // 轉換為 KB
  const quota = 5120; // 大多数瀏覽器的 localStorage 限制約為 5MB
  const percentage = ((used / quota) * 100).toFixed(2);
  
  return {
    used: used,
    quota: quota,
    percentage: percentage
  };
}

// 刪除確認對話框組件
function DeleteConfirmation({ card, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p className="mb-4">您確定要刪除此待辨識項目嗎？</p>
                <p className="mb-4 font-semibold text-gray-800">{card.productName || '未命名產品'}</p>
                <div className="flex justify-end space-x-3">
                    <button 
                        onClick={onClose}
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                    >
                        取消
                    </button>
                    <button 
                        onClick={onConfirm}
                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                    >
                        確認刪除
                    </button>
                </div>
            </div>
        </div>
    );
}

function OcrQueuePage({ theme, onBack, pendingOcrCards, onRemoveCard, onStoreSelect, 
    isStoreSelectorOpen, onStoreSelectCallback, onCloseStoreSelector }) {
    const [queueStats, setQueueStats] = useState({
        total: 0,
        oldest: null,
        newest: null
    });
    
    // 新增狀態：localStorage 使用量
    const [localStorageUsage, setLocalStorageUsage] = useState({
        used: 0,
        quota: 5120,
        percentage: 0
    });
    
    // 新增狀態：刪除確認對話框
    const [deleteConfirmation, setDeleteConfirmation] = useState(null);
    
    // 新增狀態：正在編輯的卡片
    // 移除 editingCard 狀態，因為現在由父組件控制
    // const [editingCard, setEditingCard] = useState(null);
    
    // 新增狀態：比價結果
    const [priceComparisonResults, setPriceComparisonResults] = useState({});

    useEffect(() => {
        if (pendingOcrCards.length > 0) {
            const timestamps = pendingOcrCards.map(card => card.id);
            setQueueStats({
                total: pendingOcrCards.length,
                oldest: Math.min(...timestamps),
                newest: Math.max(...timestamps)
            });
        } else {
            setQueueStats({
                total: 0,
                oldest: null,
                newest: null
            });
        }
        
        // 更新 localStorage 使用量
        setLocalStorageUsage(getLocalStorageUsage());
    }, [pendingOcrCards]);

    const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleString('zh-TW');
    };

    const calculateDuration = (timestamp) => {
        const now = Date.now();
        const diffMs = now - timestamp;
        const diffSecs = Math.floor(diffMs / 1000);
        const diffMins = Math.floor(diffSecs / 60);
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            return `${diffHours}小時前`;
        } else if (diffMins > 0) {
            return `${diffMins}分鐘前`;
        } else {
            return `${diffSecs}秒前`;
        }
    };

    // 處理刪除操作
    const handleDeleteClick = (card) => {
        setDeleteConfirmation(card);
    };

    // 確認刪除
    const confirmDelete = () => {
        if (deleteConfirmation) {
            onRemoveCard(deleteConfirmation.id);
            setDeleteConfirmation(null);
            // 刪除後更新 localStorage 使用量
            setTimeout(() => {
                setLocalStorageUsage(getLocalStorageUsage());
            }, 100);
        }
    };

    // 取消刪除
    const cancelDelete = () => {
        setDeleteConfirmation(null);
    };

    // 處理儲存操作 - 檢查商店名稱
    const handleSaveClick = async (card) => {
        // 檢查商店名稱是否為空白
        if (!card.storeName || card.storeName.trim() === '') {
            // 如果商店名稱為空白，顯示商店選擇器
            onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
        } else {
            // 如果商店名稱不為空白，直接儲存（不再彈出確認對話框）
            try {
                // 儲存到 Firebase
                await saveOcrCardToFirebase(card);
                
                // 從待辨識序列中移除
                onRemoveCard(card.id);
                
                // 儲存後更新 localStorage 使用量
                setTimeout(() => {
                    setLocalStorageUsage(getLocalStorageUsage());
                }, 100);
                
                // 儲存成功時不顯示任何訊息
            } catch (error) {
                console.error("儲存失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "儲存待辨識卡片");
                showUserFriendlyError(userMessage);
            }
        }
    };

    // 處理卡片欄位變更
    const handleCardChange = (cardId, field, value) => {
        const updatedCards = pendingOcrCards.map(card => 
            card.id === cardId ? { ...card, [field]: value } : card
        );
        onStoreSelect(updatedCards);
        
        // 當價格相關欄位變更時，重新計算比價結果
        if (field === 'extractedPrice' || field === 'specialPrice' || field === 'originalPrice' || field === 'quantity' || field === 'unitType') {
            // 延遲一點時間再重新計算，確保狀態已更新
            setTimeout(() => {
                const fetchPriceComparisonResults = async () => {
                    const results = {};
                    for (const card of updatedCards) {
                        const result = await checkIfBestPrice(card, updatedCards);
                        results[card.id] = result;
                    }
                    setPriceComparisonResults(results);
                };
                
                fetchPriceComparisonResults();
            }, 0);
        }
    };

    // 處理商店欄位點擊
    const handleStoreClick = (card) => {
        onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
    };

    // 儲存 OCR 卡片到 Firebase
    const saveOcrCardToFirebase = async (card) => {
        // 生成產品 ID
        const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
        const priceValue = parseFloat(finalPrice);
        
        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
        
        // 儲存產品資訊
        const productRef = doc(db, "products", numericalID.toString());
        const productSnap = await getDoc(productRef);
        if (!productSnap.exists()) {
            await setDoc(productRef, {
                numericalID,
                barcodeData: card.scannedBarcode,
                productName: card.productName,
                createdAt: serverTimestamp(),
                lastUpdatedBy: "ocr-queue", // 標記為來自 OCR 隊列
            });
        }
        
        // 儲存價格記錄
        const priceRecord = {
            numericalID,
            productName: card.productName,
            storeName: card.storeName,
            price: priceValue, // 總價
            quantity: parseFloat(card.quantity),
            unitType: card.unitType,
            unitPrice: calculatedUnitPrice, // 單價
            discountDetails: card.discountDetails || '',
            timestamp: serverTimestamp(),
            recordedBy: "ocr-queue", // 標記為來自 OCR 隊列
            // 保存原價和特價信息（如果有的話）
            originalPrice: card.originalPrice ? parseFloat(card.originalPrice) : null,
            specialPrice: card.specialPrice ? parseFloat(card.specialPrice) : null
        };
        
        await addDoc(collection(db, "priceRecords"), priceRecord);
    };

    // 生成產品 ID 的函數
    function generateProductId(barcode, productName, storeName) {
        function djb2Hash(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i);
            }
            return hash >>> 0;
        }
        
        if (barcode) {
            return djb2Hash(barcode).toString();
        } else {
            // Combine productName and storeName to create a unique ID for products without barcodes
            return djb2Hash(`${productName}-${storeName}`).toString();
        }
    }

    // 新增函數：檢查價格是否為歷史最低（包含待辨識序列中的卡片）
    const checkIfBestPrice = useCallback(async (card, allCards) => {
        try {
            // 生成產品 ID
            const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
            
            if (!numericalID) return null;
            
            // 使用新的價格計算函數來確定最終價格
            const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
            const priceValue = parseFloat(finalPrice);
            
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
            
            if (calculatedUnitPrice === null) return null;
            
            // 查詢 Firebase 中該產品的所有價格記錄
            const recordsQuery = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID)
            );
            
            const recordsSnap = await getDocs(recordsQuery);
            const records = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 準備所有記錄以進行比較（包括當前記錄和待辨識序列中的相同產品）
            let allRecordsForCompare = [...records, { 
                unitPrice: calculatedUnitPrice,
                timestamp: new Date()
            }];
            
            // 添加待辨識序列中相同產品的卡片（排除當前卡片）
            const sameProductCards = allCards.filter(c => 
                c.id !== card.id && 
                generateProductId(c.scannedBarcode, c.productName, c.storeName) === numericalID
            );
            
            // 將相同產品的卡片添加到比較列表中
            sameProductCards.forEach(c => {
                const cardFinalPrice = calculateFinalPrice(c.extractedPrice, c.specialPrice);
                const cardPriceValue = parseFloat(cardFinalPrice);
                const cardUnitPrice = calculateUnitPrice(cardPriceValue, c.quantity, c.unitType);
                
                if (cardUnitPrice !== null) {
                    allRecordsForCompare.push({
                        unitPrice: cardUnitPrice,
                        timestamp: new Date(c.id) // 使用卡片 ID 作為時間戳
                    });
                }
            });

            // 如果沒有歷史記錄，則當前價格就是最低價
            if (allRecordsForCompare.length <= 1) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            }
            
            // 使用與主頁面相同的比價邏輯
            const bestDeal = allRecordsForCompare.reduce((best, cur) => {
                const curUnitPrice = cur.unitPrice !== undefined && cur.unitPrice !== null ? cur.unitPrice : Infinity;
                const bestUnitPrice = best.unitPrice !== undefined && best.unitPrice !== null ? best.unitPrice : Infinity;
                return curUnitPrice < bestUnitPrice ? cur : best;
            });

            const isBest = calculatedUnitPrice <= (bestDeal.unitPrice !== undefined && bestDeal.unitPrice !== null ? bestDeal.unitPrice : Infinity);
            
            if (isBest) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            } else {
                return { isBest: false, message: "非歷史最低價", backgroundColor: "bg-yellow-100" };
            }
        } catch (error) {
            console.error("比價檢查失敗:", error);
            return null;
        }
    }, []);

    // 當待辨識卡片列表改變時，重新計算比價結果
    useEffect(() => {
        const fetchPriceComparisonResults = async () => {
            const results = {};
            for (const card of pendingOcrCards) {
                const result = await checkIfBestPrice(card, pendingOcrCards);
                results[card.id] = result;
            }
            setPriceComparisonResults(results);
        };
        
        if (pendingOcrCards.length > 0) {
            fetchPriceComparisonResults();
        } else {
            setPriceComparisonResults({});
        }
    }, [pendingOcrCards, checkIfBestPrice]);

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${theme.bg}`}>
            <div className="max-w-2xl mx-auto">
                <div className="flex items-center mb-6 border-b pb-4">
                    <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4">
                        <ArrowLeft className="mr-1" size={20} />返回
                    </button>
                    <h1 className={`text-2xl font-bold ${theme.text} flex items-center`}>
                        <Clock className="w-6 h-6 mr-2" />待辨識序列管理
                    </h1>
                </div>

                {queueStats.total > 0 ? (
                    <div className="mb-6 p-4 bg-white rounded-lg shadow">
                        <h2 className="text-lg font-semibold mb-3">序列統計</h2>
                        {/* 改為橫式條列呈現 */}
                        <div className="flex flex-wrap gap-4">
                            <div className="flex items-center">
                                <div className="bg-blue-100 p-2 rounded-full mr-2">
                                    <span className="text-blue-600 font-bold">{queueStats.total}</span>
                                </div>
                                <span className="text-gray-600">總數</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-green-100 p-2 rounded-full mr-2">
                                    <span className="text-green-600 font-bold">{queueStats.oldest ? formatTime(queueStats.oldest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最早</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-purple-100 p-2 rounded-full mr-2">
                                    <span className="text-purple-600 font-bold">{queueStats.newest ? formatTime(queueStats.newest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最新</span>
                            </div>
                        </div>
                        
                        {/* localStorage 使用量顯示 */}
                        <div className="mt-4 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                ) : (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <AlertCircle size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">無待辨識項目</h3>
                        <p className="text-gray-500">目前沒有任何待確認的辨識卡片</p>
                        
                        {/* localStorage 使用量顯示（即使沒有項目也顯示） */}
                        <div className="mt-6 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                )}

                <div className="space-y-4">
                    {pendingOcrCards.map((card) => (
                        <div 
                            key={card.id} 
                            className={`bg-white p-4 rounded-lg shadow border-4 relative ${
                                priceComparisonResults[card.id]?.isBest 
                                    ? 'border-green-500' 
                                    : 'border-yellow-500'
                            }`}
                        >
                            <div className="flex justify-between items-start">
                                <div className="flex-1">
                                    {/* 將比價結果移到卡片頂部 */}
                                    {priceComparisonResults[card.id] && (
                                        <div className={`mb-3 p-2 rounded text-center text-base font-bold ${
                                            priceComparisonResults[card.id].isBest 
                                                ? 'bg-green-500 text-white' 
                                                : 'bg-yellow-500 text-pink-800'
                                        }`}>
                                            {priceComparisonResults[card.id].message}
                                        </div>
                                    )}
                                    
                                    <input
                                        type="text"
                                        value={card.productName || ''}
                                        onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                        className="font-bold text-lg text-gray-800 w-full p-1 mb-2 border-b border-gray-300 focus:border-blue-500 focus:outline-none"
                                        placeholder="產品名稱"
                                    />
                                    
                                    {/* 擷取畫面顯示 */}
                                    {card.capturedImage && (
                                        <div className="mt-3 mb-3">
                                            <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                                <div className="relative w-full aspect-video">
                                                    {card.capturedImage.startsWith('data:image') ? (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    ) : (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-1 mt-1 text-sm">
                                        {/* 條碼欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">條碼數據</label>
                                            <input
                                                type="text"
                                                value={card.scannedBarcode || ''}
                                                onChange={(e) => handleCardChange(card.id, 'scannedBarcode', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="條碼"
                                            />
                                        </div>
                                        
                                        {/* 產品名稱欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">產品名稱</label>
                                            <input
                                                type="text"
                                                value={card.productName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="產品名稱"
                                            />
                                        </div>
                                        
                                        {/* 商店欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">商店名稱</label>
                                            <input
                                                type="text"
                                                value={card.storeName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'storeName', e.target.value)}
                                                onClick={() => handleStoreClick(card)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 bg-gray-50 cursor-pointer"
                                                placeholder="點擊選擇商店"
                                            />
                                        </div>
                                        
                                        {/* 價格欄位 */}
                                        {card.specialPrice !== undefined ? (
                                            <>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">原價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.originalPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'originalPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                        placeholder="原價"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">特價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.specialPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'specialPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 text-green-600 font-bold"
                                                        placeholder="特價"
                                                    />
                                                </div>
                                            </>
                                        ) : (
                                            <div className="col-span-2">
                                                <label className="block text-gray-700 font-medium mb-0.5">總價 ($)</label>
                                                <input
                                                    type="number"
                                                    value={card.extractedPrice || ''}
                                                    onChange={(e) => handleCardChange(card.id, 'extractedPrice', e.target.value)}
                                                    className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                    placeholder="價格"
                                                />
                                            </div>
                                        )}
                                        
                                        {/* 數量和單位 */}
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">數量</label>
                                            <input
                                                type="text"
                                                value={card.quantity || ''}
                                                onChange={(e) => handleCardChange(card.id, 'quantity', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="數量"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">單位</label>
                                            <select
                                                value={card.unitType || 'pcs'}
                                                onChange={(e) => handleCardChange(card.id, 'unitType', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                            >
                                                <option value="ml">ml (毫升)</option>
                                                <option value="g">g (克)</option>
                                                <option value="pcs">pcs (個/包/支/條)</option>
                                            </select>
                                        </div>
                                        
                                        {/* 單價 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">單價 (每100g/ml)</label>
                                            <input
                                                type="text"
                                                value={formatUnitPrice(card.unitPrice)}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded bg-gray-100"
                                            />
                                        </div>
                                        
                                        {/* 優惠資訊 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">優惠細節</label>
                                            <input
                                                type="text"
                                                value={card.discountDetails || ''}
                                                onChange={(e) => handleCardChange(card.id, 'discountDetails', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="優惠資訊"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>加入時間: {formatTime(card.id)}</p>
                                        <p>運行時間: {calculateDuration(card.id)}</p>
                                    </div>
                                    
                                    {/* 新增狀態圖示區塊 - 位於運行時間下面 */}
                                    <div className="absolute bottom-2 right-2">
                                        {card.syncStatus === 'pending' && (
                                            <Clock 
                                                className="w-4 h-4 text-yellow-500 animate-spin" 
                                                title="正在同步至 Firebase..." 
                                            />
                                        )}
                                        {card.syncStatus === 'success' && (
                                            <CheckCircle 
                                                className="w-4 h-4 text-green-500" 
                                                title="已成功同步至 Firebase" 
                                            />
                                        )}
                                        {card.syncStatus === 'error' && (
                                            <AlertCircle 
                                                className="w-4 h-4 text-red-500" 
                                                title="同步失敗，請檢查網路或重試" 
                                            />
                                        )}
                                    </div>
                                </div>
                                <div className="flex flex-col">
                                    <button 
                                        onClick={() => handleSaveClick(card)}
                                        className="p-2 text-green-500 hover:text-green-700 hover:bg-green-50 rounded-full"
                                        title="確認儲存"
                                    >
                                        <CheckCircle size={20} />
                                    </button>
                                    <button 
                                        onClick={() => handleDeleteClick(card)}
                                        className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full mt-5"
                                        title="刪除"
                                    >
                                        <Trash2 size={20} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            
            {/* 刪除確認對話框 - 保留 */}
            {deleteConfirmation && (
                <DeleteConfirmation 
                    card={deleteConfirmation}
                    onClose={cancelDelete}
                    onConfirm={confirmDelete}
                />
            )}
        </div>
    );
}

export default OcrQueuePage;
</file>

<file path="src.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AllRecordsPage.js
App.css
App.js
components/AIOcrCaptureModal.js
components/AIOcrCaptureModal備份
firebase-config.js
index.css
index.js
OcrQueuePage.js
StoreSelector.js
utils/errorHandler.js
utils/errorHandler.test.js
utils/priceCalculations.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AllRecordsPage.js">
import React, { useState, useEffect, useMemo, useRef, useCallback, useLayoutEffect } from 'react';
import { ArrowLeft, Database, TrendingUp, Edit, Trash2, Save, X, CheckCircle, Search } from 'lucide-react';
import { collection, getDocs, query, orderBy, updateDoc, deleteDoc, doc } from 'firebase/firestore';
import { calculateUnitPrice, formatUnitPrice } from './utils/priceCalculations';
import StoreSelector from './StoreSelector';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 圖表組件
const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, productName }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp).sort((a, b) => a.timestamp - b.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間無足夠變化可繪圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <TrendingUp className="mr-1 text-gray-500" size={16} />
                單價走勢 - {productName}
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke="#4F46E5" strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === validRecords.length - 1 ? '#10B981' : '#4F46E5'} title={`${record.displayPrice.toFixed(2)} at ${record.timestamp.toLocaleDateString()}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>{new Date(minTimestamp).toLocaleDateString()}</span>
                <span>{new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

// Fuzzy search function
function fuzzyMatch(pattern, text) {
    const pattern_lower = pattern.toLowerCase();
    const text_lower = text.toLowerCase();
    let patternIdx = 0;
    let textIdx = 0;
    let score = 0;
    let consecutive = 0;
    let firstMatchIndex = -1;

    // Iterate through text to find pattern characters
    while (patternIdx < pattern_lower.length && textIdx < text_lower.length) {
        if (pattern_lower[patternIdx] === text_lower[textIdx]) {
            if (firstMatchIndex === -1) {
                firstMatchIndex = textIdx;
            }
            score += 1;
            // Add bonus for consecutive matches
            if (consecutive > 0) {
                score += consecutive;
            }
            consecutive++;
            patternIdx++;
        } else {
            consecutive = 0;
        }
        textIdx++;
    }

    // If the whole pattern was found
    if (patternIdx === pattern_lower.length) {
        // Add bonus for being a prefix
        if (firstMatchIndex === 0) {
            score += 5;
        }
        // Add bonus for tightness of the match
        const matchDensity = pattern.length / (textIdx - firstMatchIndex);
        score *= (1 + matchDensity);

        return score;
    }

    return 0;
}

// 可滑動的記錄項目
function SwipeableRecord({ children, onEdit, onDelete }) {
    const [translateX, setTranslateX] = useState(0);
    const touchStartX = useRef(0);
    const itemRef = useRef(null);
    const buttonsRef = useRef(null);

    const handleTouchStart = (e) => {
        touchStartX.current = e.touches[0].clientX;
    };

    const handleTouchMove = (e) => {
        const touchCurrentX = e.touches[0].clientX;
        const diff = touchCurrentX - touchStartX.current;
        if (diff < 0) { // 只允許向左滑動
            setTranslateX(Math.max(diff, -160)); // -160 是按鈕寬度的總和
        }
    };

    const handleTouchEnd = () => {
        if (translateX < -80) {
            setTranslateX(-160);
        } else {
            setTranslateX(0);
        }
    };

    useEffect(() => {
        const handleGlobalClick = (e) => {
            if (buttonsRef.current && !buttonsRef.current.contains(e.target)) {
                setTranslateX(0);
            }
        };

        if (translateX !== 0) {
            document.addEventListener('click', handleGlobalClick, true);
        }

        return () => {
            document.removeEventListener('click', handleGlobalClick, true);
        };
    }, [translateX]);

    const handleEdit = () => {
        onEdit();
        setTranslateX(0);
    };

    const handleDelete = () => {
        onDelete();
        setTranslateX(0);
    };

    return (
        <div className="relative overflow-hidden">
            <div ref={buttonsRef} className="absolute top-0 right-0 h-full flex items-center">
                <button onClick={handleEdit} className="bg-blue-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Edit size={20} />
                    <span>編輯</span>
                </button>
                <button onClick={handleDelete} className="bg-red-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Trash2 size={20} />
                    <span>刪除</span>
                </button>
            </div>
            <div
                ref={itemRef}
                className="transition-transform duration-300 ease-in-out"
                style={{ transform: `translateX(${translateX}px)` }}
                onTouchStart={handleTouchStart}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleTouchEnd}
            >
                {children}
            </div>
        </div>
    );
}


// 產品記錄組件
function ProductRecord({ product, records, theme, onEdit, onDelete }) {
    const formattedRecords = records.map(r => ({ ...r, timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp) })).sort((a, b) => b.timestamp - a.timestamp);
    
    const latestRecord = formattedRecords[0];
    if (!latestRecord) return null; // 如果沒有記錄，則不渲染此組件

    const validUnitPrices = formattedRecords.map(r => r.unitPrice).filter(p => !isNaN(p) && p !== undefined && p !== null);
    const lowestUnitPrice = validUnitPrices.length > 0 ? Math.min(...validUnitPrices) : 0;
    const highestUnitPrice = validUnitPrices.length > 0 ? Math.max(...validUnitPrices) : 0;
    const avgUnitPrice = validUnitPrices.length > 0 ? validUnitPrices.reduce((sum, p) => sum + p, 0) / validUnitPrices.length : 0;

    return (
        <div className={`p-4 rounded-xl shadow-lg bg-white border-t-4 ${theme.border} mb-6`}>
            <div className="flex justify-between items-start">
                <div>
                    <h3 className="text-lg font-bold text-gray-800">{product.productName}</h3>
                    <p className="text-sm text-gray-600">條碼: {product.barcodeData}</p>
                    <p className="text-xs text-gray-500">ID: {product.numericalID}</p>
                </div>
                <div className="text-right">
                    {/* 顯示原價和特價信息 */}
                    {latestRecord.specialPrice ? (
                        <div>
                            {latestRecord.originalPrice && (
                                <p className="text-lg text-gray-500 line-through">${latestRecord.originalPrice.toFixed(2)}</p>
                            )}
                            <p className="text-2xl font-bold text-indigo-600">${latestRecord.specialPrice.toFixed(2)}</p>
                            <p className="text-xs text-gray-500">@{formatUnitPrice(latestRecord.unitPrice)}</p>
                        </div>
                    ) : (
                        <p className="text-2xl font-bold text-indigo-600">{formatUnitPrice(latestRecord.unitPrice) === '--' ? (isNaN(latestRecord.price) ? 'N/A' : `$${(latestRecord.price || 0).toFixed(2)}`) : `$${(latestRecord.price || 0).toFixed(2)} @${formatUnitPrice(latestRecord.unitPrice)}`}</p>
                    )}
                    <p className="text-xs text-gray-500">{latestRecord.timestamp.toLocaleDateString()}</p>
                    {/* 顯示數量和單位 */}
                    {latestRecord.quantity && latestRecord.unitType && (
                        <p className="text-xs text-gray-500">數量: {latestRecord.quantity} {latestRecord.unitType}</p>
                    )}
                </div>
            </div>

            <div className="grid grid-cols-3 gap-2 my-3 text-center">
                <div className="bg-green-50 p-2 rounded"><p className="text-xs text-gray-500">最低單價</p><p className="font-bold text-green-600">{isNaN(lowestUnitPrice) ? 'N/A' : `${lowestUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-blue-50 p-2 rounded"><p className="text-xs text-gray-500">平均單價</p><p className="font-bold text-blue-600">{isNaN(avgUnitPrice) ? 'N/A' : `${avgUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-red-50 p-2 rounded"><p className="text-xs text-gray-500">最高單價</p><p className="font-bold text-red-600">{isNaN(highestUnitPrice) ? 'N/A' : `${highestUnitPrice.toFixed(2)}`}</p></div>
            </div>

            <div className="mb-4"><PriceTrendChart records={formattedRecords} productName={product.productName} /></div>

            <div className="mt-4">
                <h4 className="font-semibold text-gray-700 mb-2">價格記錄詳情</h4>
                <div className="space-y-2 max-h-40 overflow-y-auto">
                    {formattedRecords.map((record, index) => (
                        <SwipeableRecord
                            key={index}
                            onEdit={() => onEdit(record)}
                            onDelete={() => onDelete(record)}
                        >
                            <div className="flex justify-between items-center p-2 bg-gray-50 rounded">
                                <div>
                                    {/* 顯示原價和特價信息 */}
                                    {record.specialPrice ? (
                                        <p className="font-medium">
                                            {record.originalPrice && (
                                                <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                            )}
                                            <span className="text-red-600 ml-1">${record.specialPrice.toFixed(2)}</span>
                                            <span className="text-gray-500 ml-1">@{formatUnitPrice(record.unitPrice)}</span>
                                        </p>
                                    ) : (
                                        <p className="font-medium">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</p>
                                    )}
                                    {record.discountDetails && <p className="text-xs text-indigo-600">{record.discountDetails}</p>}
                                    {/* 顯示數量和單位 */}
                                    {record.quantity && record.unitType && (
                                        <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType}</p>
                                    )}
                                </div>
                                <div className="text-right">
                                    <p className="text-xs text-gray-500">{record.storeName || '未標註'}</p>
                                    <p className="text-xs text-gray-500">{record.timestamp.toLocaleDateString()}</p>
                                </div>
                            </div>
                        </SwipeableRecord>
                    ))}
                </div>
            </div>
        </div>
    );
}

// 主組件
function AllRecordsPage({ theme, onBack, db, userId, isAuthReady }) {
    const [allProducts, setAllProducts] = useState([]);
    const [allRecords, setAllRecords] = useState({});
    const [loading, setLoading] = useState(true);
    const [sortOption, setSortOption] = useState('latest'); // latest, name, price
    const [editingRecord, setEditingRecord] = useState(null);
    const [deletingRecord, setDeletingRecord] = useState(null);
    const [successMessage, setSuccessMessage] = useState('');
    const scrollPositionRef = useRef(0); // For scroll restoration
    const [isAfterDelete, setIsAfterDelete] = useState(false); // Signal for scroll restoration
    const [searchQuery, setSearchQuery] = useState('');
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const searchInputRef = useRef(null);
    
    // Edit mode states
    const [isEditMode, setIsEditMode] = useState(false);
    const [selectedItems, setSelectedItems] = useState(new Set());
    const [localProducts, setLocalProducts] = useState([]);
    const [localRecords, setLocalRecords] = useState({});
    // 新增狀態：批量刪除確認對話框
    const [isBulkDeleteConfirmationOpen, setIsBulkDeleteConfirmationOpen] = useState(false);
    // 新增狀態：原始數據快照和衝突解決
    const [originalDataSnapshot, setOriginalDataSnapshot] = useState(null);
    const [isConflictDialogOpen, setIsConflictDialogOpen] = useState(false);

    const fetchData = useCallback(async () => {
        if (!db) return;
        setLoading(true);
        try {
            // 1. Fetch all products
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const productsArray = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 2. Fetch all records
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const recordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // 3. Group records by product ID
            const recordsByProduct = {};
            recordsArray.forEach(record => {
                if (!recordsByProduct[record.numericalID]) {
                    recordsByProduct[record.numericalID] = [];
                }
                recordsByProduct[record.numericalID].push(record);
            });

            setAllProducts(productsArray);
            setAllRecords(recordsByProduct);

        } catch (error) {
            console.error('讀取 Firestore 數據失敗:', error);
            const userMessage = handleFirestoreSaveError(error, "讀取產品數據");
            showUserFriendlyError(userMessage);
        } finally {
            setLoading(false);
        }
    }, [db]);

    useEffect(() => {
        // 只有在 Firebase 已準備好時才執行查詢
        if (!isAuthReady || !userId) {
            // 如果 Firebase 尚未準備好，不應該顯示加載狀態
            // 讓用戶知道需要等待 Firebase 初始化
            return;
        }
        
        // Firebase 已準備好且有 userId，執行數據獲取
        fetchData();
    }, [fetchData, isAuthReady, userId]);

    useEffect(() => {
        if (isSearchOpen && searchInputRef.current) {
            setTimeout(() => searchInputRef.current.focus(), 100); // Shorter delay for responsiveness
        }
    }, [isSearchOpen]);

    useLayoutEffect(() => {
        if (isAfterDelete && !loading) {
            // Use requestAnimationFrame to ensure scroll happens after browser paints
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollPositionRef.current);
                setIsAfterDelete(false); // Reset the signal after scrolling
            });
        }
    }, [loading, isAfterDelete]);

    const filteredProducts = useMemo(() => {
        // Use local data in edit mode, otherwise use Firebase data
        const products = isEditMode ? localProducts : allProducts;
        const records = isEditMode ? localRecords : allRecords;

        if (searchQuery.trim() === '') {
            // No search query, just sort the products
            return [...products].sort((a, b) => {
                const recordsA = records[a.numericalID] || [];
                const recordsB = records[b.numericalID] || [];
                
                if (sortOption === 'name') {
                    return a.productName.localeCompare(b.productName);
                }
                
                const latestRecordA = recordsA[0];
                const latestRecordB = recordsB[0];

                if (sortOption === 'price') {
                    const priceA = latestRecordA?.price || -1;
                    const priceB = latestRecordB?.price || -1;
                    return priceB - priceA;
                }

                // Default to 'latest'
                const timeA = latestRecordA?.timestamp?.toDate ? latestRecordA.timestamp.toDate().getTime() : 0;
                const timeB = latestRecordB?.timestamp?.toDate ? latestRecordB.timestamp.toDate().getTime() : 0;
                return timeB - timeA;
            });
        }

        // Fuzzy search logic
        const scoredProducts = products
            .map(product => ({
                product,
                score: fuzzyMatch(searchQuery, product.productName)
            }))
            .filter(item => item.score > 0)
            .sort((a, b) => b.score - a.score);
        
        return scoredProducts.map(item => item.product);

    }, [allProducts, allRecords, sortOption, searchQuery, isEditMode, localProducts, localRecords]);

    const showSuccessMessage = (message) => {
        setSuccessMessage(message);
        setTimeout(() => {
            setSuccessMessage('');
        }, 2000);
    };

    const handleEdit = (record) => {
        setEditingRecord(record);
    };

    const handleDelete = (record) => {
        scrollPositionRef.current = window.scrollY; // Save scroll position
        setDeletingRecord(record);
    };

    // New function to handle checkbox selection
    const handleItemSelect = (productId) => {
        setSelectedItems(prev => {
            const newSet = new Set(prev);
            if (newSet.has(productId)) {
                newSet.delete(productId);
            } else {
                newSet.add(productId);
            }
            return newSet;
        });
    };

    // 修改批量刪除功能以使用確認對話框
    const handleBulkDeleteClick = () => {
        if (selectedItems.size === 0) return;
        setIsBulkDeleteConfirmationOpen(true);
    };

    // New function to delete selected items
    const deleteSelectedItems = async () => {
        if (selectedItems.size === 0) return;
        
        try {
            // Update local state
            setLocalProducts(prev => prev.filter(product => !selectedItems.has(product.numericalID)));
            setLocalRecords(prev => {
                const newRecords = {...prev};
                selectedItems.forEach(productId => {
                    delete newRecords[productId];
                });
                return newRecords;
            });
            
            // Clear selection
            setSelectedItems(new Set());
            setIsBulkDeleteConfirmationOpen(false);
        } catch (error) {
            console.error("Error deleting selected items:", error);
            const userMessage = handleFirestoreSaveError(error, "批量刪除產品");
            showUserFriendlyError(userMessage);
        }
    };

    // 新增函數：檢查衝突並退出編輯模式
    const checkForConflictsAndExit = async () => {
        if (!db || !originalDataSnapshot) return;
        
        try {
            // 獲取當前 Firebase 數據
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const currentProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 將記錄按產品 ID 分組
            const currentRecords = {};
            currentRecordsArray.forEach(record => {
                if (!currentRecords[record.numericalID]) {
                    currentRecords[record.numericalID] = [];
                }
                currentRecords[record.numericalID].push(record);
            });
            
            // 比較當前數據與原始快照
            const hasConflicts = checkForDataConflicts(originalDataSnapshot, {products: currentProducts, records: currentRecords});
            
            if (hasConflicts) {
                // 如果有衝突，顯示衝突解決對話框
                setIsConflictDialogOpen(true);
            } else {
                // 如果沒有衝突，直接退出編輯模式
                await exitEditMode(currentProducts, currentRecords);
            }
        } catch (error) {
            console.error("檢查數據衝突時出錯:", error);
            const userMessage = handleFirestoreSaveError(error, "檢查數據衝突");
            showUserFriendlyError(userMessage);
            // 出錯時仍然退出編輯模式
            await exitEditMode();
        }
    };
    
    // 新增函數：檢查數據衝突
    const checkForDataConflicts = (original, current) => {
        // 比較產品數量
        if (original.products.length !== current.products.length) {
            return true;
        }
        
        // 比較記錄數量
        const originalRecordCount = Object.values(original.records).reduce((count, records) => count + records.length, 0);
        const currentRecordCount = Object.values(current.records).reduce((count, records) => count + records.length, 0);
        
        if (originalRecordCount !== currentRecordCount) {
            return true;
        }
        
        // 更詳細的比較可以在此處添加
        // 為了簡化，我們只檢查數量變化
        
        return false;
    };
    
    // 修改 exitEditMode 函數以接受當前數據
    const exitEditMode = async (currentProducts = null, currentRecords = null) => {
        if (!db) return;
        
        try {
            // 如果沒有提供當前數據，則獲取最新數據
            let latestProducts = currentProducts;
            let latestRecords = currentRecords;
            
            if (!latestProducts || !latestRecords) {
                const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
                const productsSnap = await getDocs(productsQuery);
                latestProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
                const recordsSnap = await getDocs(recordsQuery);
                const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 將記錄按產品 ID 分組
                latestRecords = {};
                currentRecordsArray.forEach(record => {
                    if (!latestRecords[record.numericalID]) {
                        latestRecords[record.numericalID] = [];
                    }
                    latestRecords[record.numericalID].push(record);
                });
            }
            
            // 計算需要從 Firebase 刪除的產品
            const productsToDelete = latestProducts.filter(product => 
                !localProducts.some(localProduct => localProduct.numericalID === product.numericalID)
            );
            
            // 刪除 Firebase 中的產品及其記錄
            for (const product of productsToDelete) {
                // 刪除所有記錄
                const productRecords = latestRecords[product.numericalID] || [];
                for (const record of productRecords) {
                    const recordRef = doc(db, "priceRecords", record.id);
                    await deleteDoc(recordRef);
                }
            }
            
            // 計算需要從 Firebase 刪除的記錄（編輯模式下刪除的記錄）
            const recordsToDelete = [];
            for (const [productId, records] of Object.entries(latestRecords)) {
                const localRecordsForProduct = localRecords[productId] || [];
                // 找出在原始記錄中存在但在本地記錄中不存在的記錄
                const deletedRecords = records.filter(record => 
                    !localRecordsForProduct.some(localRecord => localRecord.id === record.id)
                );
                recordsToDelete.push(...deletedRecords);
            }
            
            // 刪除 Firebase 中的記錄
            for (const record of recordsToDelete) {
                const recordRef = doc(db, "priceRecords", record.id);
                await deleteDoc(recordRef);
            }
            
            // 重新從 Firebase 獲取數據
            await fetchData();
            setIsEditMode(false);
            setSelectedItems(new Set());
            setOriginalDataSnapshot(null);

        } catch (error) {
            console.error("Error syncing with Firebase:", error);
            const userMessage = handleFirestoreSaveError(error, "同步編輯數據");
            showUserFriendlyError(userMessage);
        }
    };

    const handleSaveEdit = async (updatedRecord) => {
        if (!db) return;
        try {
            const recordRef = doc(db, "priceRecords", updatedRecord.id);
            // 更新所有字段，不僅僅是價格和折扣詳情
            await updateDoc(recordRef, {
                price: updatedRecord.price,
                discountDetails: updatedRecord.discountDetails,
                productName: updatedRecord.productName,
                storeName: updatedRecord.storeName,
                quantity: updatedRecord.quantity,
                unitType: updatedRecord.unitType,
                unitPrice: updatedRecord.unitPrice,
                originalPrice: updatedRecord.originalPrice,
                specialPrice: updatedRecord.specialPrice
            });
            
            // 在編輯模式下，更新本地狀態而不是重新獲取所有數據
            if (isEditMode) {
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    
                    // 確保更新的記錄所屬的產品在 localRecords 中存在
                    if (!newRecords[updatedRecord.numericalID]) {
                        newRecords[updatedRecord.numericalID] = [];
                    }
                    
                    // 更新記錄
                    Object.keys(newRecords).forEach(productId => {
                        if (newRecords[productId]) {
                            newRecords[productId] = newRecords[productId].map(record => 
                                record.id === updatedRecord.id ? updatedRecord : record
                            ).filter(record => record !== undefined); // 過濾掉可能的 undefined 值
                        }
                    });
                    
                    // 確保當前更新的記錄存在於其對應的產品記錄中
                    if (!newRecords[updatedRecord.numericalID].some(record => record.id === updatedRecord.id)) {
                        newRecords[updatedRecord.numericalID].push(updatedRecord);
                    }
                    
                    return newRecords;
                });
                
                // 同時更新本地產品列表中的產品名稱
                setLocalProducts(prev => 
                    prev.map(product => 
                        product.numericalID === updatedRecord.numericalID 
                            ? {...product, productName: updatedRecord.productName} 
                            : product
                    )
                );
            } else {
                await fetchData(); // 非編輯模式下重新獲取數據以更新UI
            }
            
            showSuccessMessage('記錄已成功更新');
        } catch (error) {
            console.error("更新記錄失敗:", error);
            const userMessage = handleFirestoreSaveError(error, "更新價格記錄");
            showUserFriendlyError(userMessage);
        }
        setEditingRecord(null);
    };

    // 新增函數：處理衝突解決
    const handleConflictResolution = async (resolutionType) => {
        setIsConflictDialogOpen(false);
        
        switch (resolutionType) {
            case 'local':
                // 保留本地更改，直接退出編輯模式
                await exitEditMode();
                break;
            case 'remote':
                // 保留遠程數據，重新獲取最新數據並退出
                await fetchData();
                setIsEditMode(false);
                setSelectedItems(new Set());
                setOriginalDataSnapshot(null);

                break;
            case 'merge':
                // 手動合併，重新獲取數據並保持編輯模式
                await fetchData();
                setLocalProducts([...allProducts]);
                setLocalRecords({...allRecords});
                // 保持編輯模式開啟，讓用戶繼續編輯
                setOriginalDataSnapshot({
                    products: [...allProducts],
                    records: {...allRecords},
                    timestamp: Date.now()
                });

                break;
            default:
                // 默認情況下直接退出編輯模式
                await exitEditMode();
        }
    };

    const confirmDelete = async () => {
        if (!db || !deletingRecord) return;
        
        // 在編輯模式下，我們只需要更新本地狀態，不需要重新整理畫面
        if (isEditMode) {
            try {
                // 更新本地狀態而不是調用 Firebase
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    if (newRecords[deletingRecord.numericalID]) {
                        newRecords[deletingRecord.numericalID] = newRecords[deletingRecord.numericalID].filter(
                            record => record.id !== deletingRecord.id
                        );
                    }
                    return newRecords;
                });
                
                // 顯示成功消息
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            } finally {
                setDeletingRecord(null);
            }
        } else {
            // 非編輯模式下保持原有行為
            setIsAfterDelete(true); // Signal that the next data fetch is after a delete
            try {
                const recordRef = doc(db, "priceRecords", deletingRecord.id);
                await deleteDoc(recordRef);
                await fetchData(); // 重新獲取數據以更新UI
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            }
            setDeletingRecord(null);
        }
    };

    const handleSearchToggle = () => {
        if (isSearchOpen) {
            setSearchQuery('');
        }
        setIsSearchOpen(!isSearchOpen);
    };

    if (loading) {
        return (
            <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
                <div className="max-w-4xl mx-auto">
                    <div className="flex items-center mb-6">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800">所有記錄</h1>
                    </div>
                    <div className="text-center py-10">
                        {!isAuthReady ? (
                            <p>正在初始化雲端服務，請稍候...</p>
                        ) : !userId ? (
                            <p>正在獲取用戶信息，請稍候...</p>
                        ) : (
                            <p>正在從雲端加載數據...</p>
                        )}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
            <div className="max-w-4xl mx-auto pb-28"> {/* Added pb-28 for floating button */}
                <SuccessMessage message={successMessage} />
                <div className="flex flex-col sm:flex-row sm:items-center justify-between mb-6">
                    <div className="flex items-center mb-4 sm:mb-0">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800 flex items-center"><Database className="mr-2" />所有記錄</h1>
                    </div>
                    <div className="flex items-center">
                        <label className="mr-2 text-gray-700">排序:</label>
                        <select value={sortOption} onChange={(e) => setSortOption(e.target.value)} className="border border-gray-300 rounded p-2 mr-2">
                            <option value="latest">最新記錄</option>
                            <option value="name">產品名稱</option>
                            <option value="price">最新價格</option>
                        </select>
                        <button 
                            onClick={() => {
                                if (!isEditMode) {
                                    // Enter edit mode - copy current data to local state
                                    setLocalProducts([...allProducts]);
                                    setLocalRecords({...allRecords});
                                    // 保存原始數據快照和時間戳
                                    setOriginalDataSnapshot({
                                        products: [...allProducts],
                                        records: {...allRecords},
                                        timestamp: Date.now()
                                    });
                                } else {
                                    // Exit edit mode - 檢查數據版本衝突
                                    checkForConflictsAndExit();
                                }
                                setIsEditMode(!isEditMode);
                                setSelectedItems(new Set());
                            }}
                            className={`px-3 py-2 rounded text-white text-sm ${
                                isEditMode ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'
                            }`}
                        >
                            {isEditMode ? '退出編輯模式' : '編輯模式'}
                        </button>
                    </div>
                </div>

                {/* Floating Delete Button - 修改為固定位置 */}
                {isEditMode && selectedItems.size > 0 && (
                    <div className="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-4 shadow-lg z-50 flex items-center"
                         style={{bottom: '6rem'}}>
                        <button 
                            onClick={handleBulkDeleteClick}
                            className="flex items-center"
                        >
                            <Trash2 size={20} className="mr-2" />
                            刪除選取項目 ({selectedItems.size})
                        </button>
                    </div>
                )}

                {/* Floating Exit Edit Mode Button - 修改為固定位置 */}
                {isEditMode && (
                    <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white rounded-full p-4 shadow-lg z-50">
                        <button 
                            onClick={checkForConflictsAndExit}
                            className="flex items-center"
                        >
                            <X size={20} className="mr-2" />
                            退出編輯模式
                        </button>
                    </div>
                )}

                {filteredProducts.length === 0 ? (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <Database size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">{searchQuery ? '找不到結果' : '暫無記錄'}</h3>
                        <p className="text-gray-500">{searchQuery ? `找不到符合 "${searchQuery}" 的產品` : '還沒有任何產品和價格記錄'}</p>
                    </div>
                ) : (
                    <div>
                        <div className="mb-4 p-4 bg-white rounded-lg shadow">
                            <div className="flex justify-between">
                                <p className="text-gray-700">總共 <span className="font-bold">{filteredProducts.length}</span> 個產品</p>
                                <p className="text-gray-700">總共 <span className="font-bold">{Object.values(allRecords).flat().length}</span> 條記錄</p>
                            </div>
                        </div>
                        {filteredProducts.map(product => {
                            // 修復：確保 records 始終有默認值
                            const records = isEditMode ? (localRecords[product.numericalID] || []) : (allRecords[product.numericalID] || []);
                            // 修改：即使沒有記錄也顯示產品卡片，但只在編輯模式下
                            if (records.length === 0 && !isEditMode) return null;
                            return (
                                // 修改：為選中的項目添加增強的視覺反饋
                                <div key={product.numericalID} className={`relative transition-all duration-200 ${isEditMode && selectedItems.has(product.numericalID) ? 'bg-blue-50 border-2 border-blue-500 rounded-lg' : ''}`}>
                                    {isEditMode && (
                                        <div className="absolute top-4 left-4 z-10">
                                            <input
                                                type="checkbox"
                                                checked={selectedItems.has(product.numericalID)}
                                                onChange={() => handleItemSelect(product.numericalID)}
                                                className="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                                            />
                                        </div>
                                    )}
                                    <div className={isEditMode ? "pl-12" : ""}>
                                        <ProductRecord 
                                            product={product} 
                                            records={records} 
                                            theme={theme} 
                                            onEdit={handleEdit} 
                                            onDelete={handleDelete} 
                                        />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}

                {editingRecord && (
                    <EditModal
                        record={editingRecord}
                        onClose={() => setEditingRecord(null)}
                        onSave={handleSaveEdit}
                    />
                )}

                {deletingRecord && (
                    <DeleteConfirmation
                        record={deletingRecord}
                        onClose={() => setDeletingRecord(null)}
                        onConfirm={confirmDelete}
                    />
                )}

                {/* 新增批量刪除確認對話框 */}
                {isBulkDeleteConfirmationOpen && (
                    <BulkDeleteConfirmation
                        count={selectedItems.size}
                        onClose={() => setIsBulkDeleteConfirmationOpen(false)}
                        onConfirm={deleteSelectedItems}
                    />
                )}

                {/* 新增衝突解決對話框 */}
                {isConflictDialogOpen && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                            <h2 className="text-xl font-bold mb-4">檢測到數據衝突</h2>
                            <p className="mb-4">在您編輯期間，其他用戶修改了部分數據。請選擇如何解決衝突：</p>
                            
                            <div className="mb-6 p-4 bg-yellow-50 rounded-lg">
                                <h3 className="font-semibold text-yellow-800 mb-2">衝突詳情：</h3>
                                <ul className="list-disc pl-5 text-sm text-yellow-700">
                                    <li>數據可能已被人修改</li>
                                    <li>您的更改可能與其他用戶的更改衝突</li>
                                </ul>
                            </div>
                            
                            <div className="space-y-3">
                                <button 
                                    onClick={() => handleConflictResolution('local')}
                                    className="w-full p-3 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                                >
                                    保留我的更改
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('remote')}
                                    className="w-full p-3 bg-green-500 text-white rounded-md hover:bg-green-600"
                                >
                                    保留最新數據
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('merge')}
                                    className="w-full p-3 bg-purple-500 text-white rounded-md hover:bg-purple-600"
                                >
                                    手動合併（推薦）
                                </button>
                            </div>
                            
                            <div className="mt-6 flex justify-end">
                                <button 
                                    onClick={() => setIsConflictDialogOpen(false)}
                                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                                >
                                    取消
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- START: Revamped Search Component --- */}
                <div className="fixed top-6 right-6 z-30">
                    <div 
                        className={`flex items-center justify-end bg-white rounded-full shadow-xl transition-all duration-300 ease-in-out overflow-hidden ${isSearchOpen ? 'w-80' : 'w-16 h-16'}`}
                    >
                        <Search className={`absolute left-5 top-1/2 -translate-y-1/2 text-gray-400 transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`} size={22} />
                        <input
                            ref={searchInputRef}
                            type="text"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="輸入品名進行模糊搜尋..."
                            className={`w-full h-16 pl-14 pr-20 bg-transparent border-none rounded-full outline-none text-lg transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`}
                            style={{pointerEvents: isSearchOpen ? 'auto' : 'none'}}
                        />
                        <button
                            onClick={handleSearchToggle}
                            className="absolute right-0 top-0 w-16 h-16 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 flex items-center justify-center"
                            aria-label={isSearchOpen ? "關閉搜尋" : "開啟搜尋"}
                        >
                            {isSearchOpen ? <X size={28} /> : <Search size={28} />}
                        </button>
                    </div>
                </div>
                {/* --- END: Revamped Search Component --- */}
            </div>
        </div>
    );
}

function EditModal({ record, onClose, onSave }) {
    const [price, setPrice] = useState(record.price);
    const [quantity, setQuantity] = useState(record.quantity || '');
    const [unitType, setUnitType] = useState(record.unitType || 'pcs');
    const [discount, setDiscount] = useState(record.discountDetails || '');
    const [originalPrice, setOriginalPrice] = useState(record.originalPrice || '');
    const [specialPrice, setSpecialPrice] = useState(record.specialPrice || '');
    const [productName, setProductName] = useState(record.productName || '');
    const [storeName, setStoreName] = useState(record.storeName || '');
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);

    const handleSave = () => {
        const newUnitPrice = calculateUnitPrice(price, quantity, unitType);
        if (newUnitPrice === null) {
            alert("請輸入有效的價格和數量。");
            return;
        }
        onSave({ 
            ...record, 
            price: parseFloat(price),
            quantity: parseFloat(quantity),
            unitType: unitType,
            unitPrice: newUnitPrice,
            discountDetails: discount,
            originalPrice: originalPrice ? parseFloat(originalPrice) : null,
            specialPrice: specialPrice ? parseFloat(specialPrice) : null,
            productName: productName,
            storeName: storeName
        });
    };

    const currentUnitPrice = calculateUnitPrice(price, quantity, unitType);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 overflow-hidden">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">編輯記錄</h2>
                <div className="space-y-3">
                    {/* 產品名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">產品名稱</label>
                        <input
                            type="text"
                            value={productName}
                            onChange={(e) => setProductName(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 商店名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">商店名稱</label>
                        <div className="mt-1 flex">
                            <input
                                type="text"
                                value={storeName}
                                onChange={(e) => setStoreName(e.target.value)}
                                className="block flex-grow border border-gray-300 rounded-l-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                placeholder="點擊選擇商店或手動輸入"
                                readOnly
                            />
                            <button 
                                onClick={() => setIsStoreSelectorOpen(true)}
                                className="bg-indigo-600 text-white px-4 py-2 rounded-r-md hover:bg-indigo-700"
                            >
                                選擇
                            </button>
                        </div>
                    </div>
                    
                    {/* 原價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">原價 ($)</label>
                        <input
                            type="number"
                            value={originalPrice}
                            onChange={(e) => setOriginalPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 特價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">特價 ($)</label>
                        <input
                            type="number"
                            value={specialPrice}
                            onChange={(e) => setSpecialPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 總價輸入（實際支付價格） */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">總價 ($)</label>
                        <input
                            type="number"
                            value={price}
                            onChange={(e) => setPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    <div>
                        <label className="block text-sm font-medium text-gray-700">數量</label>
                        <input
                            type="number"
                            value={quantity}
                            onChange={(e) => setQuantity(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單位</label>
                        <select
                            value={unitType}
                            onChange={(e) => setUnitType(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        >
                            <option value="ml">ml (毫升)</option>
                            <option value="g">g (克)</option>
                            <option value="pcs">pcs (個/包/支/條)</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單價 (自動計算)</label>
                        <input
                            type="text"
                            value={currentUnitPrice === null ? 'N/A' : currentUnitPrice.toFixed(2)}
                            readOnly
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-gray-100"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">折扣詳情</label>
                        <input
                            type="text"
                            value={discount}
                            onChange={(e) => setDiscount(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                </div>
                <div className="mt-4 flex justify-between">
                    <button onClick={onClose} className="flex-1 mr-2 items-center bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 flex justify-center">
                        <X size={18} className="mr-1" />
                        取消
                    </button>
                    <button onClick={handleSave} className="flex-1 ml-2 items-center bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 flex justify-center">
                        <Save size={18} className="mr-1" />
                        保存
                    </button>
                </div>
            </div>
            
            {isStoreSelectorOpen && (
                <StoreSelector 
                    onSelect={(selectedStore) => {
                        setStoreName(selectedStore);
                        setIsStoreSelectorOpen(false);
                    }}
                    onClose={() => setIsStoreSelectorOpen(false)}
                    theme={{ primary: 'bg-indigo-600', hover: 'hover:bg-indigo-700', text: 'text-indigo-600' }}
                />
            )}
        </div>
    );
}

function DeleteConfirmation({ record, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p>您確定要刪除這條價格為 ${record.price.toFixed(2)} 的記錄嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}

function SuccessMessage({ message }) {
    if (!message) return null;

    return (
        <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center z-50">
            <CheckCircle size={20} className="mr-2" />
            <span>{message}</span>
        </div>
    );
}



// 新增批量刪除確認對話框組件
function BulkDeleteConfirmation({ count, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認批量刪除</h2>
                <p>您確定要刪除選中的 {count} 個產品項目嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}



export default AllRecordsPage;
</file>

<file path="App.css">
/* 應用基本樣式 */
.App {
  text-align: center;
  min-height: 100vh;
}

/* 自定義樣式可以在這裡添加 */
</file>

<file path="App.js">
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PaintBucket, DollarSign, Barcode, ClipboardCheck, X, Camera, Zap, FileText, RotateCcw, Database } from 'lucide-react';
import AllRecordsPage from './AllRecordsPage';
import StoreSelector from './StoreSelector';
import AIOcrCaptureModal from './components/AIOcrCaptureModal';
import { db } from './firebase-config.js'; // <-- 引入 Firebase
import { getAuth, signInAnonymously } from "firebase/auth";
import { doc, getDoc, setDoc, collection, query, where, getDocs, addDoc, orderBy, serverTimestamp } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import OcrQueuePage from './OcrQueuePage';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// ----------------------------------------------------------------------------
// 1. 核心設定與工具函數 (Core Setup & Utilities)
// ----------------------------------------------------------------------------

function djb2Hash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
}

// 以下函數已移至 src/components/AIOcrCaptureModal.js
// callGeminiApiWithRetry
// withExponentialBackoff


function generateProductId(barcode, productName, storeName) {
    if (barcode) {
        return djb2Hash(barcode).toString();
    } else {
        // Combine productName and storeName to create a unique ID for products without barcodes
        // This assumes productName + storeName is sufficiently unique for non-barcoded items
        return djb2Hash(`${productName}-${storeName}`).toString();
    }
}

// ----------------------------------------------------------------------------
// 2. UI 元件 (UI Components)
// ----------------------------------------------------------------------------

const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, theme }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間沒有足夠的變化來繪製趨勢圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1 text-gray-500"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                單價走勢
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke={theme.color === 'red' ? '#EF4444' : '#4F46E5'} strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === 0 ? '#10B981' : theme.primary.split('-')[1]} title={`$${record.displayPrice.toFixed(2)}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>最早: {new Date(minTimestamp).toLocaleDateString()}</span>
                <span>最新: {new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

function PriceHistoryDisplay({ historyRecords, theme }) {
    if (historyRecords.length === 0) {
        return <div className="text-center p-6 text-gray-500 bg-white rounded-xl shadow-md">尚無歷史價格紀錄。</div>;
    }

    const formattedRecords = historyRecords.map(record => ({
        ...record,
        timestamp: record.timestamp?.toDate ? record.timestamp.toDate() : new Date(record.timestamp),
        displayPrice: record.unitPrice !== undefined && record.unitPrice !== null ? record.unitPrice : record.price // Use unitPrice if available, else price
    }));

    return (
        <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${theme.border} mt-8`}>
            <h2 className={`text-xl font-semibold ${theme.text} mb-4`}>價格紀錄 ({formattedRecords.length} 筆)</h2>
            <div className="mb-6"><PriceTrendChart records={formattedRecords} theme={theme} /></div>
            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {formattedRecords.map((record, index) => (
                    <div key={index} className={`p-3 rounded-lg shadow-sm border border-gray-100 ${index === 0 ? theme.light : 'bg-white'}`}>
                        <div className="flex justify-between items-start font-bold">
                            {/* 顯示原價和特價信息 */}
                            {record.specialPrice ? (
                                <span className="text-[22px]">
                                    {record.originalPrice && (
                                        <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                    )}
                                    <span className="text-red-600 ml-2">${record.specialPrice.toFixed(2)}</span>
                                    <span className="text-gray-500 ml-2">@{formatUnitPrice(record.unitPrice)}</span>
                                </span>
                            ) : (
                                <span className="text-[22px] text-red-600">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</span>
                            )}
                            <span className="text-xs text-gray-500">{record.timestamp.toLocaleString()}</span>
                        </div>
                        <p className="text-sm text-gray-700 mt-1">商店: {record.storeName || '未標註'}</p>
                        {/* 顯示數量和單位資訊 */}
                        {record.quantity && record.unitType && <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType} (總價: ${(record.price || 0).toFixed(2)})</p>}
                        {record.discountDetails && <p className="text-xs text-indigo-600 italic">優惠: {record.discountDetails}</p>}
                        {index === 0 && <span className={`text-xs font-semibold px-2 py-0.5 rounded-full text-white ${theme.primary}`}>最新紀錄</span>}
                    </div>
                ))}
            </div>
        </div>
    );
}

const THEMES = {
    'Default (Indigo)': { primary: 'bg-indigo-600', light: 'bg-indigo-100', hover: 'hover:bg-indigo-700', border: 'border-indigo-600', text: 'text-indigo-600', color: 'indigo' },
    '海洋藍 (Ocean Blue)': { primary: 'bg-blue-600', light: 'bg-blue-100', hover: 'hover:bg-blue-700', border: 'border-blue-600', text: 'text-blue-600', color: 'blue' },
    '森林綠 (Forest Green)': { primary: 'bg-green-600', light: 'bg-green-100', hover: 'hover:bg-green-700', border: 'border-green-600', text: 'text-green-600', color: 'green' },
    '夕陽紅 (Sunset Red)': { primary: 'bg-red-600', light: 'bg-red-100', hover: 'hover:bg-red-700', border: 'border-red-600', text: 'text-red-600', color: 'red' },
    '活力橙 (Vibrant Orange)': { primary: 'bg-orange-600', light: 'bg-orange-100', hover: 'hover:bg-orange-700', border: 'border-orange-600', text: 'text-orange-600', color: 'orange' },
    '薰衣草紫 (Lavender)': { primary: 'bg-purple-600', light: 'bg-purple-100', hover: 'hover:bg-purple-700', border: 'border-purple-600', text: 'text-purple-600', color: 'purple' },
};
const DEFAULT_THEME_KEY = 'Default (Indigo)';

function ThemeSelector({ theme, saveTheme, onClose }) {
    const handleThemeChange = (themeKey) => { saveTheme(themeKey); };
    const handleReset = () => { saveTheme(DEFAULT_THEME_KEY); };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 transform transition-all">
                <h3 className={`text-xl font-bold ${theme.text} mb-4 border-b pb-2`}><PaintBucket className="inline-block w-5 h-5 mr-2" />介面配色選項</h3>
                <div className="grid grid-cols-2 gap-4 mb-6">
                    {Object.keys(THEMES).map((themeKey) => {
                        const themeData = THEMES[themeKey];
                        const isSelected = theme.color === themeData.color;
                        return (
                            <button key={themeKey} onClick={() => handleThemeChange(themeKey)}
                                className={`p-3 rounded-lg text-white font-medium shadow-md transition-all ${themeData.primary} ${themeData.hover} ${isSelected ? 'ring-4 ring-offset-2 ring-opacity-70 ring-gray-400' : ''}`}
                                style={{ transform: isSelected ? 'scale(1.05)' : 'scale(1)' }}>
                                {themeKey}
                            </button>
                        );
                    })}
                </div>
                <div className="flex justify-between items-center pt-4 border-t">
                    <button onClick={handleReset} className="flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                        <RotateCcw className="w-4 h-4 mr-1" />清除還原 (預設)
                    </button>
                    <button onClick={onClose} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg ${theme.primary} ${theme.hover} transition-all`}>關閉</button>
                </div>
            </div>
        </div>
    );
}

// AIOcrCaptureModal 組件已移至獨立檔案 src/components/AIOcrCaptureModal.js


// ----------------------------------------------------------------------------
// 3. Firebase 身份驗證與主題設定 (Firebase Auth & Theming)
// ----------------------------------------------------------------------------

function useFirebaseAuthentication() {
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        const auth = getAuth();
        signInAnonymously(auth)
            .then((userCredential) => {
                setUserId(userCredential.user.uid);
                setIsAuthReady(true);
            })
            .catch((error) => {
                console.error("Firebase 匿名登入失敗:", error);
            });
    }, []);

    const [currentTheme, setCurrentTheme] = useState(() => {
        const savedKey = localStorage.getItem('appTheme') || DEFAULT_THEME_KEY;
        return THEMES[savedKey] || THEMES[DEFAULT_THEME_KEY];
    });

    const saveUserTheme = useCallback((themeKey) => {
        localStorage.setItem('appTheme', themeKey);
        setCurrentTheme(THEMES[themeKey] || THEMES[DEFAULT_THEME_KEY]);
    }, []);

    return { userId, isAuthReady, currentTheme, saveUserTheme };
}

// ----------------------------------------------------------------------------
// 4. 結果提示框 (Result Toast)
// ----------------------------------------------------------------------------
function SaveResultToast({ result, onClose }) {
    useEffect(() => {
        let timer;
        if (result) {
            timer = setTimeout(onClose, 5000);
        }
        return () => clearTimeout(timer);
    }, [result, onClose]);

    if (!result) {
        return null;
    }

    const { status, message, productName } = result;

    const theme = {
        success: { bg: 'bg-green-500', text: 'text-white', icon: <ClipboardCheck className="w-6 h-6 mr-3" /> },
        warning: { bg: 'bg-yellow-400', text: 'text-gray-800', icon: <DollarSign className="w-6 h-6 mr-3" /> },
        error: { bg: 'bg-red-500', text: 'text-white', icon: <X className="w-6 h-6 mr-3" /> },
    };

    const currentTheme = theme[status];

    return (
        <div className={`fixed top-20 left-1/2 -translate-x-1/2 max-w-md w-full p-4 rounded-xl shadow-2xl z-[100] ${currentTheme.bg} ${currentTheme.text} transition-all duration-300 ease-in-out`}>
            <div className="flex items-center">
                {currentTheme.icon}
                <div className="flex-grow">
                    <p className="font-bold text-lg">{productName}</p>
                    <p className="text-sm">{message}</p>
                    <p className="text-sm font-semibold mt-1">
                        資料儲存: {status === 'error' ? '失敗' : '成功'} | 
                        比價結果: {status === 'success' ? '是最低價' : (status === 'warning' ? '非最低價' : 'N/A')}
                    </p>
                </div>
                <button onClick={onClose} className="ml-4 p-1 rounded-full hover:bg-white/20"><X className="w-5 h-5" /></button>
            </div>
        </div>
    );
}


// ----------------------------------------------------------------------------
// 5. 主應用程式元件 (App Component)
// ----------------------------------------------------------------------------

function App() {
    const { userId, isAuthReady, currentTheme, saveUserTheme } = useFirebaseAuthentication();
    const streamRef = useRef(null);
    
    const [saveResultToast, setSaveResultToast] = useState(null);

    // UI 狀態
    const [barcode, setBarcode] = useState('');
    const [productName, setProductName] = useState('');
    const [currentPrice, setCurrentPrice] = useState('');
    const [quantity, setQuantity] = useState('');
    const [unitType, setUnitType] = useState('pcs'); // 'g', 'ml', 'pcs'
    const [unitPrice, setUnitPrice] = useState(null);
    const [discountDetails, setDiscountDetails] = useState('');
    const [storeName, setStoreName] = useState('');
    const [productHistory, setProductHistory] = useState([]);
    const [comparisonResult, setComparisonResult] = useState({ message: '等待比價數據...' });
    const [statusMessage, setStatusMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [lookupStatus, setLookupStatus] = useState('ready');
    
    // Modal and Page 狀態
    const [isThemeModalOpen, setIsThemeModalOpen] = useState(false);
    const [isCaptureModalOpen, setIsCaptureModalOpen] = useState(false);
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);
    const [isOcrQueueStoreSelectorOpen, setIsOcrQueueStoreSelectorOpen] = useState(false); // 新增狀態
    const [editingOcrCard, setEditingOcrCard] = useState(null); // 新增狀態
    const [currentPage, setCurrentPage] = useState('main'); // 'main', 'allRecords', 'ocrQueue'
    const [ocrResult, setOcrResult] = useState(null);
    const [capturedImage, setCapturedImage] = useState(null); // 新增的狀態
    
    // 新增狀態：待辨識序列
    const [pendingOcrCards, setPendingOcrCards] = useState(() => {
        // 從 localStorage 恢復待辨識卡片
        const savedCards = localStorage.getItem('pendingOcrCards');
        return savedCards ? JSON.parse(savedCards) : [];
    });
    
    // 添加 useEffect 來保存 pendingOcrCards 到 localStorage
    useEffect(() => {
        localStorage.setItem('pendingOcrCards', JSON.stringify(pendingOcrCards));
    }, [pendingOcrCards]);
    
    useEffect(() => {
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const price = parseFloat(finalPrice);
        const qty = parseFloat(quantity);

        if (!isNaN(price) && !isNaN(qty) && qty > 0) {
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(price, qty, unitType);
            setUnitPrice(calculatedUnitPrice);
        } else {
            setUnitPrice(null);
        }
    }, [currentPrice, quantity, unitType, ocrResult]);
    
    // 提前定義所有會被使用的函數，避免 no-use-before-define 警告
    const clearForm = useCallback(() => {
        setBarcode('');
        setProductName('');
        setCurrentPrice('');
        setQuantity('');
        setUnitType('pcs'); // Reset to default unit type
        setUnitPrice(null);
        setDiscountDetails('');
        setStoreName('');
        setProductHistory([]);
        setComparisonResult({ message: '等待比價數據...' });
        setOcrResult(null);
        setLookupStatus('ready');
        setCapturedImage(null); // 清除擷取的圖片
    }, []);

    const stopCameraStream = useCallback(() => {
        console.log("stopCameraStream: Attempting to stop camera.");
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
            console.log("stopCameraStream: Camera stream stopped.");
        }
    }, []);
    
    const startCameraStream = async () => {
        console.log("startCameraStream: Attempting to start camera.");
        if (streamRef.current) {
            return streamRef.current;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
            streamRef.current = stream;
            console.log("startCameraStream: Camera started successfully.");
            return stream;
        } catch (err) {
            console.error("無法存取攝影機:", err);
            setStatusMessage(`無法存取攝影機: ${err.name}`);
            return null;
        }
    };

    const lookupProduct = useCallback(async (barcodeData, currentProductName, currentStoreName) => {
        // 如果 Firebase 尚未初始化，則不執行查詢
        if (!isAuthReady || !userId) {
            return;
        }
        
        const numericalID = generateProductId(barcodeData, currentProductName, currentStoreName);

        // Adjust early exit condition:
        // If no barcode and no product name, or if barcode is too short and no product name,
        // then we can't look up a product.
        if (!numericalID) { // If numericalID couldn't be generated, then we can't look up a product.
            setProductName('');
            setLookupStatus('ready');
            setProductHistory([]);
            return;
        }
        
        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);

            if (productSnap.exists()) {
                setProductName(productSnap.data().productName);
                setLookupStatus('found');
            } else {
                setLookupStatus('new');
            }

            const recordsQueryString = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID), // numericalID is already a string
                orderBy("timestamp", "desc")
            );
            const recordsSnapString = await getDocs(recordsQueryString);
            let records = recordsSnapString.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Attempt to query for numericalID as a number, if it's a valid number string
            const numericalIDAsNumber = parseInt(numericalID, 10);
            if (!isNaN(numericalIDAsNumber) && numericalIDAsNumber.toString() === numericalID) { // Check if it's a pure number string
                const recordsQueryNumber = query(
                    collection(db, "priceRecords"),
                    where("numericalID", "==", numericalIDAsNumber),
                    orderBy("timestamp", "desc")
                );
                const recordsSnapNumber = await getDocs(recordsQueryNumber);
                const recordsNumber = recordsSnapNumber.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Merge and deduplicate records
                const mergedRecordsMap = new Map();
                records.forEach(record => mergedRecordsMap.set(record.id, record));
                recordsNumber.forEach(record => mergedRecordsMap.set(record.id, record));
                records = Array.from(mergedRecordsMap.values()).sort((a, b) => (b.timestamp?.toDate ? b.timestamp.toDate().getTime() : 0) - (a.timestamp?.toDate ? a.timestamp.toDate().getTime() : 0));
            }
            setProductHistory(records);

        } catch (error) {
            console.error("查詢產品失敗 (Firestore):", error);
            setStatusMessage("查詢產品資料時發生錯誤。");
            setLookupStatus('ready');
            setProductHistory([]);
        }
    }, [isAuthReady, userId, setProductName, setLookupStatus, setProductHistory, setStatusMessage]);

    // 新增函數：處理 OCR 隊列的商店選擇
    const handleOcrQueueStoreSelect = useCallback((card) => {
        setEditingOcrCard(card);
        setIsOcrQueueStoreSelectorOpen(true);
    }, [setEditingOcrCard, setIsOcrQueueStoreSelectorOpen]);

    // 新增函數：處理 OCR 隊列的商店選擇確認
    const handleOcrQueueStoreSelectConfirm = useCallback((selectedStore) => {
        if (editingOcrCard) {
            // 更新待辨識卡片的商店名稱
            const updatedCards = pendingOcrCards.map(card => 
                card.id === editingOcrCard.id ? { ...card, storeName: selectedStore } : card
            );
            setPendingOcrCards(updatedCards);
        }
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [editingOcrCard, pendingOcrCards, setPendingOcrCards, setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 新增函數：處理 OCR 隊列的商店選擇器關閉
    const handleOcrQueueStoreSelectorClose = useCallback(() => {
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 正確地提前定義 performSaveAndCompare 函數（必須在 saveAndComparePrice 之前定義）
    const performSaveAndCompare = useCallback(async (selectedStore) => {
        const finalStoreName = selectedStore || storeName;
        const numericalID = generateProductId(barcode, productName, finalStoreName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const priceValue = parseFloat(finalPrice);

        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, quantity, unitType);

        if (!userId || !productName || isNaN(priceValue) || isNaN(parseFloat(quantity)) || parseFloat(quantity) <= 0 || calculatedUnitPrice === null) {
            showUserFriendlyError("請確保已輸入條碼、產品名稱、有效總價、數量和單位！", "資料驗證");
            setIsLoading(false);
            return;
        }
        if (!finalStoreName.trim()) {
            setIsStoreSelectorOpen(true);
            setIsLoading(false);
            return;
        }

        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);
            
            // 準備產品文檔數據
            const productData = {
                numericalID,
                barcodeData: barcode,
                productName,
                createdAt: productSnap.exists() ? productSnap.data().createdAt : serverTimestamp(),
                lastUpdatedBy: userId,
            };

            // 準備價格記錄數據
            const priceRecord = {
                numericalID,
                productName,
                storeName: finalStoreName,
                price: priceValue, // 總價
                quantity: parseFloat(quantity),
                unitType: unitType,
                unitPrice: calculatedUnitPrice, // 單價
                discountDetails: discountDetails || '',
                timestamp: serverTimestamp(),
                recordedBy: userId,
                // 保存原價和特價信息（如果有的話）
                originalPrice: ocrResult?.originalPrice ? parseFloat(ocrResult.originalPrice) : null,
                specialPrice: ocrResult?.specialPrice ? parseFloat(ocrResult.specialPrice) : null
            };

            // 儲存價格記錄
            const priceRecordDocRef = await addDoc(collection(db, "priceRecords"), priceRecord);
            
            // 檢查是否需要更新產品文檔中的最佳單價
            let isBestPrice = false;
            if (productSnap.exists()) {
                const existingProductData = productSnap.data();
                // 如果產品文檔中沒有 bestUnitPrice 或新價格更低，則更新
                if (existingProductData.bestUnitPrice === undefined || calculatedUnitPrice < existingProductData.bestUnitPrice) {
                    productData.bestUnitPrice = calculatedUnitPrice;
                    productData.bestPriceRecordRef = priceRecordDocRef.path; // 儲存指向最佳價格記錄的引用路徑
                    isBestPrice = true;
                } else {
                    // 保持現有的最佳價格信息
                    productData.bestUnitPrice = existingProductData.bestUnitPrice;
                    productData.bestPriceRecordRef = existingProductData.bestPriceRecordRef;
                }
            } else {
                // 新產品，當前價格就是最佳價格
                productData.bestUnitPrice = calculatedUnitPrice;
                productData.bestPriceRecordRef = priceRecordDocRef.path;
                isBestPrice = true;
            }
            
            // 儲存或更新產品文檔
            await setDoc(productRef, productData);

            // 準備比價結果
            let toastStatus, toastMessage, isBest, bestPrice, bestStore;

            if (isBestPrice) {
                isBest = true;
                bestPrice = calculatedUnitPrice;
                bestStore = finalStoreName;
                toastStatus = 'success';
                toastMessage = '恭喜！這是目前紀錄中的最低單價！';
            } else {
                isBest = false;
                bestPrice = productData.bestUnitPrice;
                
                // 從 Firestore 獲取最佳價格記錄的商店名稱
                try {
                    const bestPriceRecordDoc = await getDoc(doc(db, productData.bestPriceRecordRef));
                    if (bestPriceRecordDoc.exists()) {
                        bestStore = bestPriceRecordDoc.data().storeName;
                    } else {
                        bestStore = '未知商店';
                    }
                } catch (error) {
                    console.error("獲取最佳價格記錄失敗:", error);
                    bestStore = '未知商店';
                }
                
                toastStatus = 'warning';
                toastMessage = `非最低單價。歷史最低單價為 $${formatUnitPrice(productData.bestUnitPrice)} (${bestStore})`;
            }

            setComparisonResult({ isBest, bestPrice, bestStore, message: toastMessage });
            // 儲存成功時顯示提示訊息
            setSaveResultToast({ status: toastStatus, message: toastMessage, productName: productName });
            
            lookupProduct(barcode, productName, finalStoreName);

        } catch (error) {
            console.error("儲存或比價失敗 (Firestore):", error);
            const userMessage = handleFirestoreSaveError(error, "儲存價格資訊");
            showUserFriendlyError(userMessage);
        } finally {
            setIsLoading(false);
        }
    }, [userId, barcode, productName, currentPrice, discountDetails, storeName, lookupProduct, quantity, unitType, setSaveResultToast, setComparisonResult, setIsLoading, setIsStoreSelectorOpen, ocrResult]);

    // 正確地提前定義 saveAndComparePrice 函數
    const saveAndComparePrice = useCallback(async (selectedStore) => {
        // 確保 Firebase 已初始化，如果尚未完成初始化則強制初始化
        if (!isAuthReady) {
            // 顯示加載訊息並等待初始化完成
            setIsLoading(true);
            // 等待 Firebase 初始化完成
            const checkAuth = () => {
                if (isAuthReady) {
                    // 初始化完成後繼續執行
                    performSaveAndCompare(selectedStore);
                } else {
                    // 繼續等待
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
            return;
        }
        
        // 如果 Firebase 已準備好，直接執行保存操作
        performSaveAndCompare(selectedStore);
    }, [isAuthReady, performSaveAndCompare]);
    
    const handleAiCaptureSuccess = useCallback((result) => {
        const { scannedBarcode, productName, extractedPrice, storeName, discountDetails, quantity, unitType, specialPrice, capturedImage: receivedImage } = result;
        setOcrResult(result);
        
        // 設置捕獲的圖像
        if (receivedImage) {
            setCapturedImage(receivedImage);
        }
        
        const newBarcode = scannedBarcode || '';
        setBarcode(newBarcode);

        if (!newBarcode) {
            setStatusMessage("AI 未能識別條碼，請手動輸入或確保條碼清晰！");
        } else {
            setStatusMessage(`AI 分析成功！`);
        }

        setProductName(productName || '');
        
        // 優先使用特價，如果有的話
        const finalPrice = specialPrice && !isNaN(parseFloat(specialPrice)) ? specialPrice : extractedPrice;
        setCurrentPrice(finalPrice || '');
        
        setStoreName(storeName || '');
        setDiscountDetails(discountDetails || '');

        setQuantity(quantity || '');
        setUnitType(unitType || 'pcs');

        if (productName && newBarcode) {
            setLookupStatus('found');
        } else {
            setLookupStatus('new');
        }
    }, [setBarcode, setProductName, setCurrentPrice, setStoreName, setDiscountDetails, setOcrResult, setStatusMessage, setLookupStatus, setQuantity, setUnitType, setCapturedImage]);

    // 新增函數：將辨識結果加入待確認序列
    const handleQueueNextCapture = useCallback((result) => {
        // 將結果加入待確認的辨識卡片中
        setPendingOcrCards(prev => [...prev, { ...result, id: Date.now() }]);
        setStatusMessage(`已將辨識結果加入待確認序列！`);
    }, []);

    // 新增函數：移除待確認的辨識卡片
    const handleRemovePendingOcrCard = useCallback((cardId) => {
        setPendingOcrCards(prev => prev.filter(item => item.id !== cardId));
    }, []);

    const handleStoreSelect = useCallback((selectedStore) => {
        setStoreName(selectedStore);
        setIsStoreSelectorOpen(false);
        // 不再自動觸發保存操作，與其他頁面保持一致
    }, [setStoreName, setIsStoreSelectorOpen]);

    const handleCaptureModalClose = useCallback(() => {
        setIsCaptureModalOpen(false);
        stopCameraStream();
    }, [stopCameraStream]);

    const handleNewScanClick = async () => {
        clearForm();
        const stream = await startCameraStream();
        if (stream) {
            setIsCaptureModalOpen(true);
        } else {
            // 如果無法啟動相機，顯示錯誤訊息
            setStatusMessage("無法啟動相機，請檢查權限設置");
        }
    };

    const themePrimary = currentTheme.primary;
    const themeText = currentTheme.text;
    const themeLight = currentTheme.light;
    const themeBorder = currentTheme.border;
    const themeHover = currentTheme.hover; // 添加這一行來定義 themeHover

    const productNamePlaceholder = useMemo(() => {
        switch(lookupStatus) {
            case 'searching': return '正在查詢產品資料...';
            case 'found': return '產品名稱已自動載入';
            case 'new': return '產品不存在，請手動輸入名稱';
            default: return '請先輸入條碼或掃描條碼';
        }
    }, [lookupStatus]);

    if (!isAuthReady) {
        return <div className="flex items-center justify-center min-h-screen bg-gray-50"><p className="text-xl text-gray-700">正在連線至雲端服務...</p></div>;
    }

    if (currentPage === 'allRecords') {
        return <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />;
    }

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${themeLight}`}>
            <SaveResultToast result={saveResultToast} onClose={() => setSaveResultToast(null)} />
            
            {/* 根據 currentPage 狀態渲染不同頁面 */}
            {currentPage === 'main' && (
                <div className="max-w-xl mx-auto">
                    <header className="flex justify-between items-center mb-6 border-b pb-4">
                        <h1 className={`text-3xl font-extrabold ${themeText} flex items-center`}><Barcode className="w-8 h-8 mr-2" />條碼比價神器 (Cloud)</h1>
                        <div className="flex items-center space-x-3">
                            {/* 新增待辨識的按鈕 */}
                            <button 
                                onClick={() => setCurrentPage('ocrQueue')}
                                className={`relative p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`}
                                title={`待辨識 (${pendingOcrCards.length})`}
                            >
                                <Zap className="w-5 h-5" />
                                {pendingOcrCards.length > 0 && (
                                    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                                        {pendingOcrCards.length}
                                    </span>
                                )}
                            </button>
                            <button onClick={() => setCurrentPage('allRecords')} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="查看所有記錄"><Database className="w-5 h-5" /></button>
                            <button onClick={() => setIsThemeModalOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定介面主題"><PaintBucket className="w-5 h-5" /></button>
                            <p className="text-sm text-gray-500 hidden sm:block">User: {userId.slice(0, 8)}...</p>
                        </div>
                    </header>

                    {statusMessage && <div className="bg-blue-500 text-white p-3 rounded-lg shadow-md mb-4 text-center font-medium">{statusMessage}</div>}

                    {ocrResult && (
                        <div className="bg-yellow-100 border border-yellow-300 rounded-lg p-4 mb-6">
                            <h3 className="text-lg font-semibold text-yellow-800 mb-2">AI 辨識結果 (開發者確認區)</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm">
                                <div>條碼:</div><div>{ocrResult.scannedBarcode || 'N/A'}</div>
                                <div>品名:</div><div>{ocrResult.productName || 'N/A'}</div>
                                {/* 顯示原價和特價信息 */}
                                {ocrResult.specialPrice ? (
                                    <>
                                        {ocrResult.originalPrice && (
                                            <>
                                                <div>原價:</div><div className="line-through text-red-500">${ocrResult.originalPrice.toFixed(2)}</div>
                                            </>
                                        )}
                                        <div>特價:</div><div className="text-green-600 font-bold">${ocrResult.specialPrice.toFixed(2)}</div>
                                    </>
                                ) : (
                                    <>
                                        <div>價格:</div><div>${ocrResult.extractedPrice || 'N/A'}</div>
                                    </>
                                )}
                                <div>數量:</div><div>{ocrResult.quantity || 'N/A'}</div>
                                <div>商店:</div><div>{ocrResult.storeName || 'N/A'}</div>
                                <div>折扣:</div><div>{ocrResult.discountDetails || '無'}</div>
                            </div>
                            <button onClick={() => setOcrResult(null)} className="mt-3 px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 text-sm">關閉</button>
                        </div>
                    )}

                    <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${themeBorder}`}>
                        <h2 className={`text-xl font-semibold ${themeText} mb-6 flex items-center`}><Zap className="w-5 h-5 mr-2" />步驟 1: AI 視覺自動擷取</h2>
                        <button className={`w-full p-4 rounded-lg text-white font-bold text-lg shadow-xl transition-all ${themePrimary} hover:opacity-80 flex items-center justify-center`} onClick={handleNewScanClick}>
                            <Camera className="inline-block w-6 h-6 mr-3" />開啟鏡頭擷取
                        </button>
                        <hr className="my-6 border-gray-200" />
                        <h2 className={`text-xl font-semibold text-gray-700 mb-4 flex items-center`}><FileText className="w-5 h-5 mr-2" />步驟 2: 檢查或手動輸入</h2>
                        
                        {/* 新增的擷取畫面顯示區塊 */}
                        {capturedImage && (
                            <div className="mb-6">
                                <label className="block text-gray-700 font-medium mb-2">擷取畫面 (請確認辨識資料是否正確)</label>
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                    <div className="relative w-full aspect-video">
                                        {capturedImage.startsWith('data:image') ? (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        ) : (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        )}
                                    </div>
                                </div>
                                <p className="text-sm text-gray-500 mt-2">此圖片將持續顯示直到進行下一次辨識或退出應用程式</p>
                            </div>
                        )}
                        
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">條碼數據</label>
                            <input type="text" value={barcode} onChange={(e) => setBarcode(e.target.value)} placeholder="AI 自動填入，或手動輸入" className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" />
                        </div>
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">產品名稱</label>
                            <input type="text" value={productName} onChange={(e) => setProductName(e.target.value)} placeholder={productNamePlaceholder} className={`w-full p-3 border border-gray-300 rounded-lg ${lookupStatus === 'found' ? 'bg-green-50' : lookupStatus === 'new' ? 'bg-yellow-50' : ''}`} readOnly={lookupStatus === 'found' && !ocrResult} />
                            <p className="text-sm text-gray-500 mt-1">ID (Hash): {barcode ? djb2Hash(barcode) : 'N/A'}</p>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">總價 ($) <span className="text-red-500">*</span></label>
                                <input type="number" value={currentPrice} onChange={(e) => setCurrentPrice(e.target.value)} placeholder="AI 擷取" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">商店名稱</label>
                                <input 
                                    type="text" 
                                    value={storeName} 
                                    onFocus={() => setIsStoreSelectorOpen(true)}
                                    readOnly
                                    placeholder="點擊選擇商店"
                                    className="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 cursor-pointer"
                                />
                            </div>
                        </div>
                        <div className="grid grid-cols-3 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">數量 <span className="text-red-500">*</span></label>
                                <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="例如: 500" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單位 <span className="text-red-500">*</span></label>
                                <select value={unitType} onChange={(e) => setUnitType(e.target.value)} className="w-full p-3 border border-gray-300 rounded-lg">
                                    <option value="ml">ml (毫升)</option>
                                    <option value="g">g (克)</option>
                                    <option value="pcs">pcs (個/包/支/條)</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單價 (每100g/ml)</label>
                                <input type="text" value={formatUnitPrice(unitPrice)} readOnly className="w-full p-3 border border-gray-300 rounded-lg bg-gray-100" />
                            </div>
                        </div>
                        <div className="mb-6">
                            <label className="block text-gray-700 font-medium mb-1">優惠細節</label>
                            <input type="text" value={discountDetails} onChange={(e) => setDiscountDetails(e.target.value)} placeholder="例如: 買二送一" className="w-full p-3 border border-gray-300 rounded-lg" />
                        </div>
                        <button className={`w-full mt-4 p-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-emerald-500 hover:bg-emerald-600`} onClick={() => saveAndComparePrice()} disabled={isLoading}>
                            <ClipboardCheck className="inline-block w-5 h-5 mr-2" />{isLoading ? '處理中...' : '步驟 3: 儲存紀錄並比價'}
                        </button>
                    </div>

                    <div className="mt-8">
                        <h2 className={`text-xl font-semibold ${themeText} mb-4 flex items-center`}>
                            <DollarSign className="w-5 h-5 mr-2" />
                            比價結果 {productName && <span className="ml-2 font-normal text-gray-500">- {productName}</span>}
                        </h2>
                        <div className={`p-6 rounded-xl shadow-xl border-2 ${comparisonResult.isBest ? 'border-green-500 bg-green-50' : 'border-yellow-500 bg-yellow-50'}`}>
                            <p className={`text-lg font-bold ${comparisonResult.isBest ? 'text-green-700' : 'text-yellow-700'}`}>{comparisonResult.message}</p>
                            {comparisonResult.bestPrice && <p className="text-sm text-gray-600 mt-2">歷史最低標價: ${comparisonResult.bestPrice}</p>}
                            <p className="text-xs text-gray-500 mt-2">**附註:** 您的紀錄已安全儲存在雲端。</p>
                        </div>
                    </div>

                    {(lookupStatus === 'found' || lookupStatus === 'new') && <PriceHistoryDisplay historyRecords={productHistory} theme={currentTheme} />}
                    
                    {/* 在主介面添加一個快捷處理待辨識卡片的按鈕 */}
                    {pendingOcrCards.length > 0 && (
                        <div className="mt-4 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold text-yellow-800">有待辨識的項目</h3>
                                    <p className="text-sm text-yellow-600">您有 {pendingOcrCards.length} 個待辨識的項目等待處理</p>
                                </div>
                                <button 
                                    onClick={() => {
                                        // 處理第一個待辨識的卡片
                                        const firstCard = pendingOcrCards[0];
                                        
                                        // 設置表單數據
                                        setOcrResult(firstCard);
                                        setCapturedImage(firstCard.capturedImage);
                                        setBarcode(firstCard.scannedBarcode || '');
                                        setProductName(firstCard.productName || '');
                                        setCurrentPrice(firstCard.extractedPrice || '');
                                        setStoreName(firstCard.storeName || '');
                                        setDiscountDetails(firstCard.discountDetails || '');
                                        setQuantity(firstCard.quantity || '');
                                        setUnitType(firstCard.unitType || 'pcs');
                                        
                                        // 計算單價
                                        const priceValue = parseFloat(firstCard.extractedPrice);
                                        const qty = parseFloat(firstCard.quantity);
                                        if (!isNaN(priceValue) && !isNaN(qty) && qty > 0) {
                                            const calculatedUnitPrice = calculateUnitPrice(priceValue, qty, firstCard.unitType);
                                            setUnitPrice(calculatedUnitPrice);
                                        }
                                        
                                        // 更新狀態
                                        if (firstCard.productName && firstCard.scannedBarcode) {
                                            setLookupStatus('found');
                                        } else {
                                            setLookupStatus('new');
                                        }
                                        
                                        // 從待辨識序列中移除該卡片
                                        setPendingOcrCards(prev => prev.filter(item => item.id !== firstCard.id));
                                        
                                        // 顯示提示訊息
                                        setStatusMessage(`已載入待辨識項目: ${firstCard.productName || '未命名產品'}`);
                                    }}
                                    className={`px-4 py-2 rounded-lg text-white font-medium ${themePrimary} ${themeHover}`}
                                >
                                    處理第一個待辨識項目
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            )}
            
            {currentPage === 'allRecords' && (
                <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />
            )}
            
            {currentPage === 'ocrQueue' && (
                <OcrQueuePage 
                    theme={currentTheme} 
                    onBack={() => setCurrentPage('main')} 
                    pendingOcrCards={pendingOcrCards}
                    onRemoveCard={handleRemovePendingOcrCard}
                    onStoreSelect={setPendingOcrCards}
                    isStoreSelectorOpen={isOcrQueueStoreSelectorOpen}
                    onStoreSelectCallback={handleOcrQueueStoreSelect}
                    onCloseStoreSelector={handleOcrQueueStoreSelectorClose}
                />
            )}

            {isThemeModalOpen && <ThemeSelector theme={currentTheme} saveTheme={saveUserTheme} onClose={() => setIsThemeModalOpen(false)} />}
            {isCaptureModalOpen && <AIOcrCaptureModal theme={currentTheme} onAnalysisSuccess={handleAiCaptureSuccess} onClose={handleCaptureModalClose} stream={streamRef.current} onQueueNextCapture={handleQueueNextCapture} />}
            {isStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleStoreSelect} onClose={() => setIsStoreSelectorOpen(false)} />}
            {isOcrQueueStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleOcrQueueStoreSelectConfirm} onClose={handleOcrQueueStoreSelectorClose} />}
        </div>
    );
}

export default App;
</file>

<file path="components/AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="firebase-config.js">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAtaZL06wkWJHhOJdne2Z_h9fMIEYldgjM",
  authDomain: "barcodepricing-00898.firebaseapp.com",
  projectId: "barcodepricing-00898",
  storageBucket: "barcodepricing-00898.firebasestorage.app",
  messagingSenderId: "286146042453",
  appId: "1:286146042453:web:14a20a662dcf3d06f592dc",
  measurementId: "G-6GMRVJ4S52"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

export { db };
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="OcrQueuePage.js">
import React, { useState, useEffect, useCallback } from 'react';
import { ArrowLeft, Trash2, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { db } from './firebase-config.js';
import { doc, setDoc, addDoc, collection, serverTimestamp, getDoc, query, where, getDocs } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 計算 localStorage 使用量的函數
function getLocalStorageUsage() {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += (localStorage[key].length + key.length) * 2; // 每個字符佔用 2 bytes
    }
  }
  const used = (total / 1024).toFixed(2); // 轉換為 KB
  const quota = 5120; // 大多数瀏覽器的 localStorage 限制約為 5MB
  const percentage = ((used / quota) * 100).toFixed(2);
  
  return {
    used: used,
    quota: quota,
    percentage: percentage
  };
}

// 刪除確認對話框組件
function DeleteConfirmation({ card, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p className="mb-4">您確定要刪除此待辨識項目嗎？</p>
                <p className="mb-4 font-semibold text-gray-800">{card.productName || '未命名產品'}</p>
                <div className="flex justify-end space-x-3">
                    <button 
                        onClick={onClose}
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                    >
                        取消
                    </button>
                    <button 
                        onClick={onConfirm}
                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                    >
                        確認刪除
                    </button>
                </div>
            </div>
        </div>
    );
}

function OcrQueuePage({ theme, onBack, pendingOcrCards, onRemoveCard, onStoreSelect, 
    isStoreSelectorOpen, onStoreSelectCallback, onCloseStoreSelector }) {
    const [queueStats, setQueueStats] = useState({
        total: 0,
        oldest: null,
        newest: null
    });
    
    // 新增狀態：localStorage 使用量
    const [localStorageUsage, setLocalStorageUsage] = useState({
        used: 0,
        quota: 5120,
        percentage: 0
    });
    
    // 新增狀態：刪除確認對話框
    const [deleteConfirmation, setDeleteConfirmation] = useState(null);
    
    // 新增狀態：正在編輯的卡片
    // 移除 editingCard 狀態，因為現在由父組件控制
    // const [editingCard, setEditingCard] = useState(null);
    
    // 新增狀態：比價結果
    const [priceComparisonResults, setPriceComparisonResults] = useState({});

    useEffect(() => {
        if (pendingOcrCards.length > 0) {
            const timestamps = pendingOcrCards.map(card => card.id);
            setQueueStats({
                total: pendingOcrCards.length,
                oldest: Math.min(...timestamps),
                newest: Math.max(...timestamps)
            });
        } else {
            setQueueStats({
                total: 0,
                oldest: null,
                newest: null
            });
        }
        
        // 更新 localStorage 使用量
        setLocalStorageUsage(getLocalStorageUsage());
    }, [pendingOcrCards]);

    const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleString('zh-TW');
    };

    const calculateDuration = (timestamp) => {
        const now = Date.now();
        const diffMs = now - timestamp;
        const diffSecs = Math.floor(diffMs / 1000);
        const diffMins = Math.floor(diffSecs / 60);
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            return `${diffHours}小時前`;
        } else if (diffMins > 0) {
            return `${diffMins}分鐘前`;
        } else {
            return `${diffSecs}秒前`;
        }
    };

    // 處理刪除操作
    const handleDeleteClick = (card) => {
        setDeleteConfirmation(card);
    };

    // 確認刪除
    const confirmDelete = () => {
        if (deleteConfirmation) {
            onRemoveCard(deleteConfirmation.id);
            setDeleteConfirmation(null);
            // 刪除後更新 localStorage 使用量
            setTimeout(() => {
                setLocalStorageUsage(getLocalStorageUsage());
            }, 100);
        }
    };

    // 取消刪除
    const cancelDelete = () => {
        setDeleteConfirmation(null);
    };

    // 處理儲存操作 - 檢查商店名稱
    const handleSaveClick = async (card) => {
        // 檢查商店名稱是否為空白
        if (!card.storeName || card.storeName.trim() === '') {
            // 如果商店名稱為空白，顯示商店選擇器
            onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
        } else {
            // 如果商店名稱不為空白，直接儲存（不再彈出確認對話框）
            try {
                // 儲存到 Firebase
                await saveOcrCardToFirebase(card);
                
                // 從待辨識序列中移除
                onRemoveCard(card.id);
                
                // 儲存後更新 localStorage 使用量
                setTimeout(() => {
                    setLocalStorageUsage(getLocalStorageUsage());
                }, 100);
                
                // 儲存成功時不顯示任何訊息
            } catch (error) {
                console.error("儲存失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "儲存待辨識卡片");
                showUserFriendlyError(userMessage);
            }
        }
    };

    // 處理卡片欄位變更
    const handleCardChange = (cardId, field, value) => {
        const updatedCards = pendingOcrCards.map(card => 
            card.id === cardId ? { ...card, [field]: value } : card
        );
        onStoreSelect(updatedCards);
        
        // 當價格相關欄位變更時，重新計算比價結果
        if (field === 'extractedPrice' || field === 'specialPrice' || field === 'originalPrice' || field === 'quantity' || field === 'unitType') {
            // 延遲一點時間再重新計算，確保狀態已更新
            setTimeout(() => {
                const fetchPriceComparisonResults = async () => {
                    const results = {};
                    for (const card of updatedCards) {
                        const result = await checkIfBestPrice(card, updatedCards);
                        results[card.id] = result;
                    }
                    setPriceComparisonResults(results);
                };
                
                fetchPriceComparisonResults();
            }, 0);
        }
    };

    // 處理商店欄位點擊
    const handleStoreClick = (card) => {
        onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
    };

    // 儲存 OCR 卡片到 Firebase
    const saveOcrCardToFirebase = async (card) => {
        // 生成產品 ID
        const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
        const priceValue = parseFloat(finalPrice);
        
        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
        
        // 儲存產品資訊
        const productRef = doc(db, "products", numericalID.toString());
        const productSnap = await getDoc(productRef);
        if (!productSnap.exists()) {
            await setDoc(productRef, {
                numericalID,
                barcodeData: card.scannedBarcode,
                productName: card.productName,
                createdAt: serverTimestamp(),
                lastUpdatedBy: "ocr-queue", // 標記為來自 OCR 隊列
            });
        }
        
        // 儲存價格記錄
        const priceRecord = {
            numericalID,
            productName: card.productName,
            storeName: card.storeName,
            price: priceValue, // 總價
            quantity: parseFloat(card.quantity),
            unitType: card.unitType,
            unitPrice: calculatedUnitPrice, // 單價
            discountDetails: card.discountDetails || '',
            timestamp: serverTimestamp(),
            recordedBy: "ocr-queue", // 標記為來自 OCR 隊列
            // 保存原價和特價信息（如果有的話）
            originalPrice: card.originalPrice ? parseFloat(card.originalPrice) : null,
            specialPrice: card.specialPrice ? parseFloat(card.specialPrice) : null
        };
        
        await addDoc(collection(db, "priceRecords"), priceRecord);
    };

    // 生成產品 ID 的函數
    function generateProductId(barcode, productName, storeName) {
        function djb2Hash(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i);
            }
            return hash >>> 0;
        }
        
        if (barcode) {
            return djb2Hash(barcode).toString();
        } else {
            // Combine productName and storeName to create a unique ID for products without barcodes
            return djb2Hash(`${productName}-${storeName}`).toString();
        }
    }

    // 新增函數：檢查價格是否為歷史最低（包含待辨識序列中的卡片）
    const checkIfBestPrice = useCallback(async (card, allCards) => {
        try {
            // 生成產品 ID
            const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
            
            if (!numericalID) return null;
            
            // 使用新的價格計算函數來確定最終價格
            const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
            const priceValue = parseFloat(finalPrice);
            
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
            
            if (calculatedUnitPrice === null) return null;
            
            // 查詢 Firebase 中該產品的所有價格記錄
            const recordsQuery = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID)
            );
            
            const recordsSnap = await getDocs(recordsQuery);
            const records = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 準備所有記錄以進行比較（包括當前記錄和待辨識序列中的相同產品）
            let allRecordsForCompare = [...records, { 
                unitPrice: calculatedUnitPrice,
                timestamp: new Date()
            }];
            
            // 添加待辨識序列中相同產品的卡片（排除當前卡片）
            const sameProductCards = allCards.filter(c => 
                c.id !== card.id && 
                generateProductId(c.scannedBarcode, c.productName, c.storeName) === numericalID
            );
            
            // 將相同產品的卡片添加到比較列表中
            sameProductCards.forEach(c => {
                const cardFinalPrice = calculateFinalPrice(c.extractedPrice, c.specialPrice);
                const cardPriceValue = parseFloat(cardFinalPrice);
                const cardUnitPrice = calculateUnitPrice(cardPriceValue, c.quantity, c.unitType);
                
                if (cardUnitPrice !== null) {
                    allRecordsForCompare.push({
                        unitPrice: cardUnitPrice,
                        timestamp: new Date(c.id) // 使用卡片 ID 作為時間戳
                    });
                }
            });

            // 如果沒有歷史記錄，則當前價格就是最低價
            if (allRecordsForCompare.length <= 1) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            }
            
            // 使用與主頁面相同的比價邏輯
            const bestDeal = allRecordsForCompare.reduce((best, cur) => {
                const curUnitPrice = cur.unitPrice !== undefined && cur.unitPrice !== null ? cur.unitPrice : Infinity;
                const bestUnitPrice = best.unitPrice !== undefined && best.unitPrice !== null ? best.unitPrice : Infinity;
                return curUnitPrice < bestUnitPrice ? cur : best;
            });

            const isBest = calculatedUnitPrice <= (bestDeal.unitPrice !== undefined && bestDeal.unitPrice !== null ? bestDeal.unitPrice : Infinity);
            
            if (isBest) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            } else {
                return { isBest: false, message: "非歷史最低價", backgroundColor: "bg-yellow-100" };
            }
        } catch (error) {
            console.error("比價檢查失敗:", error);
            return null;
        }
    }, []);

    // 當待辨識卡片列表改變時，重新計算比價結果
    useEffect(() => {
        const fetchPriceComparisonResults = async () => {
            const results = {};
            for (const card of pendingOcrCards) {
                const result = await checkIfBestPrice(card, pendingOcrCards);
                results[card.id] = result;
            }
            setPriceComparisonResults(results);
        };
        
        if (pendingOcrCards.length > 0) {
            fetchPriceComparisonResults();
        } else {
            setPriceComparisonResults({});
        }
    }, [pendingOcrCards, checkIfBestPrice]);

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${theme.bg}`}>
            <div className="max-w-2xl mx-auto">
                <div className="flex items-center mb-6 border-b pb-4">
                    <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4">
                        <ArrowLeft className="mr-1" size={20} />返回
                    </button>
                    <h1 className={`text-2xl font-bold ${theme.text} flex items-center`}>
                        <Clock className="w-6 h-6 mr-2" />待辨識序列管理
                    </h1>
                </div>

                {queueStats.total > 0 ? (
                    <div className="mb-6 p-4 bg-white rounded-lg shadow">
                        <h2 className="text-lg font-semibold mb-3">序列統計</h2>
                        {/* 改為橫式條列呈現 */}
                        <div className="flex flex-wrap gap-4">
                            <div className="flex items-center">
                                <div className="bg-blue-100 p-2 rounded-full mr-2">
                                    <span className="text-blue-600 font-bold">{queueStats.total}</span>
                                </div>
                                <span className="text-gray-600">總數</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-green-100 p-2 rounded-full mr-2">
                                    <span className="text-green-600 font-bold">{queueStats.oldest ? formatTime(queueStats.oldest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最早</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-purple-100 p-2 rounded-full mr-2">
                                    <span className="text-purple-600 font-bold">{queueStats.newest ? formatTime(queueStats.newest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最新</span>
                            </div>
                        </div>
                        
                        {/* localStorage 使用量顯示 */}
                        <div className="mt-4 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                ) : (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <AlertCircle size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">無待辨識項目</h3>
                        <p className="text-gray-500">目前沒有任何待確認的辨識卡片</p>
                        
                        {/* localStorage 使用量顯示（即使沒有項目也顯示） */}
                        <div className="mt-6 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                )}

                <div className="space-y-4">
                    {pendingOcrCards.map((card) => (
                        <div 
                            key={card.id} 
                            className={`bg-white p-4 rounded-lg shadow border-4 ${
                                priceComparisonResults[card.id]?.isBest 
                                    ? 'border-green-500' 
                                    : 'border-yellow-500'
                            }`}
                        >
                            <div className="flex justify-between items-start">
                                <div className="flex-1">
                                    {/* 將比價結果移到卡片頂部 */}
                                    {priceComparisonResults[card.id] && (
                                        <div className={`mb-3 p-2 rounded text-center text-base font-bold ${
                                            priceComparisonResults[card.id].isBest 
                                                ? 'bg-green-500 text-white' 
                                                : 'bg-yellow-500 text-pink-800'
                                        }`}>
                                            {priceComparisonResults[card.id].message}
                                        </div>
                                    )}
                                    
                                    <input
                                        type="text"
                                        value={card.productName || ''}
                                        onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                        className="font-bold text-lg text-gray-800 w-full p-1 mb-2 border-b border-gray-300 focus:border-blue-500 focus:outline-none"
                                        placeholder="產品名稱"
                                    />
                                    
                                    {/* 擷取畫面顯示 */}
                                    {card.capturedImage && (
                                        <div className="mt-3 mb-3">
                                            <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                                <div className="relative w-full aspect-video">
                                                    {card.capturedImage.startsWith('data:image') ? (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    ) : (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-1 mt-1 text-sm">
                                        {/* 條碼欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">條碼數據</label>
                                            <input
                                                type="text"
                                                value={card.scannedBarcode || ''}
                                                onChange={(e) => handleCardChange(card.id, 'scannedBarcode', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="條碼"
                                            />
                                        </div>
                                        
                                        {/* 產品名稱欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">產品名稱</label>
                                            <input
                                                type="text"
                                                value={card.productName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="產品名稱"
                                            />
                                        </div>
                                        
                                        {/* 商店欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">商店名稱</label>
                                            <input
                                                type="text"
                                                value={card.storeName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'storeName', e.target.value)}
                                                onClick={() => handleStoreClick(card)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 bg-gray-50 cursor-pointer"
                                                placeholder="點擊選擇商店"
                                            />
                                        </div>
                                        
                                        {/* 價格欄位 */}
                                        {card.specialPrice !== undefined ? (
                                            <>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">原價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.originalPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'originalPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                        placeholder="原價"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">特價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.specialPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'specialPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 text-green-600 font-bold"
                                                        placeholder="特價"
                                                    />
                                                </div>
                                            </>
                                        ) : (
                                            <div className="col-span-2">
                                                <label className="block text-gray-700 font-medium mb-0.5">總價 ($)</label>
                                                <input
                                                    type="number"
                                                    value={card.extractedPrice || ''}
                                                    onChange={(e) => handleCardChange(card.id, 'extractedPrice', e.target.value)}
                                                    className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                    placeholder="價格"
                                                />
                                            </div>
                                        )}
                                        
                                        {/* 數量和單位 */}
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">數量</label>
                                            <input
                                                type="text"
                                                value={card.quantity || ''}
                                                onChange={(e) => handleCardChange(card.id, 'quantity', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="數量"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">單位</label>
                                            <select
                                                value={card.unitType || 'pcs'}
                                                onChange={(e) => handleCardChange(card.id, 'unitType', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                            >
                                                <option value="ml">ml (毫升)</option>
                                                <option value="g">g (克)</option>
                                                <option value="pcs">pcs (個/包/支/條)</option>
                                            </select>
                                        </div>
                                        
                                        {/* 單價 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">單價 (每100g/ml)</label>
                                            <input
                                                type="text"
                                                value={formatUnitPrice(card.unitPrice)}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded bg-gray-100"
                                            />
                                        </div>
                                        
                                        {/* 優惠資訊 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">優惠細節</label>
                                            <input
                                                type="text"
                                                value={card.discountDetails || ''}
                                                onChange={(e) => handleCardChange(card.id, 'discountDetails', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="優惠資訊"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>加入時間: {formatTime(card.id)}</p>
                                        <p>運行時間: {calculateDuration(card.id)}</p>
                                    </div>
                                </div>
                                <div className="flex flex-col">
                                    <button 
                                        onClick={() => handleSaveClick(card)}
                                        className="p-2 text-green-500 hover:text-green-700 hover:bg-green-50 rounded-full"
                                        title="確認儲存"
                                    >
                                        <CheckCircle size={20} />
                                    </button>
                                    <button 
                                        onClick={() => handleDeleteClick(card)}
                                        className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full mt-5"
                                        title="刪除"
                                    >
                                        <Trash2 size={20} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            
            {/* 刪除確認對話框 - 保留 */}
            {deleteConfirmation && (
                <DeleteConfirmation 
                    card={deleteConfirmation}
                    onClose={cancelDelete}
                    onConfirm={confirmDelete}
                />
            )}
        </div>
    );
}

export default OcrQueuePage;
</file>

<file path="StoreSelector.js">
import React, { useState, useEffect, useCallback } from 'react';
import { X } from 'lucide-react';
import { db } from './firebase-config';
import { collection, getDocs, addDoc, query, where, serverTimestamp, doc, updateDoc } from 'firebase/firestore';

const initialStores = [
    { name: "全聯", sort: 1 },
    { name: "大全聯", sort: 2 },
    { name: "家樂福", sort: 3 },
    { name: "7-11", sort: 4 }, 
    { name: "全家", sort: 5 },
    { name: "萊爾富", sort: 6 }, 
    { name: "好市多", sort: 7 }, 
    { name: "屈臣氏", sort: 8 }, 
    { name: "康是美", sort: 9 },
    { name: "美廉社", sort: 10 }, 
    { name: "愛買", sort: 11 },
    { name: "其他", sort: 999 }
];

function StoreSelector({ theme, onSelect, onClose }) {
    const [selectedStore, setSelectedStore] = useState('');
    const [otherStore, setOtherStore] = useState('');
    const [commonStores, setCommonStores] = useState([]);
    const [loading, setLoading] = useState(true);

    const fetchStores = useCallback(async () => {
        setLoading(true);
        try {
            const storesCollection = collection(db, 'stores');
            let querySnapshot = await getDocs(storesCollection);

            if (querySnapshot.empty) {
                const batch = initialStores.map(store => 
                    addDoc(storesCollection, { ...store, createdAt: serverTimestamp() })
                );
                await Promise.all(batch);
                querySnapshot = await getDocs(storesCollection);
            } else {
                // --- Start of new migration logic ---
                const storesFromDb = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const updates = [];

                for (const initialStore of initialStores) {
                    const dbStore = storesFromDb.find(s => s.name === initialStore.name);
                    // If the store exists in DB but the sort order is different from the code
                    if (dbStore && dbStore.sort !== initialStore.sort) {
                        const storeRef = doc(db, 'stores', dbStore.id);
                        updates.push(updateDoc(storeRef, { sort: initialStore.sort }));
                    }
                }

                // If there are any updates to perform
                if (updates.length > 0) {
                    console.log(`Updating sort order for ${updates.length} stores...`);
                    await Promise.all(updates);
                    // Re-fetch the data after updates to ensure we have the latest version
                    querySnapshot = await getDocs(storesCollection);
                    console.log("Store sort order updated successfully.");
                }
                // --- End of new migration logic ---
            }

            const storesList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const uniqueStores = Array.from(new Map(storesList.map(store => [store.name, store])).values());
            const sortedStores = uniqueStores.sort((a, b) => (a.sort || 999) - (b.sort || 999));
            
            setCommonStores(sortedStores);

        } catch (error) {
            console.error("Firebase Error in fetchStores:", error);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchStores();
    }, [fetchStores]);

    const handleSelect = async () => {
        if (selectedStore === '其他' && otherStore.trim() === '') {
            alert('請輸入其他商店名稱');
            return;
        }
        
        let finalStoreName = selectedStore === '其他' ? otherStore.trim() : selectedStore;

        if (selectedStore === '其他') {
            const storesCollection = collection(db, 'stores');
            const q = query(storesCollection, where("name", "==", finalStoreName));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                await addDoc(storesCollection, {
                    name: finalStoreName,
                    sort: 1000, 
                    createdAt: serverTimestamp()
                });
            }
        }
        
        onSelect(finalStoreName);
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-[60] flex items-center justify-center p-4 sm:p-6">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-[calc(100%-80px)] sm:max-w-md flex flex-col max-h-[80vh] h-auto">
                <div className="p-6 pb-4 flex-shrink-0">
                    <div className="flex justify-between items-center mb-4 border-b pb-2">
                        <h3 className={`text-xl font-bold ${theme.text}`}>
                            選擇商店
                        </h3>
                        <button 
                            onClick={onClose}
                            className="p-1 rounded-full text-gray-500 hover:text-gray-900"
                        >
                            <X className="w-6 h-6" />
                        </button>
                    </div>
                    <p className="text-gray-600">請選擇或輸入商店名稱：</p>
                </div>

                {loading ? (
                    <div className="flex-grow flex justify-center items-center">
                        <p className="text-gray-600">正在從資料庫載入商店列表...</p>
                    </div>
                ) : (
                    <div className="flex-grow overflow-y-auto px-6">
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 py-1">
                            {commonStores.map((store) => (
                                <button
                                    key={store.id}
                                    onClick={() => setSelectedStore(store.name)}
                                    className={`p-3 rounded-lg text-center font-medium transition-all ${
                                        selectedStore === store.name 
                                            ? `${themePrimary} text-white shadow-md` 
                                            : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                                    }`}
                                >
                                    {store.name}
                                </button>
                            ))}
                        </div>
                    </div>
                )}

                <div className="p-6 pt-4 flex-shrink-0">
                    {selectedStore === '其他' && (
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-2">請輸入商店名稱：</label>
                            <input
                                type="text"
                                value={otherStore}
                                onChange={(e) => setOtherStore(e.target.value)}
                                placeholder="輸入商店名稱"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"
                            />
                        </div>
                    )}

                    <div className="flex justify-end space-x-3 pt-4 border-t">
                        <button
                            onClick={onClose}
                            className="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-lg hover:bg-gray-600 transition-all"
                        >
                            取消
                        </button>
                        <button
                            onClick={handleSelect}
                            disabled={loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')}
                            className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg transition-all ${
                                loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : `${themePrimary} ${themeHover}`
                            }`}
                        >
                            確認選擇
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}

export default StoreSelector;
</file>

<file path="utils/errorHandler.js">
/**
 * 全域錯誤處理工具函數
 * 提供更具體的錯誤訊息給使用者
 */

/**
 * 解析 Firebase 錯誤並返回使用者友好的錯誤訊息
 * @param {Error} error - Firebase 錯誤物件
 * @returns {string} 使用者友好的錯誤訊息
 */
export function parseFirebaseError(error) {
    if (!error || !error.code) {
        return "發生未知錯誤，請稍後再試";
    }

    // 根據 Firebase 錯誤碼提供具體的錯誤訊息
    switch (error.code) {
        case 'permission-denied':
            return "權限不足，無法儲存資料。請聯繫系統管理員";
        
        case 'unavailable':
            return "Firebase 服務暫時無法使用，請檢查網路連線後再試";
            
        case 'deadline-exceeded':
            return "請求超時，請檢查網路連線後再試";
            
        case 'resource-exhausted':
            return "系統資源已滿，請稍後再試";
            
        case 'failed-precondition':
            return "資料格式錯誤，無法儲存";
            
        case 'aborted':
            return "操作被中斷，請重新嘗試";
            
        case 'out-of-range':
            return "資料超出允許範圍";
            
        case 'unimplemented':
            return "此功能尚未實作";
            
        case 'internal':
            return "系統內部錯誤，請稍後再試";
            
        case 'data-loss':
            return "資料遺失，請重新輸入";
            
        case 'unauthenticated':
            return "身份驗證失敗，請重新整理頁面";
            
        default:
            // 對於其他錯誤，提供通用但具體的訊息
            if (error.message.includes('offline') || error.message.includes('network')) {
                return "網路連線異常，請檢查網路設定後再試";
            }
            if (error.message.includes('quota')) {
                return "超過使用配額，請稍後再試";
            }
            return `操作失敗: ${error.message || '未知錯誤'}`;
    }
}

/**
 * 顯示錯誤訊息給使用者
 * @param {Error|string} error - 錯誤物件或錯誤訊息
 * @param {string} context - 錯誤發生的上下文（可選）
 */
export function showUserFriendlyError(error, context = '') {
    let message = '';
    
    if (typeof error === 'string') {
        message = error;
    } else if (error && error.message) {
        // 如果是 Firebase 錯誤，使用專門的解析函數
        if (error.code) {
            message = parseFirebaseError(error);
        } else {
            message = error.message;
        }
    } else {
        message = "發生未知錯誤，請稍後再試";
    }
    
    // 如果有上下文資訊，添加到訊息中
    if (context) {
        message = `[${context}] ${message}`;
    }
    
    // 顯示錯誤訊息給使用者
    alert(message);
}

/**
 * 處理 Firestore 儲存操作的錯誤
 * @param {Error} error - 錯誤物件
 * @param {string} operation - 操作類型（如 "儲存產品資訊"、"儲存價格記錄"）
 * @returns {string} 使用者友好的錯誤訊息
 */
export function handleFirestoreSaveError(error, operation = '儲存資料') {
    const userMessage = parseFirebaseError(error);
    const fullMessage = `${operation}失敗: ${userMessage}`;
    
    console.error(`[${operation}錯誤]`, error);
    return fullMessage;
}

// 建立一個導出物件而不是匿名導出
const errorHandler = {
    parseFirebaseError,
    showUserFriendlyError,
    handleFirestoreSaveError
};

export default errorHandler;
</file>

<file path="utils/errorHandler.test.js">
/**
 * 錯誤處理工具的測試檔案
 */

import { parseFirebaseError, handleFirestoreSaveError } from './errorHandler';

// 模擬 Firebase 錯誤物件
const mockFirebaseErrors = [
    { code: 'permission-denied', message: 'Missing or insufficient permissions.' },
    { code: 'unavailable', message: 'The service is currently unavailable.' },
    { code: 'deadline-exceeded', message: 'Deadline exceeded.' },
    { code: 'unknown', message: 'Network error' },
    { code: 'internal', message: 'Internal server error' }
];

// 測試 parseFirebaseError 函數
console.log('測試 parseFirebaseError 函數:');
mockFirebaseErrors.forEach((error, index) => {
    const result = parseFirebaseError(error);
    console.log(`測試 ${index + 1}:`, result);
});

// 測試 handleFirestoreSaveError 函數
console.log('\n測試 handleFirestoreSaveError 函數:');
const testError = { code: 'permission-denied', message: 'Missing or insufficient permissions.' };
const result = handleFirestoreSaveError(testError, "儲存產品資訊");
console.log('結果:', result);

console.log('\n所有測試完成');
</file>

<file path="utils/priceCalculations.js">
export const calculateUnitPrice = (price, quantity, unitType) => {
  const p = parseFloat(price);
  const q = parseFloat(quantity);
  if (isNaN(p) || isNaN(q) || q <= 0) {
    return null;
  }
  // 對於 'g' 或 'ml'，計算每 100 單位的價格
  return (unitType === 'g' || unitType === 'ml') ? (p / q) * 100 : p / q;
};

// 新增一個函數來根據原價和特價計算最終價格
export const calculateFinalPrice = (originalPrice, specialPrice) => {
  // 如果有特價，則優先使用特價
  if (specialPrice && !isNaN(parseFloat(specialPrice))) {
    return parseFloat(specialPrice);
  }
  // 否則使用原價
  if (originalPrice && !isNaN(parseFloat(originalPrice))) {
    return parseFloat(originalPrice);
  }
  // 如果都沒有，返回 0
  return 0;
};

/**
 * 安全地格式化單價顯示
 * @param {number|null|undefined} unitPrice - 單價值
 * @returns {string} 格式化後的單價字符串
 */
export const formatUnitPrice = (unitPrice) => {
  // 檢查值是否存在且不為 null 或 undefined
  if (unitPrice == null) {
    return '--';
  }
  
  // 檢查值是否為有效數字
  const parsedUnitPrice = parseFloat(unitPrice);
  if (isNaN(parsedUnitPrice)) {
    return '--';
  }
  
  // 檢查是否為 0
  if (parsedUnitPrice === 0) {
    return '--';
  }
  
  // 返回格式化後的價格
  return parsedUnitPrice.toFixed(2);
};
</file>

</files>
</file>

<file path="StoreSelector.js">
import React, { useState, useEffect, useCallback } from 'react';
import { X } from 'lucide-react';
import { db } from './firebase-config';
import { collection, getDocs, addDoc, query, where, serverTimestamp, doc, updateDoc } from 'firebase/firestore';

const initialStores = [
    { name: "全聯", sort: 1 },
    { name: "大全聯", sort: 2 },
    { name: "家樂福", sort: 3 },
    { name: "7-11", sort: 4 }, 
    { name: "全家", sort: 5 },
    { name: "萊爾富", sort: 6 }, 
    { name: "好市多", sort: 7 }, 
    { name: "屈臣氏", sort: 8 }, 
    { name: "康是美", sort: 9 },
    { name: "美廉社", sort: 10 }, 
    { name: "愛買", sort: 11 },
    { name: "其他", sort: 999 }
];

function StoreSelector({ theme, onSelect, onClose }) {
    const [selectedStore, setSelectedStore] = useState('');
    const [otherStore, setOtherStore] = useState('');
    const [commonStores, setCommonStores] = useState([]);
    const [loading, setLoading] = useState(true);

    const fetchStores = useCallback(async () => {
        setLoading(true);
        try {
            const storesCollection = collection(db, 'stores');
            let querySnapshot = await getDocs(storesCollection);

            if (querySnapshot.empty) {
                const batch = initialStores.map(store => 
                    addDoc(storesCollection, { ...store, createdAt: serverTimestamp() })
                );
                await Promise.all(batch);
                querySnapshot = await getDocs(storesCollection);
            } else {
                // --- Start of new migration logic ---
                const storesFromDb = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const updates = [];

                for (const initialStore of initialStores) {
                    const dbStore = storesFromDb.find(s => s.name === initialStore.name);
                    // If the store exists in DB but the sort order is different from the code
                    if (dbStore && dbStore.sort !== initialStore.sort) {
                        const storeRef = doc(db, 'stores', dbStore.id);
                        updates.push(updateDoc(storeRef, { sort: initialStore.sort }));
                    }
                }

                // If there are any updates to perform
                if (updates.length > 0) {
                    console.log(`Updating sort order for ${updates.length} stores...`);
                    await Promise.all(updates);
                    // Re-fetch the data after updates to ensure we have the latest version
                    querySnapshot = await getDocs(storesCollection);
                    console.log("Store sort order updated successfully.");
                }
                // --- End of new migration logic ---
            }

            const storesList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const uniqueStores = Array.from(new Map(storesList.map(store => [store.name, store])).values());
            const sortedStores = uniqueStores.sort((a, b) => (a.sort || 999) - (b.sort || 999));
            
            setCommonStores(sortedStores);

        } catch (error) {
            console.error("Firebase Error in fetchStores:", error);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchStores();
    }, [fetchStores]);

    const handleSelect = async () => {
        if (selectedStore === '其他' && otherStore.trim() === '') {
            alert('請輸入其他商店名稱');
            return;
        }
        
        let finalStoreName = selectedStore === '其他' ? otherStore.trim() : selectedStore;

        if (selectedStore === '其他') {
            const storesCollection = collection(db, 'stores');
            const q = query(storesCollection, where("name", "==", finalStoreName));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                await addDoc(storesCollection, {
                    name: finalStoreName,
                    sort: 1000, 
                    createdAt: serverTimestamp()
                });
            }
        }
        
        onSelect(finalStoreName);
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-[60] flex items-center justify-center p-4 sm:p-6">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-[calc(100%-80px)] sm:max-w-md flex flex-col max-h-[80vh] h-auto">
                <div className="p-6 pb-4 flex-shrink-0">
                    <div className="flex justify-between items-center mb-4 border-b pb-2">
                        <h3 className={`text-xl font-bold ${theme.text}`}>
                            選擇商店
                        </h3>
                        <button 
                            onClick={onClose}
                            className="p-1 rounded-full text-gray-500 hover:text-gray-900"
                        >
                            <X className="w-6 h-6" />
                        </button>
                    </div>
                    <p className="text-gray-600">請選擇或輸入商店名稱：</p>
                </div>

                {loading ? (
                    <div className="flex-grow flex justify-center items-center">
                        <p className="text-gray-600">正在從資料庫載入商店列表...</p>
                    </div>
                ) : (
                    <div className="flex-grow overflow-y-auto px-6">
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 py-1">
                            {commonStores.map((store) => (
                                <button
                                    key={store.id}
                                    onClick={() => setSelectedStore(store.name)}
                                    className={`p-3 rounded-lg text-center font-medium transition-all ${
                                        selectedStore === store.name 
                                            ? `${themePrimary} text-white shadow-md` 
                                            : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                                    }`}
                                >
                                    {store.name}
                                </button>
                            ))}
                        </div>
                    </div>
                )}

                <div className="p-6 pt-4 flex-shrink-0">
                    {selectedStore === '其他' && (
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-2">請輸入商店名稱：</label>
                            <input
                                type="text"
                                value={otherStore}
                                onChange={(e) => setOtherStore(e.target.value)}
                                placeholder="輸入商店名稱"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"
                            />
                        </div>
                    )}

                    <div className="flex justify-end space-x-3 pt-4 border-t">
                        <button
                            onClick={onClose}
                            className="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-lg hover:bg-gray-600 transition-all"
                        >
                            取消
                        </button>
                        <button
                            onClick={handleSelect}
                            disabled={loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')}
                            className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg transition-all ${
                                loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : `${themePrimary} ${themeHover}`
                            }`}
                        >
                            確認選擇
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}

export default StoreSelector;
</file>

<file path="utils/errorHandler.js">
/**
 * 全域錯誤處理工具函數
 * 提供更具體的錯誤訊息給使用者
 */

/**
 * 解析 Firebase 錯誤並返回使用者友好的錯誤訊息
 * @param {Error} error - Firebase 錯誤物件
 * @returns {string} 使用者友好的錯誤訊息
 */
export function parseFirebaseError(error) {
    if (!error || !error.code) {
        return "發生未知錯誤，請稍後再試";
    }

    // 根據 Firebase 錯誤碼提供具體的錯誤訊息
    switch (error.code) {
        case 'permission-denied':
            return "權限不足，無法儲存資料。請聯繫系統管理員";
        
        case 'unavailable':
            return "Firebase 服務暫時無法使用，請檢查網路連線後再試";
            
        case 'deadline-exceeded':
            return "請求超時，請檢查網路連線後再試";
            
        case 'resource-exhausted':
            return "系統資源已滿，請稍後再試";
            
        case 'failed-precondition':
            return "資料格式錯誤，無法儲存";
            
        case 'aborted':
            return "操作被中斷，請重新嘗試";
            
        case 'out-of-range':
            return "資料超出允許範圍";
            
        case 'unimplemented':
            return "此功能尚未實作";
            
        case 'internal':
            return "系統內部錯誤，請稍後再試";
            
        case 'data-loss':
            return "資料遺失，請重新輸入";
            
        case 'unauthenticated':
            return "身份驗證失敗，請重新整理頁面";
            
        default:
            // 對於其他錯誤，提供通用但具體的訊息
            if (error.message.includes('offline') || error.message.includes('network')) {
                return "網路連線異常，請檢查網路設定後再試";
            }
            if (error.message.includes('quota')) {
                return "超過使用配額，請稍後再試";
            }
            return `操作失敗: ${error.message || '未知錯誤'}`;
    }
}

/**
 * 顯示錯誤訊息給使用者
 * @param {Error|string} error - 錯誤物件或錯誤訊息
 * @param {string} context - 錯誤發生的上下文（可選）
 */
export function showUserFriendlyError(error, context = '') {
    let message = '';
    
    if (typeof error === 'string') {
        message = error;
    } else if (error && error.message) {
        // 如果是 Firebase 錯誤，使用專門的解析函數
        if (error.code) {
            message = parseFirebaseError(error);
        } else {
            message = error.message;
        }
    } else {
        message = "發生未知錯誤，請稍後再試";
    }
    
    // 如果有上下文資訊，添加到訊息中
    if (context) {
        message = `[${context}] ${message}`;
    }
    
    // 顯示錯誤訊息給使用者
    alert(message);
}

/**
 * 處理 Firestore 儲存操作的錯誤
 * @param {Error} error - 錯誤物件
 * @param {string} operation - 操作類型（如 "儲存產品資訊"、"儲存價格記錄"）
 * @returns {string} 使用者友好的錯誤訊息
 */
export function handleFirestoreSaveError(error, operation = '儲存資料') {
    const userMessage = parseFirebaseError(error);
    const fullMessage = `${operation}失敗: ${userMessage}`;
    
    console.error(`[${operation}錯誤]`, error);
    return fullMessage;
}

// 建立一個導出物件而不是匿名導出
const errorHandler = {
    parseFirebaseError,
    showUserFriendlyError,
    handleFirestoreSaveError
};

export default errorHandler;
</file>

<file path="utils/errorHandler.test.js">
/**
 * 錯誤處理工具的測試檔案
 */

import { parseFirebaseError, handleFirestoreSaveError } from './errorHandler';

// 模擬 Firebase 錯誤物件
const mockFirebaseErrors = [
    { code: 'permission-denied', message: 'Missing or insufficient permissions.' },
    { code: 'unavailable', message: 'The service is currently unavailable.' },
    { code: 'deadline-exceeded', message: 'Deadline exceeded.' },
    { code: 'unknown', message: 'Network error' },
    { code: 'internal', message: 'Internal server error' }
];

// 測試 parseFirebaseError 函數
console.log('測試 parseFirebaseError 函數:');
mockFirebaseErrors.forEach((error, index) => {
    const result = parseFirebaseError(error);
    console.log(`測試 ${index + 1}:`, result);
});

// 測試 handleFirestoreSaveError 函數
console.log('\n測試 handleFirestoreSaveError 函數:');
const testError = { code: 'permission-denied', message: 'Missing or insufficient permissions.' };
const result = handleFirestoreSaveError(testError, "儲存產品資訊");
console.log('結果:', result);

console.log('\n所有測試完成');
</file>

<file path="utils/priceCalculations.js">
export const calculateUnitPrice = (price, quantity, unitType) => {
  const p = parseFloat(price);
  const q = parseFloat(quantity);
  if (isNaN(p) || isNaN(q) || q <= 0) {
    return null;
  }
  // 對於 'g' 或 'ml'，計算每 100 單位的價格
  return (unitType === 'g' || unitType === 'ml') ? (p / q) * 100 : p / q;
};

// 新增一個函數來根據原價和特價計算最終價格
export const calculateFinalPrice = (originalPrice, specialPrice) => {
  // 如果有特價，則優先使用特價
  if (specialPrice && !isNaN(parseFloat(specialPrice))) {
    return parseFloat(specialPrice);
  }
  // 否則使用原價
  if (originalPrice && !isNaN(parseFloat(originalPrice))) {
    return parseFloat(originalPrice);
  }
  // 如果都沒有，返回 0
  return 0;
};

/**
 * 安全地格式化單價顯示
 * @param {number|null|undefined} unitPrice - 單價值
 * @returns {string} 格式化後的單價字符串
 */
export const formatUnitPrice = (unitPrice) => {
  // 檢查值是否存在且不為 null 或 undefined
  if (unitPrice == null) {
    return '--';
  }
  
  // 檢查值是否為有效數字
  const parsedUnitPrice = parseFloat(unitPrice);
  if (isNaN(parsedUnitPrice)) {
    return '--';
  }
  
  // 檢查是否為 0
  if (parsedUnitPrice === 0) {
    return '--';
  }
  
  // 返回格式化後的價格
  return parsedUnitPrice.toFixed(2);
};
</file>

</files>
</file>

<file path="StoreSelector.js">
import React, { useState, useEffect, useCallback } from 'react';
import { X } from 'lucide-react';
import { db } from './firebase-config';
import { collection, getDocs, addDoc, query, where, serverTimestamp, doc, updateDoc } from 'firebase/firestore';

const initialStores = [
    { name: "全聯", sort: 1 },
    { name: "大全聯", sort: 2 },
    { name: "家樂福", sort: 3 },
    { name: "7-11", sort: 4 }, 
    { name: "全家", sort: 5 },
    { name: "萊爾富", sort: 6 }, 
    { name: "好市多", sort: 7 }, 
    { name: "屈臣氏", sort: 8 }, 
    { name: "康是美", sort: 9 },
    { name: "美廉社", sort: 10 }, 
    { name: "愛買", sort: 11 },
    { name: "其他", sort: 999 }
];

function StoreSelector({ theme, onSelect, onClose }) {
    const [selectedStore, setSelectedStore] = useState('');
    const [otherStore, setOtherStore] = useState('');
    const [commonStores, setCommonStores] = useState([]);
    const [loading, setLoading] = useState(true);

    const fetchStores = useCallback(async () => {
        setLoading(true);
        try {
            const storesCollection = collection(db, 'stores');
            let querySnapshot = await getDocs(storesCollection);

            if (querySnapshot.empty) {
                const batch = initialStores.map(store => 
                    addDoc(storesCollection, { ...store, createdAt: serverTimestamp() })
                );
                await Promise.all(batch);
                querySnapshot = await getDocs(storesCollection);
            } else {
                // --- Start of new migration logic ---
                const storesFromDb = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const updates = [];

                for (const initialStore of initialStores) {
                    const dbStore = storesFromDb.find(s => s.name === initialStore.name);
                    // If the store exists in DB but the sort order is different from the code
                    if (dbStore && dbStore.sort !== initialStore.sort) {
                        const storeRef = doc(db, 'stores', dbStore.id);
                        updates.push(updateDoc(storeRef, { sort: initialStore.sort }));
                    }
                }

                // If there are any updates to perform
                if (updates.length > 0) {
                    console.log(`Updating sort order for ${updates.length} stores...`);
                    await Promise.all(updates);
                    // Re-fetch the data after updates to ensure we have the latest version
                    querySnapshot = await getDocs(storesCollection);
                    console.log("Store sort order updated successfully.");
                }
                // --- End of new migration logic ---
            }

            const storesList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const uniqueStores = Array.from(new Map(storesList.map(store => [store.name, store])).values());
            const sortedStores = uniqueStores.sort((a, b) => (a.sort || 999) - (b.sort || 999));
            
            setCommonStores(sortedStores);

        } catch (error) {
            console.error("Firebase Error in fetchStores:", error);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchStores();
    }, [fetchStores]);

    const handleSelect = async () => {
        if (selectedStore === '其他' && otherStore.trim() === '') {
            alert('請輸入其他商店名稱');
            return;
        }
        
        let finalStoreName = selectedStore === '其他' ? otherStore.trim() : selectedStore;

        if (selectedStore === '其他') {
            const storesCollection = collection(db, 'stores');
            const q = query(storesCollection, where("name", "==", finalStoreName));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                await addDoc(storesCollection, {
                    name: finalStoreName,
                    sort: 1000, 
                    createdAt: serverTimestamp()
                });
            }
        }
        
        onSelect(finalStoreName);
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-[60] flex items-center justify-center p-4 sm:p-6">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-[calc(100%-80px)] sm:max-w-md flex flex-col max-h-[80vh] h-auto">
                <div className="p-6 pb-4 flex-shrink-0">
                    <div className="flex justify-between items-center mb-4 border-b pb-2">
                        <h3 className={`text-xl font-bold ${theme.text}`}>
                            選擇商店
                        </h3>
                        <button 
                            onClick={onClose}
                            className="p-1 rounded-full text-gray-500 hover:text-gray-900"
                        >
                            <X className="w-6 h-6" />
                        </button>
                    </div>
                    <p className="text-gray-600">請選擇或輸入商店名稱：</p>
                </div>

                {loading ? (
                    <div className="flex-grow flex justify-center items-center">
                        <p className="text-gray-600">正在從資料庫載入商店列表...</p>
                    </div>
                ) : (
                    <div className="flex-grow overflow-y-auto px-6">
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 py-1">
                            {commonStores.map((store) => (
                                <button
                                    key={store.id}
                                    onClick={() => setSelectedStore(store.name)}
                                    className={`p-3 rounded-lg text-center font-medium transition-all ${
                                        selectedStore === store.name 
                                            ? `${themePrimary} text-white shadow-md` 
                                            : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                                    }`}
                                >
                                    {store.name}
                                </button>
                            ))}
                        </div>
                    </div>
                )}

                <div className="p-6 pt-4 flex-shrink-0">
                    {selectedStore === '其他' && (
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-2">請輸入商店名稱：</label>
                            <input
                                type="text"
                                value={otherStore}
                                onChange={(e) => setOtherStore(e.target.value)}
                                placeholder="輸入商店名稱"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"
                                autoFocus
                            />
                        </div>
                    )}

                    <div className="flex justify-end space-x-3 pt-4 border-t">
                        <button
                            onClick={onClose}
                            className="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-lg hover:bg-gray-600 transition-all"
                        >
                            取消
                        </button>
                        <button
                            onClick={handleSelect}
                            disabled={loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')}
                            className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg transition-all ${
                                loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : `${themePrimary} ${themeHover}`
                            }`}
                        >
                            確認選擇
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}

export default StoreSelector;
</file>

<file path="utils/errorHandler.js">
/**
 * 全域錯誤處理工具函數
 * 提供更具體的錯誤訊息給使用者
 */

/**
 * 解析 Firebase 錯誤並返回使用者友好的錯誤訊息
 * @param {Error} error - Firebase 錯誤物件
 * @returns {string} 使用者友好的錯誤訊息
 */
export function parseFirebaseError(error) {
    if (!error || !error.code) {
        return "發生未知錯誤，請稍後再試";
    }

    // 根據 Firebase 錯誤碼提供具體的錯誤訊息
    switch (error.code) {
        case 'permission-denied':
            return "權限不足，無法儲存資料。請聯繫系統管理員";
        
        case 'unavailable':
            return "Firebase 服務暫時無法使用，請檢查網路連線後再試";
            
        case 'deadline-exceeded':
            return "請求超時，請檢查網路連線後再試";
            
        case 'resource-exhausted':
            return "系統資源已滿，請稍後再試";
            
        case 'failed-precondition':
            return "資料格式錯誤，無法儲存";
            
        case 'aborted':
            return "操作被中斷，請重新嘗試";
            
        case 'out-of-range':
            return "資料超出允許範圍";
            
        case 'unimplemented':
            return "此功能尚未實作";
            
        case 'internal':
            return "系統內部錯誤，請稍後再試";
            
        case 'data-loss':
            return "資料遺失，請重新輸入";
            
        case 'unauthenticated':
            return "身份驗證失敗，請重新整理頁面";
            
        default:
            // 對於其他錯誤，提供通用但具體的訊息
            if (error.message.includes('offline') || error.message.includes('network')) {
                return "網路連線異常，請檢查網路設定後再試";
            }
            if (error.message.includes('quota')) {
                return "超過使用配額，請稍後再試";
            }
            return `操作失敗: ${error.message || '未知錯誤'}`;
    }
}

/**
 * 顯示錯誤訊息給使用者
 * @param {Error|string} error - 錯誤物件或錯誤訊息
 * @param {string} context - 錯誤發生的上下文（可選）
 */
export function showUserFriendlyError(error, context = '') {
    let message = '';
    
    if (typeof error === 'string') {
        message = error;
    } else if (error && error.message) {
        // 如果是 Firebase 錯誤，使用專門的解析函數
        if (error.code) {
            message = parseFirebaseError(error);
        } else {
            message = error.message;
        }
    } else {
        message = "發生未知錯誤，請稍後再試";
    }
    
    // 如果有上下文資訊，添加到訊息中
    if (context) {
        message = `[${context}] ${message}`;
    }
    
    // 顯示錯誤訊息給使用者
    alert(message);
}

/**
 * 處理 Firestore 儲存操作的錯誤
 * @param {Error} error - 錯誤物件
 * @param {string} operation - 操作類型（如 "儲存產品資訊"、"儲存價格記錄"）
 * @returns {string} 使用者友好的錯誤訊息
 */
export function handleFirestoreSaveError(error, operation = '儲存資料') {
    const userMessage = parseFirebaseError(error);
    const fullMessage = `${operation}失敗: ${userMessage}`;
    
    console.error(`[${operation}錯誤]`, error);
    return fullMessage;
}

// 建立一個導出物件而不是匿名導出
const errorHandler = {
    parseFirebaseError,
    showUserFriendlyError,
    handleFirestoreSaveError
};

export default errorHandler;
</file>

<file path="utils/errorHandler.test.js">
/**
 * 錯誤處理工具的測試檔案
 */

import { parseFirebaseError, handleFirestoreSaveError } from './errorHandler';

// 模擬 Firebase 錯誤物件
const mockFirebaseErrors = [
    { code: 'permission-denied', message: 'Missing or insufficient permissions.' },
    { code: 'unavailable', message: 'The service is currently unavailable.' },
    { code: 'deadline-exceeded', message: 'Deadline exceeded.' },
    { code: 'unknown', message: 'Network error' },
    { code: 'internal', message: 'Internal server error' }
];

// 測試 parseFirebaseError 函數
console.log('測試 parseFirebaseError 函數:');
mockFirebaseErrors.forEach((error, index) => {
    const result = parseFirebaseError(error);
    console.log(`測試 ${index + 1}:`, result);
});

// 測試 handleFirestoreSaveError 函數
console.log('\n測試 handleFirestoreSaveError 函數:');
const testError = { code: 'permission-denied', message: 'Missing or insufficient permissions.' };
const result = handleFirestoreSaveError(testError, "儲存產品資訊");
console.log('結果:', result);

console.log('\n所有測試完成');
</file>

<file path="utils/priceCalculations.js">
export const calculateUnitPrice = (price, quantity, unitType) => {
  const p = parseFloat(price);
  const q = parseFloat(quantity);
  if (isNaN(p) || isNaN(q) || q <= 0) {
    return null;
  }
  // 對於 'g' 或 'ml'，計算每 100 單位的價格
  return (unitType === 'g' || unitType === 'ml') ? (p / q) * 100 : p / q;
};

// 新增一個函數來根據原價和特價計算最終價格
export const calculateFinalPrice = (originalPrice, specialPrice) => {
  // 如果有特價，則優先使用特價
  if (specialPrice && !isNaN(parseFloat(specialPrice))) {
    return parseFloat(specialPrice);
  }
  // 否則使用原價
  if (originalPrice && !isNaN(parseFloat(originalPrice))) {
    return parseFloat(originalPrice);
  }
  // 如果都沒有，返回 0
  return 0;
};

/**
 * 安全地格式化單價顯示
 * @param {number|null|undefined} unitPrice - 單價值
 * @returns {string} 格式化後的單價字符串
 */
export const formatUnitPrice = (unitPrice) => {
  // 檢查值是否存在且不為 null 或 undefined
  if (unitPrice == null) {
    return '--';
  }
  
  // 檢查值是否為有效數字
  const parsedUnitPrice = parseFloat(unitPrice);
  if (isNaN(parsedUnitPrice)) {
    return '--';
  }
  
  // 檢查是否為 0
  if (parsedUnitPrice === 0) {
    return '--';
  }
  
  // 返回格式化後的價格
  return parsedUnitPrice.toFixed(2);
};
</file>

</files>
</file>

<file path="netlify/functions/gemini-proxy.js">
// 使用 ES 模組語法，Netlify Functions 支援
import fetch from 'node-fetch';

// API 金鑰從環境變數讀取，確保安全
const apiKey = process.env.GEMINI_API_KEY;

// Netlify Function 的主要處理函數
exports.handler = async (event, context) => {
  // 只允許 POST 請求
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method Not Allowed' }),
    };
  }

  try {
    // 從前端請求中解析出資料，包含 responseSchema
    const { systemPrompt, userPrompt, base64Image, responseSchema } = JSON.parse(event.body);

    // 驗證收到的資料
    if (!systemPrompt || !userPrompt || !base64Image || !responseSchema) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Missing required fields: systemPrompt, userPrompt, base64Image, or responseSchema' }),
      };
    }
    
    // Google Gemini API 的端點
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

    // 構建與 Google API 規格相符的 payload
    const payload = {
      contents: [{
        role: "user",
        parts: [
          { text: userPrompt },
          {
            inlineData: {
              mimeType: "image/jpeg",
              data: base64Image
            }
          }
        ]
      }],
      systemInstruction: { parts: [{ text: systemPrompt }] },
      generationConfig: {
        temperature: 0.1,
        responseMimeType: "application/json",
        // 使用從前端傳來的 responseSchema
        responseSchema: responseSchema
      }
    };

    // 呼叫 Google API
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    // 檢查 Google API 的回應
    if (!response.ok) {
      const errorBody = await response.json();
      console.error('Google API Error:', errorBody);
      return {
        statusCode: response.status,
        body: JSON.stringify({ error: `Google API error: ${errorBody.error?.message || 'Unknown error'}` }),
      };
    }

    // 將 Google API 的成功回應直接傳回給前端
    const data = await response.json();
    return {
      statusCode: 200,
      body: JSON.stringify(data),
    };

  } catch (error) {
    console.error('Serverless Function Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: `Internal Server Error: ${error.message}` }),
    };
  }
};
</file>

<file path="src/utils/priceCalculations.js">
export const calculateUnitPrice = (price, quantity, unitType) => {
  const p = parseFloat(price);
  const q = parseFloat(quantity);
  if (isNaN(p) || isNaN(q) || q <= 0) {
    return null;
  }
  // 對於 'g' 或 'ml'，計算每 100 單位的價格
  return (unitType === 'g' || unitType === 'ml') ? (p / q) * 100 : p / q;
};

// 新增一個函數來根據原價和特價計算最終價格
export const calculateFinalPrice = (originalPrice, specialPrice) => {
  // 如果有特價，則優先使用特價
  if (specialPrice && !isNaN(parseFloat(specialPrice))) {
    return parseFloat(specialPrice);
  }
  // 否則使用原價
  if (originalPrice && !isNaN(parseFloat(originalPrice))) {
    return parseFloat(originalPrice);
  }
  // 如果都沒有，返回 0
  return 0;
};

/**
 * 安全地格式化單價顯示
 * @param {number|null|undefined} unitPrice - 單價值
 * @returns {string} 格式化後的單價字符串
 */
export const formatUnitPrice = (unitPrice) => {
  // 檢查值是否存在且不為 null 或 undefined
  if (unitPrice == null) {
    return '--';
  }
  
  // 檢查值是否為有效數字
  const parsedUnitPrice = parseFloat(unitPrice);
  if (isNaN(parsedUnitPrice)) {
    return '--';
  }
  
  // 檢查是否為 0
  if (parsedUnitPrice === 0) {
    return '--';
  }
  
  // 返回格式化後的價格
  return parsedUnitPrice.toFixed(2);
};
</file>

<file path="src/components/AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        
        // 計算預覽框在視頻中的實際像素位置和尺寸 (75% 中心區域)
        const cropWidth = video.videoWidth * 0.75;
        const cropHeight = video.videoHeight * 0.75;
        const cropX = (video.videoWidth - cropWidth) / 2;
        const cropY = (video.videoHeight - cropHeight) / 2;
        
        // 創建最終的 canvas 來繪製裁切後的圖片
        const canvas = document.createElement('canvas');
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        const ctx = canvas.getContext('2d');
        
        // 從視頻中裁切並繪製 75% 中心區域
        ctx.drawImage(
            video, 
            cropX, cropY, cropWidth, cropHeight,  // source rectangle
            0, 0, cropWidth, cropHeight           // destination rectangle
        );
        
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片

        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="src/StoreSelector.js">
import React, { useState, useEffect, useCallback } from 'react';
import { X } from 'lucide-react';
import { db } from './firebase-config';
import { collection, getDocs, addDoc, query, where, serverTimestamp, doc, updateDoc } from 'firebase/firestore';

const initialStores = [
    { name: "全聯", sort: 1 },
    { name: "大全聯", sort: 2 },
    { name: "家樂福", sort: 3 },
    { name: "7-11", sort: 4 }, 
    { name: "全家", sort: 5 },
    { name: "萊爾富", sort: 6 }, 
    { name: "好市多", sort: 7 }, 
    { name: "屈臣氏", sort: 8 }, 
    { name: "康是美", sort: 9 },
    { name: "美廉社", sort: 10 }, 
    { name: "愛買", sort: 11 },
    { name: "其他", sort: 999 }
];

function StoreSelector({ theme, onSelect, onClose }) {
    const [selectedStore, setSelectedStore] = useState('');
    const [otherStore, setOtherStore] = useState('');
    const [commonStores, setCommonStores] = useState([]);
    const [loading, setLoading] = useState(true);

    const fetchStores = useCallback(async () => {
        setLoading(true);
        try {
            const storesCollection = collection(db, 'stores');
            let querySnapshot = await getDocs(storesCollection);

            if (querySnapshot.empty) {
                const batch = initialStores.map(store => 
                    addDoc(storesCollection, { ...store, createdAt: serverTimestamp() })
                );
                await Promise.all(batch);
                querySnapshot = await getDocs(storesCollection);
            } else {
                // --- Start of new migration logic ---
                const storesFromDb = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const updates = [];

                for (const initialStore of initialStores) {
                    const dbStore = storesFromDb.find(s => s.name === initialStore.name);
                    // If the store exists in DB but the sort order is different from the code
                    if (dbStore && dbStore.sort !== initialStore.sort) {
                        const storeRef = doc(db, 'stores', dbStore.id);
                        updates.push(updateDoc(storeRef, { sort: initialStore.sort }));
                    }
                }

                // If there are any updates to perform
                if (updates.length > 0) {
                    console.log(`Updating sort order for ${updates.length} stores...`);
                    await Promise.all(updates);
                    // Re-fetch the data after updates to ensure we have the latest version
                    querySnapshot = await getDocs(storesCollection);
                    console.log("Store sort order updated successfully.");
                }
                // --- End of new migration logic ---
            }

            const storesList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const uniqueStores = Array.from(new Map(storesList.map(store => [store.name, store])).values());
            const sortedStores = uniqueStores.sort((a, b) => (a.sort || 999) - (b.sort || 999));
            
            setCommonStores(sortedStores);

        } catch (error) {
            console.error("Firebase Error in fetchStores:", error);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchStores();
    }, [fetchStores]);

    const handleSelect = async () => {
        if (selectedStore === '其他' && otherStore.trim() === '') {
            alert('請輸入其他商店名稱');
            return;
        }
        
        let finalStoreName = selectedStore === '其他' ? otherStore.trim() : selectedStore;

        if (selectedStore === '其他') {
            const storesCollection = collection(db, 'stores');
            const q = query(storesCollection, where("name", "==", finalStoreName));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                await addDoc(storesCollection, {
                    name: finalStoreName,
                    sort: 1000, 
                    createdAt: serverTimestamp()
                });
            }
        }
        
        onSelect(finalStoreName);
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-[60] flex items-center justify-center p-4 sm:p-6">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-[calc(100%-80px)] sm:max-w-md flex flex-col max-h-[80vh] h-auto">
                <div className="p-6 pb-4 flex-shrink-0">
                    <div className="flex justify-between items-center mb-4 border-b pb-2">
                        <h3 className={`text-xl font-bold ${theme.text}`}>
                            選擇商店
                        </h3>
                        <button 
                            onClick={onClose}
                            className="p-1 rounded-full text-gray-500 hover:text-gray-900"
                        >
                            <X className="w-6 h-6" />
                        </button>
                    </div>
                    <p className="text-gray-600">請選擇或輸入商店名稱：</p>
                </div>

                {loading ? (
                    <div className="flex-grow flex justify-center items-center">
                        <p className="text-gray-600">正在從資料庫載入商店列表...</p>
                    </div>
                ) : (
                    <div className="flex-grow overflow-y-auto px-6">
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 py-1">
                            {commonStores.map((store) => (
                                <button
                                    key={store.id}
                                    onClick={() => setSelectedStore(store.name)}
                                    className={`p-3 rounded-lg text-center font-medium transition-all ${
                                        selectedStore === store.name 
                                            ? `${themePrimary} text-white shadow-md` 
                                            : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                                    }`}
                                >
                                    {store.name}
                                </button>
                            ))}
                        </div>
                    </div>
                )}

                <div className="p-6 pt-4 flex-shrink-0">
                    {selectedStore === '其他' && (
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-2">請輸入商店名稱：</label>
                            <input
                                type="text"
                                value={otherStore}
                                onChange={(e) => setOtherStore(e.target.value)}
                                placeholder="輸入商店名稱"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"
                                autoFocus
                            />
                        </div>
                    )}

                    <div className="flex justify-end space-x-3 pt-4 border-t">
                        <button
                            onClick={onClose}
                            className="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-lg hover:bg-gray-600 transition-all"
                        >
                            取消
                        </button>
                        <button
                            onClick={handleSelect}
                            disabled={loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')}
                            className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg transition-all ${
                                loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : `${themePrimary} ${themeHover}`
                            }`}
                        >
                            確認選擇
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}

export default StoreSelector;
</file>

<file path="src/AllRecordsPage.js">
import React, { useState, useEffect, useMemo, useRef, useCallback, useLayoutEffect } from 'react';
import { ArrowLeft, Database, TrendingUp, Edit, Trash2, Save, X, CheckCircle, Search } from 'lucide-react';
import { collection, getDocs, query, orderBy, updateDoc, deleteDoc, doc } from 'firebase/firestore';
import { calculateUnitPrice, formatUnitPrice } from './utils/priceCalculations';
import StoreSelector from './StoreSelector';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 圖表組件
const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, productName }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp).sort((a, b) => a.timestamp - b.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間無足夠變化可繪圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <TrendingUp className="mr-1 text-gray-500" size={16} />
                單價走勢 - {productName}
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke="#4F46E5" strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === validRecords.length - 1 ? '#10B981' : '#4F46E5'} title={`${record.displayPrice.toFixed(2)} at ${record.timestamp.toLocaleDateString()}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>{new Date(minTimestamp).toLocaleDateString()}</span>
                <span>{new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

// Fuzzy search function
function fuzzyMatch(pattern, text) {
    const pattern_lower = pattern.toLowerCase();
    const text_lower = text.toLowerCase();
    let patternIdx = 0;
    let textIdx = 0;
    let score = 0;
    let consecutive = 0;
    let firstMatchIndex = -1;

    // Iterate through text to find pattern characters
    while (patternIdx < pattern_lower.length && textIdx < text_lower.length) {
        if (pattern_lower[patternIdx] === text_lower[textIdx]) {
            if (firstMatchIndex === -1) {
                firstMatchIndex = textIdx;
            }
            score += 1;
            // Add bonus for consecutive matches
            if (consecutive > 0) {
                score += consecutive;
            }
            consecutive++;
            patternIdx++;
        } else {
            consecutive = 0;
        }
        textIdx++;
    }

    // If the whole pattern was found
    if (patternIdx === pattern_lower.length) {
        // Add bonus for being a prefix
        if (firstMatchIndex === 0) {
            score += 5;
        }
        // Add bonus for tightness of the match
        const matchDensity = pattern.length / (textIdx - firstMatchIndex);
        score *= (1 + matchDensity);

        return score;
    }

    return 0;
}

// 可滑動的記錄項目
function SwipeableRecord({ children, onEdit, onDelete }) {
    const [translateX, setTranslateX] = useState(0);
    const touchStartX = useRef(0);
    const itemRef = useRef(null);
    const buttonsRef = useRef(null);

    const handleTouchStart = (e) => {
        touchStartX.current = e.touches[0].clientX;
    };

    const handleTouchMove = (e) => {
        const touchCurrentX = e.touches[0].clientX;
        const diff = touchCurrentX - touchStartX.current;
        if (diff < 0) { // 只允許向左滑動
            setTranslateX(Math.max(diff, -160)); // -160 是按鈕寬度的總和
        }
    };

    const handleTouchEnd = () => {
        if (translateX < -80) {
            setTranslateX(-160);
        } else {
            setTranslateX(0);
        }
    };

    useEffect(() => {
        const handleGlobalClick = (e) => {
            if (buttonsRef.current && !buttonsRef.current.contains(e.target)) {
                setTranslateX(0);
            }
        };

        if (translateX !== 0) {
            document.addEventListener('click', handleGlobalClick, true);
        }

        return () => {
            document.removeEventListener('click', handleGlobalClick, true);
        };
    }, [translateX]);

    const handleEdit = () => {
        onEdit();
        setTranslateX(0);
    };

    const handleDelete = () => {
        onDelete();
        setTranslateX(0);
    };

    return (
        <div className="relative overflow-hidden">
            <div ref={buttonsRef} className="absolute top-0 right-0 h-full flex items-center">
                <button onClick={handleEdit} className="bg-blue-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Edit size={20} />
                    <span>編輯</span>
                </button>
                <button onClick={handleDelete} className="bg-red-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Trash2 size={20} />
                    <span>刪除</span>
                </button>
            </div>
            <div
                ref={itemRef}
                className="transition-transform duration-300 ease-in-out"
                style={{ transform: `translateX(${translateX}px)` }}
                onTouchStart={handleTouchStart}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleTouchEnd}
            >
                {children}
            </div>
        </div>
    );
}


// 產品記錄組件
function ProductRecord({ product, records, theme, onEdit, onDelete }) {
    const formattedRecords = records.map(r => ({ ...r, timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp) })).sort((a, b) => b.timestamp - a.timestamp);
    
    const latestRecord = formattedRecords[0];
    if (!latestRecord) return null; // 如果沒有記錄，則不渲染此組件

    const validUnitPrices = formattedRecords.map(r => r.unitPrice).filter(p => !isNaN(p) && p !== undefined && p !== null);
    const lowestUnitPrice = validUnitPrices.length > 0 ? Math.min(...validUnitPrices) : 0;
    const highestUnitPrice = validUnitPrices.length > 0 ? Math.max(...validUnitPrices) : 0;
    const avgUnitPrice = validUnitPrices.length > 0 ? validUnitPrices.reduce((sum, p) => sum + p, 0) / validUnitPrices.length : 0;

    return (
        <div className={`p-4 rounded-xl shadow-lg bg-white border-t-4 ${theme.border} mb-6`}>
            <div className="flex justify-between items-start">
                <div>
                    <h3 className="text-lg font-bold text-gray-800">{product.productName}</h3>
                    <p className="text-sm text-gray-600">條碼: {product.barcodeData}</p>
                    <p className="text-xs text-gray-500">ID: {product.numericalID}</p>
                </div>
                <div className="text-right">
                    {/* 顯示原價和特價信息 */}
                    {latestRecord.specialPrice ? (
                        <div>
                            {latestRecord.originalPrice && (
                                <p className="text-lg text-gray-500 line-through">${latestRecord.originalPrice.toFixed(2)}</p>
                            )}
                            <p className="text-2xl font-bold text-indigo-600">${latestRecord.specialPrice.toFixed(2)}</p>
                            <p className="text-xs text-gray-500">@{formatUnitPrice(latestRecord.unitPrice)}</p>
                        </div>
                    ) : (
                        <p className="text-2xl font-bold text-indigo-600">{formatUnitPrice(latestRecord.unitPrice) === '--' ? (isNaN(latestRecord.price) ? 'N/A' : `$${(latestRecord.price || 0).toFixed(2)}`) : `$${(latestRecord.price || 0).toFixed(2)} @${formatUnitPrice(latestRecord.unitPrice)}`}</p>
                    )}
                    <p className="text-xs text-gray-500">{latestRecord.timestamp.toLocaleDateString()}</p>
                    {/* 顯示數量和單位 */}
                    {latestRecord.quantity && latestRecord.unitType && (
                        <p className="text-xs text-gray-500">數量: {latestRecord.quantity} {latestRecord.unitType}</p>
                    )}
                </div>
            </div>

            <div className="grid grid-cols-3 gap-2 my-3 text-center">
                <div className="bg-green-50 p-2 rounded"><p className="text-xs text-gray-500">最低單價</p><p className="font-bold text-green-600">{isNaN(lowestUnitPrice) ? 'N/A' : `${lowestUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-blue-50 p-2 rounded"><p className="text-xs text-gray-500">平均單價</p><p className="font-bold text-blue-600">{isNaN(avgUnitPrice) ? 'N/A' : `${avgUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-red-50 p-2 rounded"><p className="text-xs text-gray-500">最高單價</p><p className="font-bold text-red-600">{isNaN(highestUnitPrice) ? 'N/A' : `${highestUnitPrice.toFixed(2)}`}</p></div>
            </div>

            <div className="mb-4"><PriceTrendChart records={formattedRecords} productName={product.productName} /></div>

            <div className="mt-4">
                <h4 className="font-semibold text-gray-700 mb-2">價格記錄詳情</h4>
                <div className="space-y-2 max-h-40 overflow-y-auto">
                    {formattedRecords.map((record, index) => (
                        <SwipeableRecord
                            key={index}
                            onEdit={() => onEdit(record)}
                            onDelete={() => onDelete(record)}
                        >
                            <div className="flex justify-between items-center p-2 bg-gray-50 rounded">
                                <div>
                                    {/* 顯示原價和特價信息 */}
                                    {record.specialPrice ? (
                                        <p className="font-medium">
                                            {record.originalPrice && (
                                                <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                            )}
                                            <span className="text-red-600 ml-1">${record.specialPrice.toFixed(2)}</span>
                                            <span className="text-gray-500 ml-1">@{formatUnitPrice(record.unitPrice)}</span>
                                        </p>
                                    ) : (
                                        <p className="font-medium">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</p>
                                    )}
                                    {record.discountDetails && <p className="text-xs text-indigo-600">{record.discountDetails}</p>}
                                    {/* 顯示數量和單位 */}
                                    {record.quantity && record.unitType && (
                                        <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType}</p>
                                    )}
                                </div>
                                <div className="text-right">
                                    <p className="text-xs text-gray-500">{record.storeName || '未標註'}</p>
                                    <p className="text-xs text-gray-500">{record.timestamp.toLocaleDateString()}</p>
                                </div>
                            </div>
                        </SwipeableRecord>
                    ))}
                </div>
            </div>
        </div>
    );
}

// 主組件
function AllRecordsPage({ theme, onBack, db, userId, isAuthReady }) {
    const [allProducts, setAllProducts] = useState([]);
    const [allRecords, setAllRecords] = useState({});
    const [loading, setLoading] = useState(true);
    const [sortOption, setSortOption] = useState('latest'); // latest, name, price
    const [editingRecord, setEditingRecord] = useState(null);
    const [deletingRecord, setDeletingRecord] = useState(null);
    const [successMessage, setSuccessMessage] = useState('');
    const scrollPositionRef = useRef(0); // For scroll restoration
    const [isAfterDelete, setIsAfterDelete] = useState(false); // Signal for scroll restoration
    const [searchQuery, setSearchQuery] = useState('');
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const searchInputRef = useRef(null);
    
    // Edit mode states
    const [isEditMode, setIsEditMode] = useState(false);
    const [selectedItems, setSelectedItems] = useState(new Set());
    const [localProducts, setLocalProducts] = useState([]);
    const [localRecords, setLocalRecords] = useState({});
    // 新增狀態：批量刪除確認對話框
    const [isBulkDeleteConfirmationOpen, setIsBulkDeleteConfirmationOpen] = useState(false);
    // 新增狀態：原始數據快照和衝突解決
    const [originalDataSnapshot, setOriginalDataSnapshot] = useState(null);
    const [isConflictDialogOpen, setIsConflictDialogOpen] = useState(false);

    const fetchData = useCallback(async () => {
        if (!db) return;
        setLoading(true);
        try {
            // 1. Fetch all products
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const productsArray = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 2. Fetch all records
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const recordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // 3. Group records by product ID
            const recordsByProduct = {};
            recordsArray.forEach(record => {
                if (!recordsByProduct[record.numericalID]) {
                    recordsByProduct[record.numericalID] = [];
                }
                recordsByProduct[record.numericalID].push(record);
            });

            setAllProducts(productsArray);
            setAllRecords(recordsByProduct);

        } catch (error) {
            console.error('讀取 Firestore 數據失敗:', error);
            const userMessage = handleFirestoreSaveError(error, "讀取產品數據");
            showUserFriendlyError(userMessage);
        } finally {
            setLoading(false);
        }
    }, [db]);

    useEffect(() => {
        // 只有在 Firebase 已準備好時才執行查詢
        if (!isAuthReady || !userId) {
            // 如果 Firebase 尚未準備好，不應該顯示加載狀態
            // 讓用戶知道需要等待 Firebase 初始化
            return;
        }
        
        // Firebase 已準備好且有 userId，執行數據獲取
        fetchData();
    }, [fetchData, isAuthReady, userId]);

    useEffect(() => {
        if (isSearchOpen && searchInputRef.current) {
            setTimeout(() => searchInputRef.current.focus(), 100); // Shorter delay for responsiveness
        }
    }, [isSearchOpen]);

    useLayoutEffect(() => {
        if (isAfterDelete && !loading) {
            // Use requestAnimationFrame to ensure scroll happens after browser paints
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollPositionRef.current);
                setIsAfterDelete(false); // Reset the signal after scrolling
            });
        }
    }, [loading, isAfterDelete]);

    const filteredProducts = useMemo(() => {
        // Use local data in edit mode, otherwise use Firebase data
        const products = isEditMode ? localProducts : allProducts;
        const records = isEditMode ? localRecords : allRecords;

        if (searchQuery.trim() === '') {
            // No search query, just sort the products
            return [...products].sort((a, b) => {
                const recordsA = records[a.numericalID] || [];
                const recordsB = records[b.numericalID] || [];
                
                if (sortOption === 'name') {
                    return a.productName.localeCompare(b.productName);
                }
                
                const latestRecordA = recordsA[0];
                const latestRecordB = recordsB[0];

                if (sortOption === 'price') {
                    const priceA = latestRecordA?.price || -1;
                    const priceB = latestRecordB?.price || -1;
                    return priceB - priceA;
                }

                // Default to 'latest'
                const timeA = latestRecordA?.timestamp?.toDate ? latestRecordA.timestamp.toDate().getTime() : 0;
                const timeB = latestRecordB?.timestamp?.toDate ? latestRecordB.timestamp.toDate().getTime() : 0;
                return timeB - timeA;
            });
        }

        // Fuzzy search logic
        const scoredProducts = products
            .map(product => ({
                product,
                score: fuzzyMatch(searchQuery, product.productName)
            }))
            .filter(item => item.score > 0)
            .sort((a, b) => b.score - a.score);
        
        return scoredProducts.map(item => item.product);

    }, [allProducts, allRecords, sortOption, searchQuery, isEditMode, localProducts, localRecords]);

    const showSuccessMessage = (message) => {
        setSuccessMessage(message);
        setTimeout(() => {
            setSuccessMessage('');
        }, 2000);
    };

    const handleEdit = (record) => {
        setEditingRecord(record);
    };

    const handleDelete = (record) => {
        scrollPositionRef.current = window.scrollY; // Save scroll position
        setDeletingRecord(record);
    };

    // New function to handle checkbox selection
    const handleItemSelect = (productId) => {
        setSelectedItems(prev => {
            const newSet = new Set(prev);
            if (newSet.has(productId)) {
                newSet.delete(productId);
            } else {
                newSet.add(productId);
            }
            return newSet;
        });
    };

    // 修改批量刪除功能以使用確認對話框
    const handleBulkDeleteClick = () => {
        if (selectedItems.size === 0) return;
        setIsBulkDeleteConfirmationOpen(true);
    };

    // New function to delete selected items
    const deleteSelectedItems = async () => {
        if (selectedItems.size === 0) return;
        
        try {
            // Update local state
            setLocalProducts(prev => prev.filter(product => !selectedItems.has(product.numericalID)));
            setLocalRecords(prev => {
                const newRecords = {...prev};
                selectedItems.forEach(productId => {
                    delete newRecords[productId];
                });
                return newRecords;
            });
            
            // Clear selection
            setSelectedItems(new Set());
            setIsBulkDeleteConfirmationOpen(false);
        } catch (error) {
            console.error("Error deleting selected items:", error);
            const userMessage = handleFirestoreSaveError(error, "批量刪除產品");
            showUserFriendlyError(userMessage);
        }
    };

    // 新增函數：檢查衝突並退出編輯模式
    const checkForConflictsAndExit = async () => {
        if (!db || !originalDataSnapshot) return;
        
        try {
            // 獲取當前 Firebase 數據
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const currentProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 將記錄按產品 ID 分組
            const currentRecords = {};
            currentRecordsArray.forEach(record => {
                if (!currentRecords[record.numericalID]) {
                    currentRecords[record.numericalID] = [];
                }
                currentRecords[record.numericalID].push(record);
            });
            
            // 比較當前數據與原始快照
            const hasConflicts = checkForDataConflicts(originalDataSnapshot, {products: currentProducts, records: currentRecords});
            
            if (hasConflicts) {
                // 如果有衝突，顯示衝突解決對話框
                setIsConflictDialogOpen(true);
            } else {
                // 如果沒有衝突，直接退出編輯模式
                await exitEditMode(currentProducts, currentRecords);
            }
        } catch (error) {
            console.error("檢查數據衝突時出錯:", error);
            const userMessage = handleFirestoreSaveError(error, "檢查數據衝突");
            showUserFriendlyError(userMessage);
            // 出錯時仍然退出編輯模式
            await exitEditMode();
        }
    };
    
    // 新增函數：檢查數據衝突
    const checkForDataConflicts = (original, current) => {
        // 比較產品數量
        if (original.products.length !== current.products.length) {
            return true;
        }
        
        // 比較記錄數量
        const originalRecordCount = Object.values(original.records).reduce((count, records) => count + records.length, 0);
        const currentRecordCount = Object.values(current.records).reduce((count, records) => count + records.length, 0);
        
        if (originalRecordCount !== currentRecordCount) {
            return true;
        }
        
        // 更詳細的比較可以在此處添加
        // 為了簡化，我們只檢查數量變化
        
        return false;
    };
    
    // 修改 exitEditMode 函數以接受當前數據
    const exitEditMode = async (currentProducts = null, currentRecords = null) => {
        if (!db) return;
        
        try {
            // 如果沒有提供當前數據，則獲取最新數據
            let latestProducts = currentProducts;
            let latestRecords = currentRecords;
            
            if (!latestProducts || !latestRecords) {
                const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
                const productsSnap = await getDocs(productsQuery);
                latestProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
                const recordsSnap = await getDocs(recordsQuery);
                const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 將記錄按產品 ID 分組
                latestRecords = {};
                currentRecordsArray.forEach(record => {
                    if (!latestRecords[record.numericalID]) {
                        latestRecords[record.numericalID] = [];
                    }
                    latestRecords[record.numericalID].push(record);
                });
            }
            
            // 計算需要從 Firebase 刪除的產品
            const productsToDelete = latestProducts.filter(product => 
                !localProducts.some(localProduct => localProduct.numericalID === product.numericalID)
            );
            
            // 刪除 Firebase 中的產品及其記錄
            for (const product of productsToDelete) {
                // 刪除所有記錄
                const productRecords = latestRecords[product.numericalID] || [];
                for (const record of productRecords) {
                    const recordRef = doc(db, "priceRecords", record.id);
                    await deleteDoc(recordRef);
                }
            }
            
            // 計算需要從 Firebase 刪除的記錄（編輯模式下刪除的記錄）
            const recordsToDelete = [];
            for (const [productId, records] of Object.entries(latestRecords)) {
                const localRecordsForProduct = localRecords[productId] || [];
                // 找出在原始記錄中存在但在本地記錄中不存在的記錄
                const deletedRecords = records.filter(record => 
                    !localRecordsForProduct.some(localRecord => localRecord.id === record.id)
                );
                recordsToDelete.push(...deletedRecords);
            }
            
            // 刪除 Firebase 中的記錄
            for (const record of recordsToDelete) {
                const recordRef = doc(db, "priceRecords", record.id);
                await deleteDoc(recordRef);
            }
            
            // 重新從 Firebase 獲取數據
            await fetchData();
            setIsEditMode(false);
            setSelectedItems(new Set());
            setOriginalDataSnapshot(null);

        } catch (error) {
            console.error("Error syncing with Firebase:", error);
            const userMessage = handleFirestoreSaveError(error, "同步編輯數據");
            showUserFriendlyError(userMessage);
        }
    };

    const handleSaveEdit = async (updatedRecord) => {
        if (!db) return;
        try {
            const recordRef = doc(db, "priceRecords", updatedRecord.id);
            // 更新所有字段，不僅僅是價格和折扣詳情
            await updateDoc(recordRef, {
                price: updatedRecord.price,
                discountDetails: updatedRecord.discountDetails,
                productName: updatedRecord.productName,
                storeName: updatedRecord.storeName,
                quantity: updatedRecord.quantity,
                unitType: updatedRecord.unitType,
                unitPrice: updatedRecord.unitPrice,
                originalPrice: updatedRecord.originalPrice,
                specialPrice: updatedRecord.specialPrice
            });
            
            // 在編輯模式下，更新本地狀態而不是重新獲取所有數據
            if (isEditMode) {
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    
                    // 確保更新的記錄所屬的產品在 localRecords 中存在
                    if (!newRecords[updatedRecord.numericalID]) {
                        newRecords[updatedRecord.numericalID] = [];
                    }
                    
                    // 更新記錄
                    Object.keys(newRecords).forEach(productId => {
                        if (newRecords[productId]) {
                            newRecords[productId] = newRecords[productId].map(record => 
                                record.id === updatedRecord.id ? updatedRecord : record
                            ).filter(record => record !== undefined); // 過濾掉可能的 undefined 值
                        }
                    });
                    
                    // 確保當前更新的記錄存在於其對應的產品記錄中
                    if (!newRecords[updatedRecord.numericalID].some(record => record.id === updatedRecord.id)) {
                        newRecords[updatedRecord.numericalID].push(updatedRecord);
                    }
                    
                    return newRecords;
                });
                
                // 同時更新本地產品列表中的產品名稱
                setLocalProducts(prev => 
                    prev.map(product => 
                        product.numericalID === updatedRecord.numericalID 
                            ? {...product, productName: updatedRecord.productName} 
                            : product
                    )
                );
            } else {
                await fetchData(); // 非編輯模式下重新獲取數據以更新UI
            }
            
            showSuccessMessage('記錄已成功更新');
        } catch (error) {
            console.error("更新記錄失敗:", error);
            const userMessage = handleFirestoreSaveError(error, "更新價格記錄");
            showUserFriendlyError(userMessage);
        }
        setEditingRecord(null);
    };

    // 新增函數：處理衝突解決
    const handleConflictResolution = async (resolutionType) => {
        setIsConflictDialogOpen(false);
        
        switch (resolutionType) {
            case 'local':
                // 保留本地更改，直接退出編輯模式
                await exitEditMode();
                break;
            case 'remote':
                // 保留遠程數據，重新獲取最新數據並退出
                await fetchData();
                setIsEditMode(false);
                setSelectedItems(new Set());
                setOriginalDataSnapshot(null);

                break;
            case 'merge':
                // 手動合併，重新獲取數據並保持編輯模式
                await fetchData();
                setLocalProducts([...allProducts]);
                setLocalRecords({...allRecords});
                // 保持編輯模式開啟，讓用戶繼續編輯
                setOriginalDataSnapshot({
                    products: [...allProducts],
                    records: {...allRecords},
                    timestamp: Date.now()
                });

                break;
            default:
                // 默認情況下直接退出編輯模式
                await exitEditMode();
        }
    };

    const confirmDelete = async () => {
        if (!db || !deletingRecord) return;
        
        // 在編輯模式下，我們只需要更新本地狀態，不需要重新整理畫面
        if (isEditMode) {
            try {
                // 更新本地狀態而不是調用 Firebase
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    if (newRecords[deletingRecord.numericalID]) {
                        newRecords[deletingRecord.numericalID] = newRecords[deletingRecord.numericalID].filter(
                            record => record.id !== deletingRecord.id
                        );
                    }
                    return newRecords;
                });
                
                // 顯示成功消息
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            } finally {
                setDeletingRecord(null);
            }
        } else {
            // 非編輯模式下保持原有行為
            setIsAfterDelete(true); // Signal that the next data fetch is after a delete
            try {
                const recordRef = doc(db, "priceRecords", deletingRecord.id);
                await deleteDoc(recordRef);
                await fetchData(); // 重新獲取數據以更新UI
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            }
            setDeletingRecord(null);
        }
    };

    const handleSearchToggle = () => {
        if (isSearchOpen) {
            setSearchQuery('');
        }
        setIsSearchOpen(!isSearchOpen);
    };

    if (loading) {
        return (
            <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
                <div className="max-w-4xl mx-auto">
                    <div className="flex items-center mb-6">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800">所有記錄</h1>
                    </div>
                    <div className="text-center py-10">
                        {!isAuthReady ? (
                            <p>正在初始化雲端服務，請稍候...</p>
                        ) : !userId ? (
                            <p>正在獲取用戶信息，請稍候...</p>
                        ) : (
                            <p>正在從雲端加載數據...</p>
                        )}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
            <div className="max-w-4xl mx-auto pb-28"> {/* Added pb-28 for floating button */}
                <SuccessMessage message={successMessage} />
                <div className="flex flex-col sm:flex-row sm:items-center justify-between mb-6">
                    <div className="flex items-center mb-4 sm:mb-0">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800 flex items-center"><Database className="mr-2" />所有記錄</h1>
                    </div>
                    <div className="flex items-center">
                        <label className="mr-2 text-gray-700">排序:</label>
                        <select value={sortOption} onChange={(e) => setSortOption(e.target.value)} className="border border-gray-300 rounded p-2 mr-2">
                            <option value="latest">最新記錄</option>
                            <option value="name">產品名稱</option>
                            <option value="price">最新價格</option>
                        </select>
                        <button 
                            onClick={() => {
                                if (!isEditMode) {
                                    // Enter edit mode - copy current data to local state
                                    setLocalProducts([...allProducts]);
                                    setLocalRecords({...allRecords});
                                    // 保存原始數據快照和時間戳
                                    setOriginalDataSnapshot({
                                        products: [...allProducts],
                                        records: {...allRecords},
                                        timestamp: Date.now()
                                    });
                                } else {
                                    // Exit edit mode - 檢查數據版本衝突
                                    checkForConflictsAndExit();
                                }
                                setIsEditMode(!isEditMode);
                                setSelectedItems(new Set());
                            }}
                            className={`px-3 py-2 rounded text-white text-sm ${
                                isEditMode ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'
                            }`}
                        >
                            {isEditMode ? '退出編輯模式' : '編輯模式'}
                        </button>
                    </div>
                </div>

                {/* Floating Delete Button - 修改為固定位置 */}
                {isEditMode && selectedItems.size > 0 && (
                    <div className="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-4 shadow-lg z-50 flex items-center"
                         style={{bottom: '6rem'}}>
                        <button 
                            onClick={handleBulkDeleteClick}
                            className="flex items-center"
                        >
                            <Trash2 size={20} className="mr-2" />
                            刪除選取項目 ({selectedItems.size})
                        </button>
                    </div>
                )}

                {/* Floating Exit Edit Mode Button - 修改為固定位置 */}
                {isEditMode && (
                    <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white rounded-full p-4 shadow-lg z-50">
                        <button 
                            onClick={checkForConflictsAndExit}
                            className="flex items-center"
                        >
                            <X size={20} className="mr-2" />
                            退出編輯模式
                        </button>
                    </div>
                )}

                {filteredProducts.length === 0 ? (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <Database size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">{searchQuery ? '找不到結果' : '暫無記錄'}</h3>
                        <p className="text-gray-500">{searchQuery ? `找不到符合 "${searchQuery}" 的產品` : '還沒有任何產品和價格記錄'}</p>
                    </div>
                ) : (
                    <div>
                        <div className="mb-4 p-4 bg-white rounded-lg shadow">
                            <div className="flex justify-between">
                                <p className="text-gray-700">總共 <span className="font-bold">{filteredProducts.length}</span> 個產品</p>
                                <p className="text-gray-700">總共 <span className="font-bold">{Object.values(allRecords).flat().length}</span> 條記錄</p>
                            </div>
                        </div>
                        {filteredProducts.map(product => {
                            // 修復：確保 records 始終有默認值
                            const records = isEditMode ? (localRecords[product.numericalID] || []) : (allRecords[product.numericalID] || []);
                            // 修改：即使沒有記錄也顯示產品卡片，但只在編輯模式下
                            if (records.length === 0 && !isEditMode) return null;
                            return (
                                // 修改：為選中的項目添加增強的視覺反饋
                                <div key={product.numericalID} className={`relative transition-all duration-200 ${isEditMode && selectedItems.has(product.numericalID) ? 'bg-blue-50 border-2 border-blue-500 rounded-lg' : ''}`}>
                                    {isEditMode && (
                                        <div className="absolute top-4 left-4 z-10">
                                            <input
                                                type="checkbox"
                                                checked={selectedItems.has(product.numericalID)}
                                                onChange={() => handleItemSelect(product.numericalID)}
                                                className="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                                            />
                                        </div>
                                    )}
                                    <div className={isEditMode ? "pl-12" : ""}>
                                        <ProductRecord 
                                            product={product} 
                                            records={records} 
                                            theme={theme} 
                                            onEdit={handleEdit} 
                                            onDelete={handleDelete} 
                                        />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}

                {editingRecord && (
                    <EditModal
                        record={editingRecord}
                        onClose={() => setEditingRecord(null)}
                        onSave={handleSaveEdit}
                    />
                )}

                {deletingRecord && (
                    <DeleteConfirmation
                        record={deletingRecord}
                        onClose={() => setDeletingRecord(null)}
                        onConfirm={confirmDelete}
                    />
                )}

                {/* 新增批量刪除確認對話框 */}
                {isBulkDeleteConfirmationOpen && (
                    <BulkDeleteConfirmation
                        count={selectedItems.size}
                        onClose={() => setIsBulkDeleteConfirmationOpen(false)}
                        onConfirm={deleteSelectedItems}
                    />
                )}

                {/* 新增衝突解決對話框 */}
                {isConflictDialogOpen && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                            <h2 className="text-xl font-bold mb-4">檢測到數據衝突</h2>
                            <p className="mb-4">在您編輯期間，其他用戶修改了部分數據。請選擇如何解決衝突：</p>
                            
                            <div className="mb-6 p-4 bg-yellow-50 rounded-lg">
                                <h3 className="font-semibold text-yellow-800 mb-2">衝突詳情：</h3>
                                <ul className="list-disc pl-5 text-sm text-yellow-700">
                                    <li>數據可能已被人修改</li>
                                    <li>您的更改可能與其他用戶的更改衝突</li>
                                </ul>
                            </div>
                            
                            <div className="space-y-3">
                                <button 
                                    onClick={() => handleConflictResolution('local')}
                                    className="w-full p-3 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                                >
                                    保留我的更改
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('remote')}
                                    className="w-full p-3 bg-green-500 text-white rounded-md hover:bg-green-600"
                                >
                                    保留最新數據
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('merge')}
                                    className="w-full p-3 bg-purple-500 text-white rounded-md hover:bg-purple-600"
                                >
                                    手動合併（推薦）
                                </button>
                            </div>
                            
                            <div className="mt-6 flex justify-end">
                                <button 
                                    onClick={() => setIsConflictDialogOpen(false)}
                                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                                >
                                    取消
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- START: Revamped Search Component --- */}
                <div className="fixed top-6 right-6 z-30">
                    <div 
                        className={`flex items-center justify-end bg-white rounded-full shadow-xl transition-all duration-300 ease-in-out overflow-hidden ${isSearchOpen ? 'w-80' : 'w-16 h-16'}`}
                    >
                        <Search className={`absolute left-5 top-1/2 -translate-y-1/2 text-gray-400 transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`} size={22} />
                        <input
                            ref={searchInputRef}
                            type="text"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="輸入品名進行模糊搜尋..."
                            className={`w-full h-16 pl-14 pr-20 bg-transparent border-none rounded-full outline-none text-lg transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`}
                            style={{pointerEvents: isSearchOpen ? 'auto' : 'none'}}
                        />
                        <button
                            onClick={handleSearchToggle}
                            className="absolute right-0 top-0 w-16 h-16 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 flex items-center justify-center"
                            aria-label={isSearchOpen ? "關閉搜尋" : "開啟搜尋"}
                        >
                            {isSearchOpen ? <X size={28} /> : <Search size={28} />}
                        </button>
                    </div>
                </div>
                {/* --- END: Revamped Search Component --- */}
            </div>
        </div>
    );
}

function EditModal({ record, onClose, onSave }) {
    const [price, setPrice] = useState(record.price);
    const [quantity, setQuantity] = useState(record.quantity || '');
    const [unitType, setUnitType] = useState(record.unitType || 'pcs');
    const [discount, setDiscount] = useState(record.discountDetails || '');
    const [originalPrice, setOriginalPrice] = useState(record.originalPrice || '');
    const [specialPrice, setSpecialPrice] = useState(record.specialPrice || '');
    const [productName, setProductName] = useState(record.productName || '');
    const [storeName, setStoreName] = useState(record.storeName || '');
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);

    const handleSave = () => {
        const newUnitPrice = calculateUnitPrice(price, quantity, unitType);
        if (newUnitPrice === null) {
            alert("請輸入有效的價格和數量。");
            return;
        }
        onSave({ 
            ...record, 
            price: parseFloat(price),
            quantity: parseFloat(quantity),
            unitType: unitType,
            unitPrice: newUnitPrice,
            discountDetails: discount,
            originalPrice: originalPrice ? parseFloat(originalPrice) : null,
            specialPrice: specialPrice ? parseFloat(specialPrice) : null,
            productName: productName,
            storeName: storeName
        });
    };

    const currentUnitPrice = calculateUnitPrice(price, quantity, unitType);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 overflow-hidden">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">編輯記錄</h2>
                <div className="space-y-3">
                    {/* 產品名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">產品名稱</label>
                        <input
                            type="text"
                            value={productName}
                            onChange={(e) => setProductName(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 商店名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">商店名稱</label>
                        <div className="mt-1 flex">
                            <input
                                type="text"
                                value={storeName}
                                onChange={(e) => setStoreName(e.target.value)}
                                className="block flex-grow border border-gray-300 rounded-l-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                placeholder="點擊選擇商店或手動輸入"
                                readOnly
                            />
                            <button 
                                onClick={() => setIsStoreSelectorOpen(true)}
                                className="bg-indigo-600 text-white px-4 py-2 rounded-r-md hover:bg-indigo-700"
                            >
                                選擇
                            </button>
                        </div>
                    </div>
                    
                    {/* 原價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">原價 ($)</label>
                        <input
                            type="number"
                            value={originalPrice}
                            onChange={(e) => setOriginalPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 特價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">特價 ($)</label>
                        <input
                            type="number"
                            value={specialPrice}
                            onChange={(e) => setSpecialPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 總價輸入（實際支付價格） */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">總價 ($)</label>
                        <input
                            type="number"
                            value={price}
                            onChange={(e) => setPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    <div>
                        <label className="block text-sm font-medium text-gray-700">數量</label>
                        <input
                            type="number"
                            value={quantity}
                            onChange={(e) => setQuantity(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單位</label>
                        <select
                            value={unitType}
                            onChange={(e) => setUnitType(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        >
                            <option value="ml">ml (毫升)</option>
                            <option value="g">g (克)</option>
                            <option value="pcs">pcs (個/包/支/條)</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單價 (自動計算)</label>
                        <input
                            type="text"
                            value={currentUnitPrice === null ? 'N/A' : currentUnitPrice.toFixed(2)}
                            readOnly
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-gray-100"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">折扣詳情</label>
                        <input
                            type="text"
                            value={discount}
                            onChange={(e) => setDiscount(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                </div>
                <div className="mt-4 flex justify-between">
                    <button onClick={onClose} className="flex-1 mr-2 items-center bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 flex justify-center">
                        <X size={18} className="mr-1" />
                        取消
                    </button>
                    <button onClick={handleSave} className="flex-1 ml-2 items-center bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 flex justify-center">
                        <Save size={18} className="mr-1" />
                        保存
                    </button>
                </div>
            </div>
            
            {isStoreSelectorOpen && (
                <StoreSelector 
                    onSelect={(selectedStore) => {
                        setStoreName(selectedStore);
                        setIsStoreSelectorOpen(false);
                    }}
                    onClose={() => setIsStoreSelectorOpen(false)}
                    theme={{ primary: 'bg-indigo-600', hover: 'hover:bg-indigo-700', text: 'text-indigo-600' }}
                />
            )}
        </div>
    );
}

function DeleteConfirmation({ record, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p>您確定要刪除這條價格為 ${record.price.toFixed(2)} 的記錄嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}

function SuccessMessage({ message }) {
    if (!message) return null;

    return (
        <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center z-50">
            <CheckCircle size={20} className="mr-2" />
            <span>{message}</span>
        </div>
    );
}



// 新增批量刪除確認對話框組件
function BulkDeleteConfirmation({ count, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認批量刪除</h2>
                <p>您確定要刪除選中的 {count} 個產品項目嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}



export default AllRecordsPage;
</file>

<file path="src/OcrQueuePage.js">
import React, { useState, useEffect, useCallback } from 'react';
import { ArrowLeft, Trash2, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { db } from './firebase-config.js';
import { doc, setDoc, addDoc, collection, serverTimestamp, getDoc, query, where, getDocs } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 計算 localStorage 使用量的函數
function getLocalStorageUsage() {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += (localStorage[key].length + key.length) * 2; // 每個字符佔用 2 bytes
    }
  }
  const used = (total / 1024).toFixed(2); // 轉換為 KB
  const quota = 5120; // 大多数瀏覽器的 localStorage 限制約為 5MB
  const percentage = ((used / quota) * 100).toFixed(2);
  
  return {
    used: used,
    quota: quota,
    percentage: percentage
  };
}

// 刪除確認對話框組件
function DeleteConfirmation({ card, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p className="mb-4">您確定要刪除此待辨識項目嗎？</p>
                <p className="mb-4 font-semibold text-gray-800">{card.productName || '未命名產品'}</p>
                <div className="flex justify-end space-x-3">
                    <button 
                        onClick={onClose}
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                    >
                        取消
                    </button>
                    <button 
                        onClick={onConfirm}
                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                    >
                        確認刪除
                    </button>
                </div>
            </div>
        </div>
    );
}

function OcrQueuePage({ theme, onBack, pendingOcrCards, onRemoveCard, onStoreSelect, 
    isStoreSelectorOpen, onStoreSelectCallback, onCloseStoreSelector }) {
    const [queueStats, setQueueStats] = useState({
        total: 0,
        oldest: null,
        newest: null
    });
    
    // 新增狀態：localStorage 使用量
    const [localStorageUsage, setLocalStorageUsage] = useState({
        used: 0,
        quota: 5120,
        percentage: 0
    });
    
    // 新增狀態：刪除確認對話框
    const [deleteConfirmation, setDeleteConfirmation] = useState(null);
    
    // 新增狀態：正在編輯的卡片
    // 移除 editingCard 狀態，因為現在由父組件控制
    // const [editingCard, setEditingCard] = useState(null);
    
    // 新增狀態：比價結果
    const [priceComparisonResults, setPriceComparisonResults] = useState({});

    useEffect(() => {
        if (pendingOcrCards.length > 0) {
            const timestamps = pendingOcrCards.map(card => card.timestamp);
            setQueueStats({
                total: pendingOcrCards.length,
                oldest: Math.min(...timestamps),
                newest: Math.max(...timestamps)
            });
        } else {
            setQueueStats({
                total: 0,
                oldest: null,
                newest: null
            });
        }
        
        // 更新 localStorage 使用量
        setLocalStorageUsage(getLocalStorageUsage());
    }, [pendingOcrCards]);

    const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleString('zh-TW');
    };

    const calculateDuration = (timestamp) => {
        const now = Date.now();
        const diffMs = now - timestamp;
        const diffSecs = Math.floor(diffMs / 1000);
        const diffMins = Math.floor(diffSecs / 60);
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            return `${diffHours}小時前`;
        } else if (diffMins > 0) {
            return `${diffMins}分鐘前`;
        } else {
            return `${diffSecs}秒前`;
        }
    };

    // 處理刪除操作
    const handleDeleteClick = (card) => {
        setDeleteConfirmation(card);
    };

    // 確認刪除
    const confirmDelete = () => {
        if (deleteConfirmation) {
            onRemoveCard(deleteConfirmation.id);
            setDeleteConfirmation(null);
            // 刪除後更新 localStorage 使用量
            setTimeout(() => {
                setLocalStorageUsage(getLocalStorageUsage());
            }, 100);
        }
    };

    // 取消刪除
    const cancelDelete = () => {
        setDeleteConfirmation(null);
    };

    // 處理儲存操作 - 檢查商店名稱
    const handleSaveClick = async (card) => {
        // 檢查商店名稱是否為空白
        if (!card.storeName || card.storeName.trim() === '') {
            // 如果商店名稱為空白，顯示商店選擇器
            onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
        } else {
            // 如果商店名稱不為空白，直接儲存（不再彈出確認對話框）
            try {
                // 儲存到 Firebase
                await saveOcrCardToFirebase(card);
                
                // 從待辨識序列中移除
                onRemoveCard(card.id);
                
                // 儲存後更新 localStorage 使用量
                setTimeout(() => {
                    setLocalStorageUsage(getLocalStorageUsage());
                }, 100);
                
                // 儲存成功時不顯示任何訊息
            } catch (error) {
                console.error("儲存失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "儲存待辨識卡片");
                showUserFriendlyError(userMessage);
            }
        }
    };

    // 處理卡片欄位變更
    const handleCardChange = (cardId, field, value) => {
        const updatedCards = pendingOcrCards.map(card => 
            card.id === cardId ? { ...card, [field]: value } : card
        );
        onStoreSelect(updatedCards);
        
        // 當價格相關欄位變更時，重新計算比價結果
        if (field === 'extractedPrice' || field === 'specialPrice' || field === 'originalPrice' || field === 'quantity' || field === 'unitType') {
            // 延遲一點時間再重新計算，確保狀態已更新
            setTimeout(() => {
                const fetchPriceComparisonResults = async () => {
                    const results = {};
                    for (const card of updatedCards) {
                        const result = await checkIfBestPrice(card, updatedCards);
                        results[card.id] = result;
                    }
                    setPriceComparisonResults(results);
                };
                
                fetchPriceComparisonResults();
            }, 0);
        }
    };

    // 處理商店欄位點擊
    const handleStoreClick = (card) => {
        // 阻止默认行为，防止移动设备上弹出键盘
        onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
    };

    // 儲存 OCR 卡片到 Firebase
    const saveOcrCardToFirebase = async (card) => {
        // 生成產品 ID
        const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
        const priceValue = parseFloat(finalPrice);
        
        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
        
        // 儲存產品資訊
        const productRef = doc(db, "products", numericalID.toString());
        const productSnap = await getDoc(productRef);
        if (!productSnap.exists()) {
            await setDoc(productRef, {
                numericalID,
                barcodeData: card.scannedBarcode,
                productName: card.productName,
                createdAt: serverTimestamp(),
                lastUpdatedBy: "ocr-queue", // 標記為來自 OCR 隊列
            });
        }
        
        // 儲存價格記錄
        const priceRecord = {
            numericalID,
            productName: card.productName,
            storeName: card.storeName,
            price: priceValue, // 總價
            quantity: parseFloat(card.quantity),
            unitType: card.unitType,
            unitPrice: calculatedUnitPrice, // 單價
            discountDetails: card.discountDetails || '',
            timestamp: serverTimestamp(),
            recordedBy: "ocr-queue", // 標記為來自 OCR 隊列
            // 保存原價和特價信息（如果有的話）
            originalPrice: card.originalPrice ? parseFloat(card.originalPrice) : null,
            specialPrice: card.specialPrice ? parseFloat(card.specialPrice) : null
        };
        
        await addDoc(collection(db, "priceRecords"), priceRecord);
    };

    // 生成產品 ID 的函數
    function generateProductId(barcode, productName, storeName) {
        function djb2Hash(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i);
            }
            return hash >>> 0;
        }
        
        if (barcode) {
            return djb2Hash(barcode).toString();
        } else {
            // Combine productName and storeName to create a unique ID for products without barcodes
            return djb2Hash(`${productName}-${storeName}`).toString();
        }
    }

    // 新增函數：檢查價格是否為歷史最低（包含待辨識序列中的卡片）
    const checkIfBestPrice = useCallback(async (card, allCards) => {
        try {
            // 生成產品 ID
            const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
            
            if (!numericalID) return null;
            
            // 使用新的價格計算函數來確定最終價格
            const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
            const priceValue = parseFloat(finalPrice);
            
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
            
            if (calculatedUnitPrice === null) return null;
            
            // 查詢 Firebase 中該產品的所有價格記錄
            const recordsQuery = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID)
            );
            
            const recordsSnap = await getDocs(recordsQuery);
            const records = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 準備所有記錄以進行比較（包括當前記錄和待辨識序列中的相同產品）
            let allRecordsForCompare = [...records, { 
                unitPrice: calculatedUnitPrice,
                timestamp: new Date()
            }];
            
            // 添加待辨識序列中相同產品的卡片（排除當前卡片）
            const sameProductCards = allCards.filter(c => 
                c.id !== card.id && 
                generateProductId(c.scannedBarcode, c.productName, c.storeName) === numericalID
            );
            
            // 將相同產品的卡片添加到比較列表中
            sameProductCards.forEach(c => {
                const cardFinalPrice = calculateFinalPrice(c.extractedPrice, c.specialPrice);
                const cardPriceValue = parseFloat(cardFinalPrice);
                const cardUnitPrice = calculateUnitPrice(cardPriceValue, c.quantity, c.unitType);
                
                if (cardUnitPrice !== null) {
                    allRecordsForCompare.push({
                        unitPrice: cardUnitPrice,
                        timestamp: new Date(c.id) // 使用卡片 ID 作為時間戳
                    });
                }
            });

            // 如果沒有歷史記錄，則當前價格就是最低價
            if (allRecordsForCompare.length <= 1) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            }
            
            // 使用與主頁面相同的比價邏輯
            const bestDeal = allRecordsForCompare.reduce((best, cur) => {
                const curUnitPrice = cur.unitPrice !== undefined && cur.unitPrice !== null ? cur.unitPrice : Infinity;
                const bestUnitPrice = best.unitPrice !== undefined && best.unitPrice !== null ? best.unitPrice : Infinity;
                return curUnitPrice < bestUnitPrice ? cur : best;
            });

            const isBest = calculatedUnitPrice <= (bestDeal.unitPrice !== undefined && bestDeal.unitPrice !== null ? bestDeal.unitPrice : Infinity);
            
            if (isBest) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            } else {
                return { isBest: false, message: "非歷史最低價", backgroundColor: "bg-yellow-100" };
            }
        } catch (error) {
            console.error("比價檢查失敗:", error);
            return null;
        }
    }, []);

    // 當待辨識卡片列表改變時，重新計算比價結果
    useEffect(() => {
        const fetchPriceComparisonResults = async () => {
            const results = {};
            for (const card of pendingOcrCards) {
                const result = await checkIfBestPrice(card, pendingOcrCards);
                results[card.id] = result;
            }
            setPriceComparisonResults(results);
        };
        
        if (pendingOcrCards.length > 0) {
            fetchPriceComparisonResults();
        } else {
            setPriceComparisonResults({});
        }
    }, [pendingOcrCards, checkIfBestPrice]);

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${theme.bg}`}>
            <div className="max-w-2xl mx-auto">
                <div className="flex items-center mb-6 border-b pb-4">
                    <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4">
                        <ArrowLeft className="mr-1" size={20} />返回
                    </button>
                    <h1 className={`text-2xl font-bold ${theme.text} flex items-center`}>
                        <Clock className="w-6 h-6 mr-2" />待辨識序列管理
                    </h1>
                </div>

                {queueStats.total > 0 ? (
                    <div className="mb-6 p-4 bg-white rounded-lg shadow">
                        <h2 className="text-lg font-semibold mb-3">序列統計</h2>
                        {/* 改為橫式條列呈現 */}
                        <div className="flex flex-wrap gap-4">
                            <div className="flex items-center">
                                <div className="bg-blue-100 p-2 rounded-full mr-2">
                                    <span className="text-blue-600 font-bold">{queueStats.total}</span>
                                </div>
                                <span className="text-gray-600">總數</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-green-100 p-2 rounded-full mr-2">
                                    <span className="text-green-600 font-bold">{queueStats.oldest ? formatTime(queueStats.oldest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最早</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-purple-100 p-2 rounded-full mr-2">
                                    <span className="text-purple-600 font-bold">{queueStats.newest ? formatTime(queueStats.newest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最新</span>
                            </div>
                        </div>
                        
                        {/* localStorage 使用量顯示 */}
                        <div className="mt-4 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                ) : (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <AlertCircle size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">無待辨識項目</h3>
                        <p className="text-gray-500">目前沒有任何待確認的辨識卡片</p>
                        
                        {/* localStorage 使用量顯示（即使沒有項目也顯示） */}
                        <div className="mt-6 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                )}

                <div className="space-y-4">
                    {pendingOcrCards.map((card) => (
                        <div 
                            key={card.id} 
                            className={`bg-white p-4 rounded-lg shadow border-4 relative ${
                                priceComparisonResults[card.id]?.isBest 
                                    ? 'border-green-500' 
                                    : 'border-yellow-500'
                            }`}
                        >
                            <div className="flex justify-between items-start">
                                <div className="flex-1">
                                    {/* 將比價結果移到卡片頂部 */}
                                    {priceComparisonResults[card.id] && (
                                        <div className={`mb-3 p-2 rounded text-center text-base font-bold ${
                                            priceComparisonResults[card.id].isBest 
                                                ? 'bg-green-500 text-white' 
                                                : 'bg-yellow-500 text-pink-800'
                                        }`}>
                                            {priceComparisonResults[card.id].message}
                                        </div>
                                    )}
                                    
                                    <input
                                        type="text"
                                        value={card.productName || ''}
                                        onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                        className="font-bold text-lg text-gray-800 w-full p-1 mb-2 border-b border-gray-300 focus:border-blue-500 focus:outline-none"
                                        placeholder="產品名稱"
                                    />
                                    
                                    {/* 擷取畫面顯示 */}
                                    {card.capturedImage && (
                                        <div className="mt-3 mb-3">
                                            <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                                <div className="relative w-full aspect-video">
                                                    {card.capturedImage.startsWith('data:image') ? (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    ) : (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-1 mt-1 text-sm">
                                        {/* 條碼欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">條碼數據</label>
                                            <input
                                                type="text"
                                                value={card.scannedBarcode || ''}
                                                onChange={(e) => handleCardChange(card.id, 'scannedBarcode', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="條碼"
                                            />
                                        </div>
                                        
                                        {/* 產品名稱欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">產品名稱</label>
                                            <input
                                                type="text"
                                                value={card.productName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="產品名稱"
                                            />
                                        </div>
                                        
                                        {/* 商店欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">商店名稱</label>
                                            <input
                                                type="text"
                                                value={card.storeName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'storeName', e.target.value)}
                                                onClick={(e) => {
                                                    e.preventDefault();
                                                    handleStoreClick(card);
                                                }}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 bg-gray-50 cursor-pointer"
                                                placeholder="點擊選擇商店"
                                            />
                                        </div>
                                        
                                        {/* 價格欄位 */}
                                        {card.specialPrice !== undefined ? (
                                            <>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">原價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.originalPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'originalPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                        placeholder="原價"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">特價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.specialPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'specialPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 text-green-600 font-bold"
                                                        placeholder="特價"
                                                    />
                                                </div>
                                            </>
                                        ) : (
                                            <div className="col-span-2">
                                                <label className="block text-gray-700 font-medium mb-0.5">總價 ($)</label>
                                                <input
                                                    type="number"
                                                    value={card.extractedPrice || ''}
                                                    onChange={(e) => handleCardChange(card.id, 'extractedPrice', e.target.value)}
                                                    className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                    placeholder="價格"
                                                />
                                            </div>
                                        )}
                                        
                                        {/* 數量和單位 */}
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">數量</label>
                                            <input
                                                type="text"
                                                value={card.quantity || ''}
                                                onChange={(e) => handleCardChange(card.id, 'quantity', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="數量"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">單位</label>
                                            <select
                                                value={card.unitType || 'pcs'}
                                                onChange={(e) => handleCardChange(card.id, 'unitType', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                            >
                                                <option value="ml">ml (毫升)</option>
                                                <option value="g">g (克)</option>
                                                <option value="pcs">pcs (個/包/支/條)</option>
                                            </select>
                                        </div>
                                        
                                        {/* 單價 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">單價 (每100g/ml)</label>
                                            <input
                                                type="text"
                                                value={formatUnitPrice(card.unitPrice)}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded bg-gray-100"
                                            />
                                        </div>
                                        
                                        {/* 優惠資訊 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">優惠細節</label>
                                            <input
                                                type="text"
                                                value={card.discountDetails || ''}
                                                onChange={(e) => handleCardChange(card.id, 'discountDetails', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="優惠資訊"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>加入時間: {formatTime(card.timestamp)}</p>
                                        <p>運行時間: {calculateDuration(card.timestamp)}</p>
                                    </div>
                                    
                                    {/* 新增狀態圖示區塊 - 位於運行時間下面 */}
                                    <div className="absolute bottom-2 right-2">
                                        {card.syncStatus === 'pending' && (
                                            <Clock 
                                                className="w-4 h-4 text-yellow-500 animate-spin" 
                                                title="正在同步至 Firebase..." 
                                            />
                                        )}
                                        {card.syncStatus === 'success' && (
                                            <CheckCircle 
                                                className="w-4 h-4 text-green-500" 
                                                title="已成功同步至 Firebase" 
                                            />
                                        )}
                                        {card.syncStatus === 'error' && (
                                            <AlertCircle 
                                                className="w-4 h-4 text-red-500" 
                                                title="同步失敗，請檢查網路或重試" 
                                            />
                                        )}
                                    </div>
                                </div>
                                <div className="flex flex-col">
                                    <button 
                                        onClick={() => handleSaveClick(card)}
                                        className="p-2 text-green-500 hover:text-green-700 hover:bg-green-50 rounded-full"
                                        title="確認儲存"
                                    >
                                        <CheckCircle size={20} />
                                    </button>
                                    <button 
                                        onClick={() => handleDeleteClick(card)}
                                        className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full mt-5"
                                        title="刪除"
                                    >
                                        <Trash2 size={20} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            
            {/* 刪除確認對話框 - 保留 */}
            {deleteConfirmation && (
                <DeleteConfirmation 
                    card={deleteConfirmation}
                    onClose={cancelDelete}
                    onConfirm={confirmDelete}
                />
            )}
        </div>
    );
}

export default OcrQueuePage;
</file>

<file path="src/App.js">
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PaintBucket, DollarSign, Barcode, ClipboardCheck, X, Camera, Zap, FileText, RotateCcw, Database, Settings as SettingsIcon } from 'lucide-react';
import AllRecordsPage from './AllRecordsPage';
import StoreSelector from './StoreSelector';
import AIOcrCaptureModal from './components/AIOcrCaptureModal';
import SettingsPage from './components/SettingsPage'; // 新增導入
import { db } from './firebase-config.js'; // <-- 引入 Firebase
import { getAuth, signInAnonymously } from "firebase/auth";
import { doc, getDoc, setDoc, collection, query, where, getDocs, addDoc, orderBy, serverTimestamp } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import OcrQueuePage from './OcrQueuePage';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具
import { v4 as uuidv4 } from 'uuid'; // 引入 uuid 函式庫來生成本地 ID

// ----------------------------------------------------------------------------
// 1. 核心設定與工具函數 (Core Setup & Utilities)
// ----------------------------------------------------------------------------

function djb2Hash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
}

// 以下函數已移至 src/components/AIOcrCaptureModal.js
// callGeminiApiWithRetry
// withExponentialBackoff


function generateProductId(barcode, productName, storeName) {
    if (barcode) {
        return djb2Hash(barcode).toString();
    } else {
        // Combine productName and storeName to create a unique ID for products without barcodes
        // This assumes productName + storeName is sufficiently unique for non-barcoded items
        return djb2Hash(`${productName}-${storeName}`).toString();
    }
}

// ----------------------------------------------------------------------------
// 2. UI 元件 (UI Components)
// ----------------------------------------------------------------------------

const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, theme }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間沒有足夠的變化來繪製趨勢圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1 text-gray-500"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                單價走勢
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke={theme.color === 'red' ? '#EF4444' : '#4F46E5'} strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === 0 ? '#10B981' : theme.primary.split('-')[1]} title={`$${record.displayPrice.toFixed(2)}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>最早: {new Date(minTimestamp).toLocaleDateString()}</span>
                <span>最新: {new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

function PriceHistoryDisplay({ historyRecords, theme }) {
    if (historyRecords.length === 0) {
        return <div className="text-center p-6 text-gray-500 bg-white rounded-xl shadow-md">尚無歷史價格紀錄。</div>;
    }

    const formattedRecords = historyRecords.map(record => ({
        ...record,
        timestamp: record.timestamp?.toDate ? record.timestamp.toDate() : new Date(record.timestamp),
        displayPrice: record.unitPrice !== undefined && record.unitPrice !== null ? record.unitPrice : record.price // Use unitPrice if available, else price
    }));

    return (
        <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${theme.border} mt-8`}>
            <h2 className={`text-xl font-semibold ${theme.text} mb-4`}>價格紀錄 ({formattedRecords.length} 筆)</h2>
            <div className="mb-6"><PriceTrendChart records={formattedRecords} theme={theme} /></div>
            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {formattedRecords.map((record, index) => (
                    <div key={index} className={`p-3 rounded-lg shadow-sm border border-gray-100 ${index === 0 ? theme.light : 'bg-white'}`}>
                        <div className="flex justify-between items-start font-bold">
                            {/* 顯示原價和特價信息 */}
                            {record.specialPrice ? (
                                <span className="text-[22px]">
                                    {record.originalPrice && (
                                        <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                    )}
                                    <span className="text-red-600 ml-2">${record.specialPrice.toFixed(2)}</span>
                                    <span className="text-gray-500 ml-2">@{formatUnitPrice(record.unitPrice)}</span>
                                </span>
                            ) : (
                                <span className="text-[22px] text-red-600">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</span>
                            )}
                            <span className="text-xs text-gray-500">{record.timestamp.toLocaleString()}</span>
                        </div>
                        <p className="text-sm text-gray-700 mt-1">商店: {record.storeName || '未標註'}</p>
                        {/* 顯示數量和單位資訊 */}
                        {record.quantity && record.unitType && <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType} (總價: ${(record.price || 0).toFixed(2)})</p>}
                        {record.discountDetails && <p className="text-xs text-indigo-600 italic">優惠: {record.discountDetails}</p>}
                        {index === 0 && <span className={`text-xs font-semibold px-2 py-0.5 rounded-full text-white ${theme.primary}`}>最新紀錄</span>}
                    </div>
                ))}
            </div>
        </div>
    );
}

const THEMES = {
    'Default (Indigo)': { primary: 'bg-indigo-600', light: 'bg-indigo-100', hover: 'hover:bg-indigo-700', border: 'border-indigo-600', text: 'text-indigo-600', color: 'indigo' },
    '海洋藍 (Ocean Blue)': { primary: 'bg-blue-600', light: 'bg-blue-100', hover: 'hover:bg-blue-700', border: 'border-blue-600', text: 'text-blue-600', color: 'blue' },
    '森林綠 (Forest Green)': { primary: 'bg-green-600', light: 'bg-green-100', hover: 'hover:bg-green-700', border: 'border-green-600', text: 'text-green-600', color: 'green' },
    '夕陽紅 (Sunset Red)': { primary: 'bg-red-600', light: 'bg-red-100', hover: 'hover:bg-red-700', border: 'border-red-600', text: 'text-red-600', color: 'red' },
    '活力橙 (Vibrant Orange)': { primary: 'bg-orange-600', light: 'bg-orange-100', hover: 'hover:bg-orange-700', border: 'border-orange-600', text: 'text-orange-600', color: 'orange' },
    '薰衣草紫 (Lavender)': { primary: 'bg-purple-600', light: 'bg-purple-100', hover: 'hover:bg-purple-700', border: 'border-purple-600', text: 'text-purple-600', color: 'purple' },
};
const DEFAULT_THEME_KEY = 'Default (Indigo)';

function ThemeSelector({ theme, saveTheme, onClose }) {
    const handleThemeChange = (themeKey) => { saveTheme(themeKey); };
    const handleReset = () => { saveTheme(DEFAULT_THEME_KEY); };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 transform transition-all">
                <h3 className={`text-xl font-bold ${theme.text} mb-4 border-b pb-2`}><PaintBucket className="inline-block w-5 h-5 mr-2" />介面配色選項</h3>
                <div className="grid grid-cols-2 gap-4 mb-6">
                    {Object.keys(THEMES).map((themeKey) => {
                        const themeData = THEMES[themeKey];
                        const isSelected = theme.color === themeData.color;
                        return (
                            <button key={themeKey} onClick={() => handleThemeChange(themeKey)}
                                className={`p-3 rounded-lg text-white font-medium shadow-md transition-all ${themeData.primary} ${themeData.hover} ${isSelected ? 'ring-4 ring-offset-2 ring-opacity-70 ring-gray-400' : ''}`}
                                style={{ transform: isSelected ? 'scale(1.05)' : 'scale(1)' }}>
                                {themeKey}
                            </button>
                        );
                    })}
                </div>
                <div className="flex justify-between items-center pt-4 border-t">
                    <button onClick={handleReset} className="flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                        <RotateCcw className="w-4 h-4 mr-1" />清除還原 (預設)
                    </button>
                    <button onClick={onClose} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg ${theme.primary} ${theme.hover} transition-all`}>關閉</button>
                </div>
            </div>
        </div>
    );
}

// AIOcrCaptureModal 組件已移至獨立檔案 src/components/AIOcrCaptureModal.js


// ----------------------------------------------------------------------------
// 3. Firebase 身份驗證與主題設定 (Firebase Auth & Theming)
// ----------------------------------------------------------------------------

function useFirebaseAuthentication() {
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        const auth = getAuth();
        signInAnonymously(auth)
            .then((userCredential) => {
                setUserId(userCredential.user.uid);
                setIsAuthReady(true);
            })
            .catch((error) => {
                console.error("Firebase 匿名登入失敗:", error);
            });
    }, []);

    const [currentTheme, setCurrentTheme] = useState(() => {
        const savedKey = localStorage.getItem('appTheme') || DEFAULT_THEME_KEY;
        return THEMES[savedKey] || THEMES[DEFAULT_THEME_KEY];
    });

    const saveUserTheme = useCallback((themeKey) => {
        localStorage.setItem('appTheme', themeKey);
        setCurrentTheme(THEMES[themeKey] || THEMES[DEFAULT_THEME_KEY]);
    }, []);

    return { userId, isAuthReady, currentTheme, saveUserTheme };
}

// ----------------------------------------------------------------------------
// 4. 結果提示框 (Result Toast)
// ----------------------------------------------------------------------------
function SaveResultToast({ result, onClose }) {
    useEffect(() => {
        let timer;
        if (result) {
            timer = setTimeout(onClose, 5000);
        }
        return () => clearTimeout(timer);
    }, [result, onClose]);

    if (!result) {
        return null;
    }

    const { status, message, productName } = result;

    const theme = {
        success: { bg: 'bg-green-500', text: 'text-white', icon: <ClipboardCheck className="w-6 h-6 mr-3" /> },
        warning: { bg: 'bg-yellow-400', text: 'text-gray-800', icon: <DollarSign className="w-6 h-6 mr-3" /> },
        error: { bg: 'bg-red-500', text: 'text-white', icon: <X className="w-6 h-6 mr-3" /> },
    };

    const currentTheme = theme[status];

    return (
        <div className={`fixed top-20 left-1/2 -translate-x-1/2 max-w-md w-full p-4 rounded-xl shadow-2xl z-[100] ${currentTheme.bg} ${currentTheme.text} transition-all duration-300 ease-in-out`}>
            <div className="flex items-center">
                {currentTheme.icon}
                <div className="flex-grow">
                    <p className="font-bold text-lg">{productName}</p>
                    <p className="text-sm">{message}</p>
                    <p className="text-sm font-semibold mt-1">
                        資料儲存: {status === 'error' ? '失敗' : '成功'} | 
                        比價結果: {status === 'success' ? '是最低價' : (status === 'warning' ? '非最低價' : 'N/A')}
                    </p>
                </div>
                <button onClick={onClose} className="ml-4 p-1 rounded-full hover:bg-white/20"><X className="w-5 h-5" /></button>
            </div>
        </div>
    );
}


// ----------------------------------------------------------------------------
// 5. 主應用程式元件 (App Component)
// ----------------------------------------------------------------------------

function App() {
    const { userId, isAuthReady, currentTheme, saveUserTheme } = useFirebaseAuthentication();
    const streamRef = useRef(null);
    
    const [saveResultToast, setSaveResultToast] = useState(null);

    // UI 狀態
    const [barcode, setBarcode] = useState('');
    const [productName, setProductName] = useState('');
    const [currentPrice, setCurrentPrice] = useState('');
    const [quantity, setQuantity] = useState('');
    const [unitType, setUnitType] = useState('pcs'); // 'g', 'ml', 'pcs'
    const [unitPrice, setUnitPrice] = useState(null);
    const [discountDetails, setDiscountDetails] = useState('');
    const [storeName, setStoreName] = useState('');
    const [productHistory, setProductHistory] = useState([]);
    const [comparisonResult, setComparisonResult] = useState({ message: '等待比價數據...' });
    const [statusMessage, setStatusMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [lookupStatus, setLookupStatus] = useState('ready');
    
    // Modal and Page 狀態
    const [isThemeModalOpen, setIsThemeModalOpen] = useState(false);
    const [isCaptureModalOpen, setIsCaptureModalOpen] = useState(false);
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);
    const [isOcrQueueStoreSelectorOpen, setIsOcrQueueStoreSelectorOpen] = useState(false); // 新增狀態
    const [isSettingsOpen, setIsSettingsOpen] = useState(false); // 新增狀態
    const [editingOcrCard, setEditingOcrCard] = useState(null); // 新增狀態
    
    // 新增 useEffect 來自動清除狀態消息
    useEffect(() => {
        let timer;
        if (statusMessage) {
            timer = setTimeout(() => {
                setStatusMessage('');
            }, 3000); // 3秒後清除消息
        }
        return () => clearTimeout(timer);
    }, [statusMessage]);
    
    // 新增函數：處理數據刷新
    const handleDataRefresh = useCallback((key) => {
        // 如果清除的是 pendingOcrCards，需要更新狀態
        if (key === 'pendingOcrCards' || key === 'ALL') {
            const savedCards = localStorage.getItem('pendingOcrCards');
            setPendingOcrCards(savedCards ? JSON.parse(savedCards) : []);
        }
        // 可以在這裡添加其他需要刷新的狀態
    }, []);

    const [currentPage, setCurrentPage] = useState('main'); // 'main', 'allRecords', 'ocrQueue'
    const [ocrResult, setOcrResult] = useState(null);
    const [capturedImage, setCapturedImage] = useState(null); // 新增的狀態
    
    // 新增狀態：待辨識序列
    const [pendingOcrCards, setPendingOcrCards] = useState(() => {
        // 從 localStorage 恢復待辨識卡片
        const savedCards = localStorage.getItem('pendingOcrCards');
        return savedCards ? JSON.parse(savedCards) : [];
    });
    
    // 新增狀態：跟踪是否已從 Firebase 加載數據
    const [isFirebaseDataLoaded, setIsFirebaseDataLoaded] = useState(false);
    
    // 新增狀態：跟踪上次同步的數據哈希值
    const [lastSyncedDataHash, setLastSyncedDataHash] = useState('');
    
    // 新增狀態：跟踪上次同步時間
    const [lastSyncTime, setLastSyncTime] = useState(0);
    
    // 計算數據哈希值的函數
    const calculateDataHash = useCallback((data) => {
        // 將數據轉換為字符串並計算簡單哈希
        const str = JSON.stringify(data, Object.keys(data).sort());
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 轉換為32位整數
        }
        return hash.toString();
    }, []);
    
    // 新增函數：同步 pendingOcrCards 到 Firebase
    const syncPendingOcrCardsToFirebase = useCallback(async (cards) => {
        // 只有在用戶已認證時才同步（不需要等待 Firebase 數據加載完成）
        if (!isAuthReady || !userId) {
            console.log("Firebase 尚未準備好或無用戶 ID，跳過雲端同步。");
            return;
        }
        
        // 計算當前數據的哈希值
        const currentDataHash = calculateDataHash(cards);
        
        // 檢查是否在短時間內重複同步（頻率限制）
        const now = Date.now();
        const timeSinceLastSync = now - lastSyncTime;
        if (timeSinceLastSync < 5000) { // 5秒內不重複同步
            console.log("同步頻率過高，跳過本次同步。");
            return;
        }
        
        // 如果數據沒有變化，則跳過同步
        if (currentDataHash === lastSyncedDataHash) {
            console.log("數據未發生變化，跳過雲端同步。");
            return;
        }

        try {
            // 使用用戶 ID 作為 Document ID，在 ocrQueues Collection 中
            const queueRef = doc(db, "ocrQueues", userId);

            // 儲存整個卡片陣列 (如果陣列大小在 Firestore 限制內)
            await setDoc(queueRef, {
                cards: cards, // 整個 pendingOcrCards 陣列
                lastUpdated: serverTimestamp(), // 記錄最後更新時間
                userId: userId // 保存用戶 ID
            }, { merge: true });

            console.log("待辨識序列已成功同步至 Firebase 雲端。");
            
            // 更新最後同步的數據哈希值和時間
            setLastSyncedDataHash(currentDataHash);
            setLastSyncTime(now);
            
            // 更新卡片的同步狀態為成功（只更新那些狀態不是成功的卡片）
            const updatedCards = cards.map(card => ({
                ...card,
                syncStatus: card.syncStatus === 'success' ? 'success' : 'success'
            }));
            
            // 只有當有卡片狀態需要更新時才更新狀態
            const needsUpdate = cards.some(card => card.syncStatus !== 'success');
            if (needsUpdate) {
                setPendingOcrCards(updatedCards);
            }
        } catch (error) {
            console.error("Firebase 雲端同步失敗:", error);
            // 不再顯示錯誤給用戶，因為這可能會干擾用戶體驗
            
            // 更新卡片的同步狀態為錯誤（只更新那些狀態不是錯誤的卡片）
            const updatedCards = cards.map(card => ({
                ...card,
                syncStatus: card.syncStatus === 'error' ? 'error' : 'error'
            }));
            
            // 只有當有卡片狀態需要更新時才更新狀態
            const needsUpdate = cards.some(card => card.syncStatus !== 'error');
            if (needsUpdate) {
                setPendingOcrCards(updatedCards);
            }
        }
    }, [isAuthReady, userId, lastSyncedDataHash, lastSyncTime, calculateDataHash]);
    
    // 添加 useEffect 來保存 pendingOcrCards 到 localStorage 和雲端
    useEffect(() => {
        // 1. 本地持久化
        localStorage.setItem('pendingOcrCards', JSON.stringify(pendingOcrCards));
        
        // 2. 雲端同步（不需要等待 Firebase 數據加載完成）
        // 只有當有卡片時才觸發同步
        if (pendingOcrCards.length > 0) {
            syncPendingOcrCardsToFirebase(pendingOcrCards);
        }
    }, [pendingOcrCards, syncPendingOcrCardsToFirebase]);
    
    // 新增 useEffect：從 Firebase 載入數據
    useEffect(() => {
        if (isAuthReady && userId && !isFirebaseDataLoaded) {
            const loadCards = async () => {
                try {
                    const queueRef = doc(db, "ocrQueues", userId);
                    const docSnap = await getDoc(queueRef);

                    // 獲取本地數據
                    const savedLocalCards = localStorage.getItem('pendingOcrCards');
                    let localCards = [];
                    if (savedLocalCards) {
                         try {
                             localCards = JSON.parse(savedLocalCards);
                         } catch (parseError) {
                             console.error("解析本地數據失敗:", parseError);
                             localStorage.removeItem('pendingOcrCards'); // 清除損壞的數據
                         }
                    }
                    
                    // 獲取本地最後更新時間
                    const localLastUpdated = localStorage.getItem('pendingOcrCardsLastUpdated');
                    const localLastUpdatedDate = localLastUpdated ? new Date(localLastUpdated) : new Date(0);

                    if (docSnap.exists() && Array.isArray(docSnap.data().cards)) {
                        const firebaseCards = docSnap.data().cards;
                        const firebaseLastUpdated = docSnap.data().lastUpdated?.toDate?.() || new Date(0);
                        
                        // 比較本地和雲端數據的時間戳
                        // 如果雲端數據比本地新，則使用雲端數據
                        if (firebaseLastUpdated > localLastUpdatedDate) {
                            setPendingOcrCards(firebaseCards);
                            localStorage.setItem('pendingOcrCards', JSON.stringify(firebaseCards)); // 用雲端數據覆蓋本地
                            localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString()); // 更新時間戳
                            console.log("已從 Firebase 恢復待辨識序列。");
                        } 
                        // 如果本地數據比雲端新，則上傳本地數據到雲端
                        else if (firebaseLastUpdated < localLastUpdatedDate && localCards.length > 0) {
                            // 觸發一次同步到雲端
                            syncPendingOcrCardsToFirebase(localCards);
                            console.log("本地數據較新，已同步到 Firebase。");
                        }
                        // 如果數據數量不同，合併數據
                        else if (firebaseCards.length !== localCards.length) {
                            // 創建一個基於 ID 的映射來避免重複
                            const localCardMap = new Map(localCards.map(card => [card.id, card]));
                            const firebaseCardMap = new Map(firebaseCards.map(card => [card.id, card]));
                            
                            // 合併兩個集合
                            const mergedCards = [...localCards];
                            for (const [id, firebaseCard] of firebaseCardMap) {
                                if (!localCardMap.has(id)) {
                                    mergedCards.push(firebaseCard);
                                }
                            }
                            
                            // 按時間戳排序
                            mergedCards.sort((a, b) => a.timestamp - b.timestamp);
                            
                            setPendingOcrCards(mergedCards);
                            localStorage.setItem('pendingOcrCards', JSON.stringify(mergedCards)); // 用合併後的數據覆蓋本地
                            localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString()); // 更新時間戳
                            console.log("已從 Firebase 合併待辨識序列。");
                        }
                        // 如果數據相同，則不需要做任何事情
                        else {
                            console.log("本地和雲端數據一致，無需同步。");
                        }
                    } else {
                        // 如果雲端沒有數據但本地有數據，則上傳本地數據到雲端
                        if (localCards.length > 0) {
                            // 注意：這裡我們不直接調用 syncPendingOcrCardsToFirebase，因為 setPendingOcrCards 會觸發上面的 useEffect
                            // 這樣可以確保數據同步到雲端
                            console.log("雲端沒有數據，本地數據將在下次更新時同步到 Firebase。");
                        }
                    }
                    
                    // 標記 Firebase 數據已加載
                    setIsFirebaseDataLoaded(true);
                } catch (error) {
                    console.error("從 Firebase 載入序列失敗:", error);
                    // 即使加載失敗，也標記為已加載以允許本地操作
                    setIsFirebaseDataLoaded(true);
                }
            };
            loadCards();
        }
    }, [isAuthReady, userId, setPendingOcrCards, syncPendingOcrCardsToFirebase, isFirebaseDataLoaded]);
    
    useEffect(() => {
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const price = parseFloat(finalPrice);
        const qty = parseFloat(quantity);

        if (!isNaN(price) && !isNaN(qty) && qty > 0) {
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(price, qty, unitType);
            setUnitPrice(calculatedUnitPrice);
        } else {
            setUnitPrice(null);
        }
    }, [currentPrice, quantity, unitType, ocrResult]);
    
    // 提前定義所有會被使用的函數，避免 no-use-before-define 警告
    const clearForm = useCallback(() => {
        setBarcode('');
        setProductName('');
        setCurrentPrice('');
        setQuantity('');
        setUnitType('pcs'); // Reset to default unit type
        setUnitPrice(null);
        setDiscountDetails('');
        setStoreName('');
        setProductHistory([]);
        setComparisonResult({ message: '等待比價數據...' });
        setOcrResult(null);
        setLookupStatus('ready');
        setCapturedImage(null); // 清除擷取的圖片
    }, []);

    const stopCameraStream = useCallback(() => {
        console.log("stopCameraStream: Attempting to stop camera.");
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
            console.log("stopCameraStream: Camera stream stopped.");
        }
    }, []);
    
    const startCameraStream = async () => {
        console.log("startCameraStream: Attempting to start camera.");
        if (streamRef.current) {
            return streamRef.current;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
            streamRef.current = stream;
            console.log("startCameraStream: Camera started successfully.");
            return stream;
        } catch (err) {
            console.error("無法存取攝影機:", err);
            setStatusMessage(`無法存取攝影機: ${err.name}`);
            return null;
        }
    };

    const lookupProduct = useCallback(async (barcodeData, currentProductName, currentStoreName) => {
        // 如果 Firebase 尚未初始化，則不執行查詢
        if (!isAuthReady || !userId) {
            return;
        }
        
        const numericalID = generateProductId(barcodeData, currentProductName, currentStoreName);

        // Adjust early exit condition:
        // If no barcode and no product name, or if barcode is too short and no product name,
        // then we can't look up a product.
        if (!numericalID) { // If numericalID couldn't be generated, then we can't look up a product.
            setProductName('');
            setLookupStatus('ready');
            setProductHistory([]);
            return;
        }
        
        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);

            if (productSnap.exists()) {
                setProductName(productSnap.data().productName);
                setLookupStatus('found');
            } else {
                setLookupStatus('new');
            }

            const recordsQueryString = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID), // numericalID is already a string
                orderBy("timestamp", "desc")
            );
            const recordsSnapString = await getDocs(recordsQueryString);
            let records = recordsSnapString.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Attempt to query for numericalID as a number, if it's a valid number string
            const numericalIDAsNumber = parseInt(numericalID, 10);
            if (!isNaN(numericalIDAsNumber) && numericalIDAsNumber.toString() === numericalID) { // Check if it's a pure number string
                const recordsQueryNumber = query(
                    collection(db, "priceRecords"),
                    where("numericalID", "==", numericalIDAsNumber),
                    orderBy("timestamp", "desc")
                );
                const recordsSnapNumber = await getDocs(recordsQueryNumber);
                const recordsNumber = recordsSnapNumber.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Merge and deduplicate records
                const mergedRecordsMap = new Map();
                records.forEach(record => mergedRecordsMap.set(record.id, record));
                recordsNumber.forEach(record => mergedRecordsMap.set(record.id, record));
                records = Array.from(mergedRecordsMap.values()).sort((a, b) => (b.timestamp?.toDate ? b.timestamp.toDate().getTime() : 0) - (a.timestamp?.toDate ? a.timestamp.toDate().getTime() : 0));
            }
            setProductHistory(records);

        } catch (error) {
            console.error("查詢產品失敗 (Firestore):", error);
            setStatusMessage("查詢產品資料時發生錯誤。");
            setLookupStatus('ready');
            setProductHistory([]);
        }
    }, [isAuthReady, userId, setProductName, setLookupStatus, setProductHistory, setStatusMessage]);

    // 新增函數：處理 OCR 隊列的商店選擇
    const handleOcrQueueStoreSelect = useCallback((card) => {
        setEditingOcrCard(card);
        setIsOcrQueueStoreSelectorOpen(true);
    }, [setEditingOcrCard, setIsOcrQueueStoreSelectorOpen]);

    // 新增函數：處理 OCR 隊列的商店選擇確認
    const handleOcrQueueStoreSelectConfirm = useCallback((selectedStore) => {
        if (editingOcrCard) {
            // 更新待辨識卡片的商店名稱
            const updatedCards = pendingOcrCards.map(card => 
                card.id === editingOcrCard.id ? { ...card, storeName: selectedStore } : card
            );
            setPendingOcrCards(updatedCards);
        }
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [editingOcrCard, pendingOcrCards, setPendingOcrCards, setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 新增函數：處理 OCR 隊列的商店選擇器關閉
    const handleOcrQueueStoreSelectorClose = useCallback(() => {
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 正確地提前定義 performSaveAndCompare 函數（必須在 saveAndComparePrice 之前定義）
    const performSaveAndCompare = useCallback(async (selectedStore) => {
        const finalStoreName = selectedStore || storeName;
        const numericalID = generateProductId(barcode, productName, finalStoreName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const priceValue = parseFloat(finalPrice);

        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, quantity, unitType);

        if (!userId || !productName || isNaN(priceValue) || isNaN(parseFloat(quantity)) || parseFloat(quantity) <= 0 || calculatedUnitPrice === null) {
            showUserFriendlyError("請確保已輸入條碼、產品名稱、有效總價、數量和單位！", "資料驗證");
            setIsLoading(false);
            return;
        }
        if (!finalStoreName.trim()) {
            setIsStoreSelectorOpen(true);
            setIsLoading(false);
            return;
        }

        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);
            
            // 準備產品文檔數據
            const productData = {
                numericalID,
                barcodeData: barcode,
                productName,
                createdAt: productSnap.exists() ? productSnap.data().createdAt : serverTimestamp(),
                lastUpdatedBy: userId,
            };

            // 準備價格記錄數據
            const priceRecord = {
                numericalID,
                productName,
                storeName: finalStoreName,
                price: priceValue, // 總價
                quantity: parseFloat(quantity),
                unitType: unitType,
                unitPrice: calculatedUnitPrice, // 單價
                discountDetails: discountDetails || '',
                timestamp: serverTimestamp(),
                recordedBy: userId,
                // 保存原價和特價信息（如果有的話）
                originalPrice: ocrResult?.originalPrice ? parseFloat(ocrResult.originalPrice) : null,
                specialPrice: ocrResult?.specialPrice ? parseFloat(ocrResult.specialPrice) : null
            };

            // 儲存價格記錄
            const priceRecordDocRef = await addDoc(collection(db, "priceRecords"), priceRecord);
            
            // 檢查是否需要更新產品文檔中的最佳單價
            let isBestPrice = false;
            if (productSnap.exists()) {
                const existingProductData = productSnap.data();
                // 如果產品文檔中沒有 bestUnitPrice 或新價格更低，則更新
                if (existingProductData.bestUnitPrice === undefined || calculatedUnitPrice < existingProductData.bestUnitPrice) {
                    productData.bestUnitPrice = calculatedUnitPrice;
                    productData.bestPriceRecordRef = priceRecordDocRef.path; // 儲存指向最佳價格記錄的引用路徑
                    isBestPrice = true;
                } else {
                    // 保持現有的最佳價格信息
                    productData.bestUnitPrice = existingProductData.bestUnitPrice;
                    productData.bestPriceRecordRef = existingProductData.bestPriceRecordRef;
                }
            } else {
                // 新產品，當前價格就是最佳價格
                productData.bestUnitPrice = calculatedUnitPrice;
                productData.bestPriceRecordRef = priceRecordDocRef.path;
                isBestPrice = true;
            }
            
            // 儲存或更新產品文檔
            await setDoc(productRef, productData);

            // 準備比價結果
            let toastStatus, toastMessage, isBest, bestPrice, bestStore;

            if (isBestPrice) {
                isBest = true;
                bestPrice = calculatedUnitPrice;
                bestStore = finalStoreName;
                toastStatus = 'success';
                toastMessage = '恭喜！這是目前紀錄中的最低單價！';
            } else {
                isBest = false;
                bestPrice = productData.bestUnitPrice;
                
                // 從 Firestore 獲取最佳價格記錄的商店名稱
                try {
                    const bestPriceRecordDoc = await getDoc(doc(db, productData.bestPriceRecordRef));
                    if (bestPriceRecordDoc.exists()) {
                        bestStore = bestPriceRecordDoc.data().storeName;
                    } else {
                        bestStore = '未知商店';
                    }
                } catch (error) {
                    console.error("獲取最佳價格記錄失敗:", error);
                    bestStore = '未知商店';
                }
                
                toastStatus = 'warning';
                toastMessage = `非最低單價。歷史最低單價為 $${formatUnitPrice(productData.bestUnitPrice)} (${bestStore})`;
            }

            setComparisonResult({ isBest, bestPrice, bestStore, message: toastMessage });
            // 儲存成功時顯示提示訊息
            setSaveResultToast({ status: toastStatus, message: toastMessage, productName: productName });
            
            lookupProduct(barcode, productName, finalStoreName);

        } catch (error) {
            console.error("儲存或比價失敗 (Firestore):", error);
            const userMessage = handleFirestoreSaveError(error, "儲存價格資訊");
            showUserFriendlyError(userMessage);
        } finally {
            setIsLoading(false);
        }
    }, [userId, barcode, productName, currentPrice, discountDetails, storeName, lookupProduct, quantity, unitType, setSaveResultToast, setComparisonResult, setIsLoading, setIsStoreSelectorOpen, ocrResult]);

    // 正確地提前定義 saveAndComparePrice 函數
    const saveAndComparePrice = useCallback(async (selectedStore) => {
        // 確保 Firebase 已初始化，如果尚未完成初始化則強制初始化
        if (!isAuthReady) {
            // 顯示加載訊息並等待初始化完成
            setIsLoading(true);
            // 等待 Firebase 初始化完成
            const checkAuth = () => {
                if (isAuthReady) {
                    // 初始化完成後繼續執行
                    performSaveAndCompare(selectedStore);
                } else {
                    // 繼續等待
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
            return;
        }
        
        // 如果 Firebase 已準備好，直接執行保存操作
        performSaveAndCompare(selectedStore);
    }, [isAuthReady, performSaveAndCompare]);
    
    const handleAiCaptureSuccess = useCallback((result) => {
        const { scannedBarcode, productName, extractedPrice, storeName, discountDetails, quantity, unitType, specialPrice, capturedImage: receivedImage } = result;
        setOcrResult(result);
        
        // 設置捕獲的圖像
        if (receivedImage) {
            setCapturedImage(receivedImage);
        }
        
        const newBarcode = scannedBarcode || '';
        setBarcode(newBarcode);

        if (!newBarcode) {
            setStatusMessage("AI 未能識別條碼，請手動輸入或確保條碼清晰！");
        } else {
            setStatusMessage(`AI 分析成功！`);
        }

        setProductName(productName || '');
        
        // 優先使用特價，如果有的話
        const finalPrice = specialPrice && !isNaN(parseFloat(specialPrice)) ? specialPrice : extractedPrice;
        setCurrentPrice(finalPrice || '');
        
        setStoreName(storeName || '');
        setDiscountDetails(discountDetails || '');

        setQuantity(quantity || '');
        setUnitType(unitType || 'pcs');

        if (productName && newBarcode) {
            setLookupStatus('found');
        } else {
            setLookupStatus('new');
        }
    }, [setBarcode, setProductName, setCurrentPrice, setStoreName, setDiscountDetails, setOcrResult, setStatusMessage, setLookupStatus, setQuantity, setUnitType, setCapturedImage]);

    // 定義一個新的函式來處理 Firebase 備份
    const backupOcrCardToFirebase = useCallback(async (cardData) => {
        // 檢查 Firebase 是否準備好
        if (!isAuthReady || !userId) {
            // 由於功能要求是自動備份，若服務未準備好，則將其視為 pending 或 error (可選)
            console.warn("Firebase 服務尚未準備好，跳過備份。");
            // 由於此專案似乎有 MVP 階段屏蔽 Firebase 的歷史需求，
            // 這裡可以選擇將狀態設為 'error' 或保留 'pending'。
            // 為避免影響核心功能，建議在此處直接返回，讓卡片保持 'pending' 狀態。
            return;
        }

        const cardToSave = {
            ...cardData,
            userId: userId, // 儲存用戶 ID
            timestamp: serverTimestamp(), // 使用 Firebase 服務器時間戳
            // 移除本地 ID 和同步狀態，因為這些只用於本地 UI
            id: undefined, 
            syncStatus: undefined
        };

        try {
            // 將卡片數據儲存到 pendingOcrCards 集合
            const docRef = await addDoc(collection(db, "pendingOcrCards"), cardToSave);
            
            // 成功後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'success', fbDocId: docRef.id } : c
                )
            );

        } catch (error) {
            console.error("Firebase 待辨識卡片備份失敗:", error);
            handleFirestoreSaveError(error, "備份待辨識卡片"); // 使用錯誤處理機制
            
            // 失敗後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'error' } : c
                )
            );
        }
    }, [isAuthReady, userId, setPendingOcrCards]);

    // 新增函數：將辨識結果加入待確認序列
    const handleQueueNextCapture = useCallback((result) => {
        // 1. 建立具有初始同步狀態的新卡片物件
        const newCard = {
            ...result,
            id: uuidv4(), // 確保本地狀態有一個唯一 ID
            timestamp: Date.now(), // 本地時間戳 (用於排序/顯示)
            syncStatus: 'pending', // 初始狀態設為處理中
        };
        
        // 2. 更新本地狀態 (立即顯示卡片)
        setPendingOcrCards(prev => [...prev, newCard]);
        
        // 3. 更新本地時間戳
        localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString());

        // 4. 觸發 Firebase 備份
        backupOcrCardToFirebase(newCard); 
        
        setStatusMessage(`已將辨識結果加入待確認序列！`);
    }, [setPendingOcrCards, backupOcrCardToFirebase]);

    // 新增函數：移除待確認的辨識卡片
    const handleRemovePendingOcrCard = useCallback((cardId) => {
        setPendingOcrCards(prev => prev.filter(item => item.id !== cardId));
    }, []);

    const handleStoreSelect = useCallback((selectedStore) => {
        setStoreName(selectedStore);
        setIsStoreSelectorOpen(false);
        // 不再自動觸發保存操作，與其他頁面保持一致
    }, [setStoreName, setIsStoreSelectorOpen]);

    const handleCaptureModalClose = useCallback(() => {
        setIsCaptureModalOpen(false);
        stopCameraStream();
    }, [stopCameraStream]);

    const handleNewScanClick = async () => {
        clearForm();
        const stream = await startCameraStream();
        if (stream) {
            setIsCaptureModalOpen(true);
        } else {
            // 如果無法啟動相機，顯示錯誤訊息
            setStatusMessage("無法啟動相機，請檢查權限設置");
        }
    };

    const themePrimary = currentTheme.primary;
    const themeText = currentTheme.text;
    const themeLight = currentTheme.light;
    const themeBorder = currentTheme.border;
    const themeHover = currentTheme.hover; // 添加這一行來定義 themeHover

    const productNamePlaceholder = useMemo(() => {
        switch(lookupStatus) {
            case 'searching': return '正在查詢產品資料...';
            case 'found': return '產品名稱已自動載入';
            case 'new': return '產品不存在，請手動輸入名稱';
            default: return '請先輸入條碼或掃描條碼';
        }
    }, [lookupStatus]);

    if (!isAuthReady) {
        return <div className="flex items-center justify-center min-h-screen bg-gray-50"><p className="text-xl text-gray-700">正在連線至雲端服務...</p></div>;
    }

    if (currentPage === 'allRecords') {
        return <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />;
    }

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${themeLight}`}>
            <SaveResultToast result={saveResultToast} onClose={() => setSaveResultToast(null)} />
            
            {/* 新增 SettingsPage 的渲染 */}
            {isSettingsOpen && (
                <SettingsPage 
                    theme={currentTheme} 
                    onClose={() => setIsSettingsOpen(false)} 
                    onDataChange={handleDataRefresh}
                />
            )}

            {/* 根據 currentPage 狀態渲染不同頁面 */}
            {currentPage === 'main' && (
                <div className="max-w-xl mx-auto">
                    <header className="flex justify-between items-center mb-6 border-b pb-4">
                        <h1 className={`text-3xl font-extrabold ${themeText} flex items-center`}><Barcode className="w-8 h-8 mr-2" />條碼比價神器 (Cloud)</h1>
                        <div className="flex items-center space-x-3">
                            {/* 新增待辨識的按鈕 */}
                            <button 
                                onClick={() => setCurrentPage('ocrQueue')}
                                className={`relative p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`}
                                title={`待辨識 (${pendingOcrCards.length})`}
                            >
                                <Zap className="w-5 h-5" />
                                {pendingOcrCards.length > 0 && (
                                    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                                        {pendingOcrCards.length}
                                    </span>
                                )}
                            </button>
                            <button onClick={() => setCurrentPage('allRecords')} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="查看所有記錄"><Database className="w-5 h-5" /></button>
                            <button onClick={() => setIsThemeModalOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定介面主題"><PaintBucket className="w-5 h-5" /></button>
                            {/* 新增設定按鈕 */}
                            <button onClick={() => setIsSettingsOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定"><SettingsIcon className="w-5 h-5" /></button>
                            <p className="text-sm text-gray-500 hidden sm:block">User: {userId.slice(0, 8)}...</p>
                        </div>
                    </header>

                    {statusMessage && <div className="bg-blue-500 text-white p-3 rounded-lg shadow-md mb-4 text-center font-medium">{statusMessage}</div>}

                    {ocrResult && (
                        <div className="bg-yellow-100 border border-yellow-300 rounded-lg p-4 mb-6">
                            <h3 className="text-lg font-semibold text-yellow-800 mb-2">AI 辨識結果 (開發者確認區)</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm">
                                <div>條碼:</div><div>{ocrResult.scannedBarcode || 'N/A'}</div>
                                <div>品名:</div><div>{ocrResult.productName || 'N/A'}</div>
                                {/* 顯示原價和特價信息 */}
                                {ocrResult.specialPrice ? (
                                    <>
                                        {ocrResult.originalPrice && (
                                            <>
                                                <div>原價:</div><div className="line-through text-red-500">${ocrResult.originalPrice.toFixed(2)}</div>
                                            </>
                                        )}
                                        <div>特價:</div><div className="text-green-600 font-bold">${ocrResult.specialPrice.toFixed(2)}</div>
                                    </>
                                ) : (
                                    <>
                                        <div>價格:</div><div>${ocrResult.extractedPrice || 'N/A'}</div>
                                    </>
                                )}
                                <div>數量:</div><div>{ocrResult.quantity || 'N/A'}</div>
                                <div>商店:</div><div>{ocrResult.storeName || 'N/A'}</div>
                                <div>折扣:</div><div>{ocrResult.discountDetails || '無'}</div>
                            </div>
                            <button onClick={() => setOcrResult(null)} className="mt-3 px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 text-sm">關閉</button>
                        </div>
                    )}

                    <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${themeBorder}`}>
                        <h2 className={`text-xl font-semibold ${themeText} mb-6 flex items-center`}><Zap className="w-5 h-5 mr-2" />步驟 1: AI 視覺自動擷取</h2>
                        <button className={`w-full p-4 rounded-lg text-white font-bold text-lg shadow-xl transition-all ${themePrimary} hover:opacity-80 flex items-center justify-center`} onClick={handleNewScanClick}>
                            <Camera className="inline-block w-6 h-6 mr-3" />開啟鏡頭擷取
                        </button>
                        <hr className="my-6 border-gray-200" />
                        <h2 className={`text-xl font-semibold text-gray-700 mb-4 flex items-center`}><FileText className="w-5 h-5 mr-2" />步驟 2: 檢查或手動輸入</h2>
                        
                        {/* 新增的擷取畫面顯示區塊 */}
                        {capturedImage && (
                            <div className="mb-6">
                                <label className="block text-gray-700 font-medium mb-2">擷取畫面 (請確認辨識資料是否正確)</label>
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                    <div className="relative w-full aspect-video">
                                        {capturedImage.startsWith('data:image') ? (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        ) : (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        )}
                                    </div>
                                </div>
                                <p className="text-sm text-gray-500 mt-2">此圖片將持續顯示直到進行下一次辨識或退出應用程式</p>
                            </div>
                        )}
                        
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">條碼數據</label>
                            <input type="text" value={barcode} onChange={(e) => setBarcode(e.target.value)} placeholder="AI 自動填入，或手動輸入" className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" />
                        </div>
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">產品名稱</label>
                            <input type="text" value={productName} onChange={(e) => setProductName(e.target.value)} placeholder={productNamePlaceholder} className={`w-full p-3 border border-gray-300 rounded-lg ${lookupStatus === 'found' ? 'bg-green-50' : lookupStatus === 'new' ? 'bg-yellow-50' : ''}`} readOnly={lookupStatus === 'found' && !ocrResult} />
                            <p className="text-sm text-gray-500 mt-1">ID (Hash): {barcode ? djb2Hash(barcode) : 'N/A'}</p>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">總價 ($) <span className="text-red-500">*</span></label>
                                <input type="number" value={currentPrice} onChange={(e) => setCurrentPrice(e.target.value)} placeholder="AI 擷取" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">商店名稱</label>
                                <input 
                                    type="text" 
                                    value={storeName} 
                                    onFocus={() => setIsStoreSelectorOpen(true)}
                                    readOnly
                                    placeholder="點擊選擇商店"
                                    className="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 cursor-pointer"
                                />
                            </div>
                        </div>
                        <div className="grid grid-cols-3 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">數量 <span className="text-red-500">*</span></label>
                                <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="例如: 500" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單位 <span className="text-red-500">*</span></label>
                                <select value={unitType} onChange={(e) => setUnitType(e.target.value)} className="w-full p-3 border border-gray-300 rounded-lg">
                                    <option value="ml">ml (毫升)</option>
                                    <option value="g">g (克)</option>
                                    <option value="pcs">pcs (個/包/支/條)</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單價 (每100g/ml)</label>
                                <input type="text" value={formatUnitPrice(unitPrice)} readOnly className="w-full p-3 border border-gray-300 rounded-lg bg-gray-100" />
                            </div>
                        </div>
                        <div className="mb-6">
                            <label className="block text-gray-700 font-medium mb-1">優惠細節</label>
                            <input type="text" value={discountDetails} onChange={(e) => setDiscountDetails(e.target.value)} placeholder="例如: 買二送一" className="w-full p-3 border border-gray-300 rounded-lg" />
                        </div>
                        <button className={`w-full mt-4 p-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-emerald-500 hover:bg-emerald-600`} onClick={() => saveAndComparePrice()} disabled={isLoading}>
                            <ClipboardCheck className="inline-block w-5 h-5 mr-2" />{isLoading ? '處理中...' : '步驟 3: 儲存紀錄並比價'}
                        </button>
                    </div>

                    <div className="mt-8">
                        <h2 className={`text-xl font-semibold ${themeText} mb-4 flex items-center`}>
                            <DollarSign className="w-5 h-5 mr-2" />
                            比價結果 {productName && <span className="ml-2 font-normal text-gray-500">- {productName}</span>}
                        </h2>
                        <div className={`p-6 rounded-xl shadow-xl border-2 ${comparisonResult.isBest ? 'border-green-500 bg-green-50' : 'border-yellow-500 bg-yellow-50'}`}>
                            <p className={`text-lg font-bold ${comparisonResult.isBest ? 'text-green-700' : 'text-yellow-700'}`}>{comparisonResult.message}</p>
                            {comparisonResult.bestPrice && <p className="text-sm text-gray-600 mt-2">歷史最低標價: ${comparisonResult.bestPrice}</p>}
                            <p className="text-xs text-gray-500 mt-2">**附註:** 您的紀錄已安全儲存在雲端。</p>
                        </div>
                    </div>

                    {(lookupStatus === 'found' || lookupStatus === 'new') && <PriceHistoryDisplay historyRecords={productHistory} theme={currentTheme} />}
                    
                    {/* 在主介面添加一個快捷處理待辨識卡片的按鈕 */}
                    {pendingOcrCards.length > 0 && (
                        <div className="mt-4 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold text-yellow-800">有待辨識的項目</h3>
                                    <p className="text-sm text-yellow-600">您有 {pendingOcrCards.length} 個待辨識的項目等待處理</p>
                                </div>
                                <button 
                                    onClick={() => {
                                        // 處理第一個待辨識的卡片
                                        const firstCard = pendingOcrCards[0];
                                        
                                        // 設置表單數據
                                        setOcrResult(firstCard);
                                        setCapturedImage(firstCard.capturedImage);
                                        setBarcode(firstCard.scannedBarcode || '');
                                        setProductName(firstCard.productName || '');
                                        setCurrentPrice(firstCard.extractedPrice || '');
                                        setStoreName(firstCard.storeName || '');
                                        setDiscountDetails(firstCard.discountDetails || '');
                                        setQuantity(firstCard.quantity || '');
                                        setUnitType(firstCard.unitType || 'pcs');
                                        
                                        // 計算單價
                                        const priceValue = parseFloat(firstCard.extractedPrice);
                                        const qty = parseFloat(firstCard.quantity);
                                        if (!isNaN(priceValue) && !isNaN(qty) && qty > 0) {
                                            const calculatedUnitPrice = calculateUnitPrice(priceValue, qty, firstCard.unitType);
                                            setUnitPrice(calculatedUnitPrice);
                                        }
                                        
                                        // 更新狀態
                                        if (firstCard.productName && firstCard.scannedBarcode) {
                                            setLookupStatus('found');
                                        } else {
                                            setLookupStatus('new');
                                        }
                                        
                                        // 從待辨識序列中移除該卡片
                                        setPendingOcrCards(prev => prev.filter(item => item.id !== firstCard.id));
                                        
                                        // 顯示提示訊息
                                        setStatusMessage(`已載入待辨識項目: ${firstCard.productName || '未命名產品'}`);
                                    }}
                                    className={`px-4 py-2 rounded-lg text-white font-medium ${themePrimary} ${themeHover}`}
                                >
                                    處理第一個待辨識項目
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            )}
            
            {currentPage === 'allRecords' && (
                <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />
            )}
            
            {currentPage === 'ocrQueue' && (
                <OcrQueuePage 
                    theme={currentTheme} 
                    onBack={() => setCurrentPage('main')} 
                    pendingOcrCards={pendingOcrCards}
                    onRemoveCard={handleRemovePendingOcrCard}
                    onStoreSelect={setPendingOcrCards}
                    isStoreSelectorOpen={isOcrQueueStoreSelectorOpen}
                    onStoreSelectCallback={handleOcrQueueStoreSelect}
                    onCloseStoreSelector={handleOcrQueueStoreSelectorClose}
                />
            )}

            {isThemeModalOpen && <ThemeSelector theme={currentTheme} saveTheme={saveUserTheme} onClose={() => setIsThemeModalOpen(false)} />}
            {isCaptureModalOpen && <AIOcrCaptureModal theme={currentTheme} onAnalysisSuccess={handleAiCaptureSuccess} onClose={handleCaptureModalClose} stream={streamRef.current} onQueueNextCapture={handleQueueNextCapture} />}
            {isStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleStoreSelect} onClose={() => setIsStoreSelectorOpen(false)} />}
            {isOcrQueueStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleOcrQueueStoreSelectConfirm} onClose={handleOcrQueueStoreSelectorClose} />}
        </div>
    );
}

export default App;
</file>

</files>
