This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AllRecordsPage.js
App.css
App.js
components/AIOcrCaptureModal.js
components/AIOcrCaptureModal備份
components/components.xml
components/DataManagement.js
components/SettingsPage.js
firebase-config.js
index.css
index.js
OcrQueuePage.js
src.xml
StoreSelector.js
utils/errorHandler.js
utils/errorHandler.test.js
utils/priceCalculations.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AllRecordsPage.js">
import React, { useState, useEffect, useMemo, useRef, useCallback, useLayoutEffect } from 'react';
import { ArrowLeft, Database, TrendingUp, Edit, Trash2, Save, X, CheckCircle, Search } from 'lucide-react';
import { collection, getDocs, query, orderBy, updateDoc, deleteDoc, doc } from 'firebase/firestore';
import { calculateUnitPrice, formatUnitPrice } from './utils/priceCalculations';
import StoreSelector from './StoreSelector';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 圖表組件
const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, productName }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp).sort((a, b) => a.timestamp - b.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間無足夠變化可繪圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <TrendingUp className="mr-1 text-gray-500" size={16} />
                單價走勢 - {productName}
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke="#4F46E5" strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === validRecords.length - 1 ? '#10B981' : '#4F46E5'} title={`${record.displayPrice.toFixed(2)} at ${record.timestamp.toLocaleDateString()}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>{new Date(minTimestamp).toLocaleDateString()}</span>
                <span>{new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

// Fuzzy search function
function fuzzyMatch(pattern, text) {
    const pattern_lower = pattern.toLowerCase();
    const text_lower = text.toLowerCase();
    let patternIdx = 0;
    let textIdx = 0;
    let score = 0;
    let consecutive = 0;
    let firstMatchIndex = -1;

    // Iterate through text to find pattern characters
    while (patternIdx < pattern_lower.length && textIdx < text_lower.length) {
        if (pattern_lower[patternIdx] === text_lower[textIdx]) {
            if (firstMatchIndex === -1) {
                firstMatchIndex = textIdx;
            }
            score += 1;
            // Add bonus for consecutive matches
            if (consecutive > 0) {
                score += consecutive;
            }
            consecutive++;
            patternIdx++;
        } else {
            consecutive = 0;
        }
        textIdx++;
    }

    // If the whole pattern was found
    if (patternIdx === pattern_lower.length) {
        // Add bonus for being a prefix
        if (firstMatchIndex === 0) {
            score += 5;
        }
        // Add bonus for tightness of the match
        const matchDensity = pattern.length / (textIdx - firstMatchIndex);
        score *= (1 + matchDensity);

        return score;
    }

    return 0;
}

// 可滑動的記錄項目
function SwipeableRecord({ children, onEdit, onDelete }) {
    const [translateX, setTranslateX] = useState(0);
    const touchStartX = useRef(0);
    const itemRef = useRef(null);
    const buttonsRef = useRef(null);

    const handleTouchStart = (e) => {
        touchStartX.current = e.touches[0].clientX;
    };

    const handleTouchMove = (e) => {
        const touchCurrentX = e.touches[0].clientX;
        const diff = touchCurrentX - touchStartX.current;
        if (diff < 0) { // 只允許向左滑動
            setTranslateX(Math.max(diff, -160)); // -160 是按鈕寬度的總和
        }
    };

    const handleTouchEnd = () => {
        if (translateX < -80) {
            setTranslateX(-160);
        } else {
            setTranslateX(0);
        }
    };

    useEffect(() => {
        const handleGlobalClick = (e) => {
            if (buttonsRef.current && !buttonsRef.current.contains(e.target)) {
                setTranslateX(0);
            }
        };

        if (translateX !== 0) {
            document.addEventListener('click', handleGlobalClick, true);
        }

        return () => {
            document.removeEventListener('click', handleGlobalClick, true);
        };
    }, [translateX]);

    const handleEdit = () => {
        onEdit();
        setTranslateX(0);
    };

    const handleDelete = () => {
        onDelete();
        setTranslateX(0);
    };

    return (
        <div className="relative overflow-hidden">
            <div ref={buttonsRef} className="absolute top-0 right-0 h-full flex items-center">
                <button onClick={handleEdit} className="bg-blue-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Edit size={20} />
                    <span>編輯</span>
                </button>
                <button onClick={handleDelete} className="bg-red-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Trash2 size={20} />
                    <span>刪除</span>
                </button>
            </div>
            <div
                ref={itemRef}
                className="transition-transform duration-300 ease-in-out"
                style={{ transform: `translateX(${translateX}px)` }}
                onTouchStart={handleTouchStart}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleTouchEnd}
            >
                {children}
            </div>
        </div>
    );
}


// 產品記錄組件
function ProductRecord({ product, records, theme, onEdit, onDelete }) {
    const formattedRecords = records.map(r => ({ ...r, timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp) })).sort((a, b) => b.timestamp - a.timestamp);
    
    const latestRecord = formattedRecords[0];
    if (!latestRecord) return null; // 如果沒有記錄，則不渲染此組件

    const validUnitPrices = formattedRecords.map(r => r.unitPrice).filter(p => !isNaN(p) && p !== undefined && p !== null);
    const lowestUnitPrice = validUnitPrices.length > 0 ? Math.min(...validUnitPrices) : 0;
    const highestUnitPrice = validUnitPrices.length > 0 ? Math.max(...validUnitPrices) : 0;
    const avgUnitPrice = validUnitPrices.length > 0 ? validUnitPrices.reduce((sum, p) => sum + p, 0) / validUnitPrices.length : 0;

    return (
        <div className={`p-4 rounded-xl shadow-lg bg-white border-t-4 ${theme.border} mb-6`}>
            <div className="flex justify-between items-start">
                <div>
                    <h3 className="text-lg font-bold text-gray-800">{product.productName}</h3>
                    <p className="text-sm text-gray-600">條碼: {product.barcodeData}</p>
                    <p className="text-xs text-gray-500">ID: {product.numericalID}</p>
                </div>
                <div className="text-right">
                    {/* 顯示原價和特價信息 */}
                    {latestRecord.specialPrice ? (
                        <div>
                            {latestRecord.originalPrice && (
                                <p className="text-lg text-gray-500 line-through">${latestRecord.originalPrice.toFixed(2)}</p>
                            )}
                            <p className="text-2xl font-bold text-indigo-600">${latestRecord.specialPrice.toFixed(2)}</p>
                            <p className="text-xs text-gray-500">@{formatUnitPrice(latestRecord.unitPrice)}</p>
                        </div>
                    ) : (
                        <p className="text-2xl font-bold text-indigo-600">{formatUnitPrice(latestRecord.unitPrice) === '--' ? (isNaN(latestRecord.price) ? 'N/A' : `$${(latestRecord.price || 0).toFixed(2)}`) : `$${(latestRecord.price || 0).toFixed(2)} @${formatUnitPrice(latestRecord.unitPrice)}`}</p>
                    )}
                    <p className="text-xs text-gray-500">{latestRecord.timestamp.toLocaleDateString()}</p>
                    {/* 顯示數量和單位 */}
                    {latestRecord.quantity && latestRecord.unitType && (
                        <p className="text-xs text-gray-500">數量: {latestRecord.quantity} {latestRecord.unitType}</p>
                    )}
                </div>
            </div>

            <div className="grid grid-cols-3 gap-2 my-3 text-center">
                <div className="bg-green-50 p-2 rounded"><p className="text-xs text-gray-500">最低單價</p><p className="font-bold text-green-600">{isNaN(lowestUnitPrice) ? 'N/A' : `${lowestUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-blue-50 p-2 rounded"><p className="text-xs text-gray-500">平均單價</p><p className="font-bold text-blue-600">{isNaN(avgUnitPrice) ? 'N/A' : `${avgUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-red-50 p-2 rounded"><p className="text-xs text-gray-500">最高單價</p><p className="font-bold text-red-600">{isNaN(highestUnitPrice) ? 'N/A' : `${highestUnitPrice.toFixed(2)}`}</p></div>
            </div>

            <div className="mb-4"><PriceTrendChart records={formattedRecords} productName={product.productName} /></div>

            <div className="mt-4">
                <h4 className="font-semibold text-gray-700 mb-2">價格記錄詳情</h4>
                <div className="space-y-2 max-h-40 overflow-y-auto">
                    {formattedRecords.map((record, index) => (
                        <SwipeableRecord
                            key={index}
                            onEdit={() => onEdit(record)}
                            onDelete={() => onDelete(record)}
                        >
                            <div className="flex justify-between items-center p-2 bg-gray-50 rounded">
                                <div>
                                    {/* 顯示原價和特價信息 */}
                                    {record.specialPrice ? (
                                        <p className="font-medium">
                                            {record.originalPrice && (
                                                <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                            )}
                                            <span className="text-red-600 ml-1">${record.specialPrice.toFixed(2)}</span>
                                            <span className="text-gray-500 ml-1">@{formatUnitPrice(record.unitPrice)}</span>
                                        </p>
                                    ) : (
                                        <p className="font-medium">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</p>
                                    )}
                                    {record.discountDetails && <p className="text-xs text-indigo-600">{record.discountDetails}</p>}
                                    {/* 顯示數量和單位 */}
                                    {record.quantity && record.unitType && (
                                        <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType}</p>
                                    )}
                                </div>
                                <div className="text-right">
                                    <p className="text-xs text-gray-500">{record.storeName || '未標註'}</p>
                                    <p className="text-xs text-gray-500">{record.timestamp.toLocaleDateString()}</p>
                                </div>
                            </div>
                        </SwipeableRecord>
                    ))}
                </div>
            </div>
        </div>
    );
}

// 主組件
function AllRecordsPage({ theme, onBack, db, userId, isAuthReady }) {
    const [allProducts, setAllProducts] = useState([]);
    const [allRecords, setAllRecords] = useState({});
    const [loading, setLoading] = useState(true);
    const [sortOption, setSortOption] = useState('latest'); // latest, name, price
    const [editingRecord, setEditingRecord] = useState(null);
    const [deletingRecord, setDeletingRecord] = useState(null);
    const [successMessage, setSuccessMessage] = useState('');
    const scrollPositionRef = useRef(0); // For scroll restoration
    const [isAfterDelete, setIsAfterDelete] = useState(false); // Signal for scroll restoration
    const [searchQuery, setSearchQuery] = useState('');
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const searchInputRef = useRef(null);
    
    // Edit mode states
    const [isEditMode, setIsEditMode] = useState(false);
    const [selectedItems, setSelectedItems] = useState(new Set());
    const [localProducts, setLocalProducts] = useState([]);
    const [localRecords, setLocalRecords] = useState({});
    // 新增狀態：批量刪除確認對話框
    const [isBulkDeleteConfirmationOpen, setIsBulkDeleteConfirmationOpen] = useState(false);
    // 新增狀態：原始數據快照和衝突解決
    const [originalDataSnapshot, setOriginalDataSnapshot] = useState(null);
    const [isConflictDialogOpen, setIsConflictDialogOpen] = useState(false);

    const fetchData = useCallback(async () => {
        if (!db) return;
        setLoading(true);
        try {
            // 1. Fetch all products
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const productsArray = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 2. Fetch all records
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const recordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // 3. Group records by product ID
            const recordsByProduct = {};
            recordsArray.forEach(record => {
                if (!recordsByProduct[record.numericalID]) {
                    recordsByProduct[record.numericalID] = [];
                }
                recordsByProduct[record.numericalID].push(record);
            });

            setAllProducts(productsArray);
            setAllRecords(recordsByProduct);

        } catch (error) {
            console.error('讀取 Firestore 數據失敗:', error);
            const userMessage = handleFirestoreSaveError(error, "讀取產品數據");
            showUserFriendlyError(userMessage);
        } finally {
            setLoading(false);
        }
    }, [db]);

    useEffect(() => {
        // 只有在 Firebase 已準備好時才執行查詢
        if (!isAuthReady || !userId) {
            // 如果 Firebase 尚未準備好，不應該顯示加載狀態
            // 讓用戶知道需要等待 Firebase 初始化
            return;
        }
        
        // Firebase 已準備好且有 userId，執行數據獲取
        fetchData();
    }, [fetchData, isAuthReady, userId]);

    useEffect(() => {
        if (isSearchOpen && searchInputRef.current) {
            setTimeout(() => searchInputRef.current.focus(), 100); // Shorter delay for responsiveness
        }
    }, [isSearchOpen]);

    useLayoutEffect(() => {
        if (isAfterDelete && !loading) {
            // Use requestAnimationFrame to ensure scroll happens after browser paints
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollPositionRef.current);
                setIsAfterDelete(false); // Reset the signal after scrolling
            });
        }
    }, [loading, isAfterDelete]);

    const filteredProducts = useMemo(() => {
        // Use local data in edit mode, otherwise use Firebase data
        const products = isEditMode ? localProducts : allProducts;
        const records = isEditMode ? localRecords : allRecords;

        if (searchQuery.trim() === '') {
            // No search query, just sort the products
            return [...products].sort((a, b) => {
                const recordsA = records[a.numericalID] || [];
                const recordsB = records[b.numericalID] || [];
                
                if (sortOption === 'name') {
                    return a.productName.localeCompare(b.productName);
                }
                
                const latestRecordA = recordsA[0];
                const latestRecordB = recordsB[0];

                if (sortOption === 'price') {
                    const priceA = latestRecordA?.price || -1;
                    const priceB = latestRecordB?.price || -1;
                    return priceB - priceA;
                }

                // Default to 'latest'
                const timeA = latestRecordA?.timestamp?.toDate ? latestRecordA.timestamp.toDate().getTime() : 0;
                const timeB = latestRecordB?.timestamp?.toDate ? latestRecordB.timestamp.toDate().getTime() : 0;
                return timeB - timeA;
            });
        }

        // Fuzzy search logic
        const scoredProducts = products
            .map(product => ({
                product,
                score: fuzzyMatch(searchQuery, product.productName)
            }))
            .filter(item => item.score > 0)
            .sort((a, b) => b.score - a.score);
        
        return scoredProducts.map(item => item.product);

    }, [allProducts, allRecords, sortOption, searchQuery, isEditMode, localProducts, localRecords]);

    const showSuccessMessage = (message) => {
        setSuccessMessage(message);
        setTimeout(() => {
            setSuccessMessage('');
        }, 2000);
    };

    const handleEdit = (record) => {
        setEditingRecord(record);
    };

    const handleDelete = (record) => {
        scrollPositionRef.current = window.scrollY; // Save scroll position
        setDeletingRecord(record);
    };

    // New function to handle checkbox selection
    const handleItemSelect = (productId) => {
        setSelectedItems(prev => {
            const newSet = new Set(prev);
            if (newSet.has(productId)) {
                newSet.delete(productId);
            } else {
                newSet.add(productId);
            }
            return newSet;
        });
    };

    // 修改批量刪除功能以使用確認對話框
    const handleBulkDeleteClick = () => {
        if (selectedItems.size === 0) return;
        setIsBulkDeleteConfirmationOpen(true);
    };

    // New function to delete selected items
    const deleteSelectedItems = async () => {
        if (selectedItems.size === 0) return;
        
        try {
            // Update local state
            setLocalProducts(prev => prev.filter(product => !selectedItems.has(product.numericalID)));
            setLocalRecords(prev => {
                const newRecords = {...prev};
                selectedItems.forEach(productId => {
                    delete newRecords[productId];
                });
                return newRecords;
            });
            
            // Clear selection
            setSelectedItems(new Set());
            setIsBulkDeleteConfirmationOpen(false);
        } catch (error) {
            console.error("Error deleting selected items:", error);
            const userMessage = handleFirestoreSaveError(error, "批量刪除產品");
            showUserFriendlyError(userMessage);
        }
    };

    // 新增函數：檢查衝突並退出編輯模式
    const checkForConflictsAndExit = async () => {
        if (!db || !originalDataSnapshot) return;
        
        try {
            // 獲取當前 Firebase 數據
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const currentProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 將記錄按產品 ID 分組
            const currentRecords = {};
            currentRecordsArray.forEach(record => {
                if (!currentRecords[record.numericalID]) {
                    currentRecords[record.numericalID] = [];
                }
                currentRecords[record.numericalID].push(record);
            });
            
            // 比較當前數據與原始快照
            const hasConflicts = checkForDataConflicts(originalDataSnapshot, {products: currentProducts, records: currentRecords});
            
            if (hasConflicts) {
                // 如果有衝突，顯示衝突解決對話框
                setIsConflictDialogOpen(true);
            } else {
                // 如果沒有衝突，直接退出編輯模式
                await exitEditMode(currentProducts, currentRecords);
            }
        } catch (error) {
            console.error("檢查數據衝突時出錯:", error);
            const userMessage = handleFirestoreSaveError(error, "檢查數據衝突");
            showUserFriendlyError(userMessage);
            // 出錯時仍然退出編輯模式
            await exitEditMode();
        }
    };
    
    // 新增函數：檢查數據衝突
    const checkForDataConflicts = (original, current) => {
        // 比較產品數量
        if (original.products.length !== current.products.length) {
            return true;
        }
        
        // 比較記錄數量
        const originalRecordCount = Object.values(original.records).reduce((count, records) => count + records.length, 0);
        const currentRecordCount = Object.values(current.records).reduce((count, records) => count + records.length, 0);
        
        if (originalRecordCount !== currentRecordCount) {
            return true;
        }
        
        // 更詳細的比較可以在此處添加
        // 為了簡化，我們只檢查數量變化
        
        return false;
    };
    
    // 修改 exitEditMode 函數以接受當前數據
    const exitEditMode = async (currentProducts = null, currentRecords = null) => {
        if (!db) return;
        
        try {
            // 如果沒有提供當前數據，則獲取最新數據
            let latestProducts = currentProducts;
            let latestRecords = currentRecords;
            
            if (!latestProducts || !latestRecords) {
                const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
                const productsSnap = await getDocs(productsQuery);
                latestProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
                const recordsSnap = await getDocs(recordsQuery);
                const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 將記錄按產品 ID 分組
                latestRecords = {};
                currentRecordsArray.forEach(record => {
                    if (!latestRecords[record.numericalID]) {
                        latestRecords[record.numericalID] = [];
                    }
                    latestRecords[record.numericalID].push(record);
                });
            }
            
            // 計算需要從 Firebase 刪除的產品
            const productsToDelete = latestProducts.filter(product => 
                !localProducts.some(localProduct => localProduct.numericalID === product.numericalID)
            );
            
            // 刪除 Firebase 中的產品及其記錄
            for (const product of productsToDelete) {
                // 刪除所有記錄
                const productRecords = latestRecords[product.numericalID] || [];
                for (const record of productRecords) {
                    const recordRef = doc(db, "priceRecords", record.id);
                    await deleteDoc(recordRef);
                }
            }
            
            // 計算需要從 Firebase 刪除的記錄（編輯模式下刪除的記錄）
            const recordsToDelete = [];
            for (const [productId, records] of Object.entries(latestRecords)) {
                const localRecordsForProduct = localRecords[productId] || [];
                // 找出在原始記錄中存在但在本地記錄中不存在的記錄
                const deletedRecords = records.filter(record => 
                    !localRecordsForProduct.some(localRecord => localRecord.id === record.id)
                );
                recordsToDelete.push(...deletedRecords);
            }
            
            // 刪除 Firebase 中的記錄
            for (const record of recordsToDelete) {
                const recordRef = doc(db, "priceRecords", record.id);
                await deleteDoc(recordRef);
            }
            
            // 重新從 Firebase 獲取數據
            await fetchData();
            setIsEditMode(false);
            setSelectedItems(new Set());
            setOriginalDataSnapshot(null);

        } catch (error) {
            console.error("Error syncing with Firebase:", error);
            const userMessage = handleFirestoreSaveError(error, "同步編輯數據");
            showUserFriendlyError(userMessage);
        }
    };

    const handleSaveEdit = async (updatedRecord) => {
        if (!db) return;
        try {
            const recordRef = doc(db, "priceRecords", updatedRecord.id);
            // 更新所有字段，不僅僅是價格和折扣詳情
            await updateDoc(recordRef, {
                price: updatedRecord.price,
                discountDetails: updatedRecord.discountDetails,
                productName: updatedRecord.productName,
                storeName: updatedRecord.storeName,
                quantity: updatedRecord.quantity,
                unitType: updatedRecord.unitType,
                unitPrice: updatedRecord.unitPrice,
                originalPrice: updatedRecord.originalPrice,
                specialPrice: updatedRecord.specialPrice
            });
            
            // 在編輯模式下，更新本地狀態而不是重新獲取所有數據
            if (isEditMode) {
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    
                    // 確保更新的記錄所屬的產品在 localRecords 中存在
                    if (!newRecords[updatedRecord.numericalID]) {
                        newRecords[updatedRecord.numericalID] = [];
                    }
                    
                    // 更新記錄
                    Object.keys(newRecords).forEach(productId => {
                        if (newRecords[productId]) {
                            newRecords[productId] = newRecords[productId].map(record => 
                                record.id === updatedRecord.id ? updatedRecord : record
                            ).filter(record => record !== undefined); // 過濾掉可能的 undefined 值
                        }
                    });
                    
                    // 確保當前更新的記錄存在於其對應的產品記錄中
                    if (!newRecords[updatedRecord.numericalID].some(record => record.id === updatedRecord.id)) {
                        newRecords[updatedRecord.numericalID].push(updatedRecord);
                    }
                    
                    return newRecords;
                });
                
                // 同時更新本地產品列表中的產品名稱
                setLocalProducts(prev => 
                    prev.map(product => 
                        product.numericalID === updatedRecord.numericalID 
                            ? {...product, productName: updatedRecord.productName} 
                            : product
                    )
                );
            } else {
                await fetchData(); // 非編輯模式下重新獲取數據以更新UI
            }
            
            showSuccessMessage('記錄已成功更新');
        } catch (error) {
            console.error("更新記錄失敗:", error);
            const userMessage = handleFirestoreSaveError(error, "更新價格記錄");
            showUserFriendlyError(userMessage);
        }
        setEditingRecord(null);
    };

    // 新增函數：處理衝突解決
    const handleConflictResolution = async (resolutionType) => {
        setIsConflictDialogOpen(false);
        
        switch (resolutionType) {
            case 'local':
                // 保留本地更改，直接退出編輯模式
                await exitEditMode();
                break;
            case 'remote':
                // 保留遠程數據，重新獲取最新數據並退出
                await fetchData();
                setIsEditMode(false);
                setSelectedItems(new Set());
                setOriginalDataSnapshot(null);

                break;
            case 'merge':
                // 手動合併，重新獲取數據並保持編輯模式
                await fetchData();
                setLocalProducts([...allProducts]);
                setLocalRecords({...allRecords});
                // 保持編輯模式開啟，讓用戶繼續編輯
                setOriginalDataSnapshot({
                    products: [...allProducts],
                    records: {...allRecords},
                    timestamp: Date.now()
                });

                break;
            default:
                // 默認情況下直接退出編輯模式
                await exitEditMode();
        }
    };

    const confirmDelete = async () => {
        if (!db || !deletingRecord) return;
        
        // 在編輯模式下，我們只需要更新本地狀態，不需要重新整理畫面
        if (isEditMode) {
            try {
                // 更新本地狀態而不是調用 Firebase
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    if (newRecords[deletingRecord.numericalID]) {
                        newRecords[deletingRecord.numericalID] = newRecords[deletingRecord.numericalID].filter(
                            record => record.id !== deletingRecord.id
                        );
                    }
                    return newRecords;
                });
                
                // 顯示成功消息
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            } finally {
                setDeletingRecord(null);
            }
        } else {
            // 非編輯模式下保持原有行為
            setIsAfterDelete(true); // Signal that the next data fetch is after a delete
            try {
                const recordRef = doc(db, "priceRecords", deletingRecord.id);
                await deleteDoc(recordRef);
                await fetchData(); // 重新獲取數據以更新UI
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            }
            setDeletingRecord(null);
        }
    };

    const handleSearchToggle = () => {
        if (isSearchOpen) {
            setSearchQuery('');
        }
        setIsSearchOpen(!isSearchOpen);
    };

    if (loading) {
        return (
            <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
                <div className="max-w-4xl mx-auto">
                    <div className="flex items-center mb-6">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800">所有記錄</h1>
                    </div>
                    <div className="text-center py-10">
                        {!isAuthReady ? (
                            <p>正在初始化雲端服務，請稍候...</p>
                        ) : !userId ? (
                            <p>正在獲取用戶信息，請稍候...</p>
                        ) : (
                            <p>正在從雲端加載數據...</p>
                        )}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
            <div className="max-w-4xl mx-auto pb-28"> {/* Added pb-28 for floating button */}
                <SuccessMessage message={successMessage} />
                <div className="flex flex-col sm:flex-row sm:items-center justify-between mb-6">
                    <div className="flex items-center mb-4 sm:mb-0">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800 flex items-center"><Database className="mr-2" />所有記錄</h1>
                    </div>
                    <div className="flex items-center">
                        <label className="mr-2 text-gray-700">排序:</label>
                        <select value={sortOption} onChange={(e) => setSortOption(e.target.value)} className="border border-gray-300 rounded p-2 mr-2">
                            <option value="latest">最新記錄</option>
                            <option value="name">產品名稱</option>
                            <option value="price">最新價格</option>
                        </select>
                        <button 
                            onClick={() => {
                                if (!isEditMode) {
                                    // Enter edit mode - copy current data to local state
                                    setLocalProducts([...allProducts]);
                                    setLocalRecords({...allRecords});
                                    // 保存原始數據快照和時間戳
                                    setOriginalDataSnapshot({
                                        products: [...allProducts],
                                        records: {...allRecords},
                                        timestamp: Date.now()
                                    });
                                } else {
                                    // Exit edit mode - 檢查數據版本衝突
                                    checkForConflictsAndExit();
                                }
                                setIsEditMode(!isEditMode);
                                setSelectedItems(new Set());
                            }}
                            className={`px-3 py-2 rounded text-white text-sm ${
                                isEditMode ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'
                            }`}
                        >
                            {isEditMode ? '退出編輯模式' : '編輯模式'}
                        </button>
                    </div>
                </div>

                {/* Floating Delete Button - 修改為固定位置 */}
                {isEditMode && selectedItems.size > 0 && (
                    <div className="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-4 shadow-lg z-50 flex items-center"
                         style={{bottom: '6rem'}}>
                        <button 
                            onClick={handleBulkDeleteClick}
                            className="flex items-center"
                        >
                            <Trash2 size={20} className="mr-2" />
                            刪除選取項目 ({selectedItems.size})
                        </button>
                    </div>
                )}

                {/* Floating Exit Edit Mode Button - 修改為固定位置 */}
                {isEditMode && (
                    <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white rounded-full p-4 shadow-lg z-50">
                        <button 
                            onClick={checkForConflictsAndExit}
                            className="flex items-center"
                        >
                            <X size={20} className="mr-2" />
                            退出編輯模式
                        </button>
                    </div>
                )}

                {filteredProducts.length === 0 ? (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <Database size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">{searchQuery ? '找不到結果' : '暫無記錄'}</h3>
                        <p className="text-gray-500">{searchQuery ? `找不到符合 "${searchQuery}" 的產品` : '還沒有任何產品和價格記錄'}</p>
                    </div>
                ) : (
                    <div>
                        <div className="mb-4 p-4 bg-white rounded-lg shadow">
                            <div className="flex justify-between">
                                <p className="text-gray-700">總共 <span className="font-bold">{filteredProducts.length}</span> 個產品</p>
                                <p className="text-gray-700">總共 <span className="font-bold">{Object.values(allRecords).flat().length}</span> 條記錄</p>
                            </div>
                        </div>
                        {filteredProducts.map(product => {
                            // 修復：確保 records 始終有默認值
                            const records = isEditMode ? (localRecords[product.numericalID] || []) : (allRecords[product.numericalID] || []);
                            // 修改：即使沒有記錄也顯示產品卡片，但只在編輯模式下
                            if (records.length === 0 && !isEditMode) return null;
                            return (
                                // 修改：為選中的項目添加增強的視覺反饋
                                <div key={product.numericalID} className={`relative transition-all duration-200 ${isEditMode && selectedItems.has(product.numericalID) ? 'bg-blue-50 border-2 border-blue-500 rounded-lg' : ''}`}>
                                    {isEditMode && (
                                        <div className="absolute top-4 left-4 z-10">
                                            <input
                                                type="checkbox"
                                                checked={selectedItems.has(product.numericalID)}
                                                onChange={() => handleItemSelect(product.numericalID)}
                                                className="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                                            />
                                        </div>
                                    )}
                                    <div className={isEditMode ? "pl-12" : ""}>
                                        <ProductRecord 
                                            product={product} 
                                            records={records} 
                                            theme={theme} 
                                            onEdit={handleEdit} 
                                            onDelete={handleDelete} 
                                        />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}

                {editingRecord && (
                    <EditModal
                        record={editingRecord}
                        onClose={() => setEditingRecord(null)}
                        onSave={handleSaveEdit}
                    />
                )}

                {deletingRecord && (
                    <DeleteConfirmation
                        record={deletingRecord}
                        onClose={() => setDeletingRecord(null)}
                        onConfirm={confirmDelete}
                    />
                )}

                {/* 新增批量刪除確認對話框 */}
                {isBulkDeleteConfirmationOpen && (
                    <BulkDeleteConfirmation
                        count={selectedItems.size}
                        onClose={() => setIsBulkDeleteConfirmationOpen(false)}
                        onConfirm={deleteSelectedItems}
                    />
                )}

                {/* 新增衝突解決對話框 */}
                {isConflictDialogOpen && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                            <h2 className="text-xl font-bold mb-4">檢測到數據衝突</h2>
                            <p className="mb-4">在您編輯期間，其他用戶修改了部分數據。請選擇如何解決衝突：</p>
                            
                            <div className="mb-6 p-4 bg-yellow-50 rounded-lg">
                                <h3 className="font-semibold text-yellow-800 mb-2">衝突詳情：</h3>
                                <ul className="list-disc pl-5 text-sm text-yellow-700">
                                    <li>數據可能已被人修改</li>
                                    <li>您的更改可能與其他用戶的更改衝突</li>
                                </ul>
                            </div>
                            
                            <div className="space-y-3">
                                <button 
                                    onClick={() => handleConflictResolution('local')}
                                    className="w-full p-3 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                                >
                                    保留我的更改
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('remote')}
                                    className="w-full p-3 bg-green-500 text-white rounded-md hover:bg-green-600"
                                >
                                    保留最新數據
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('merge')}
                                    className="w-full p-3 bg-purple-500 text-white rounded-md hover:bg-purple-600"
                                >
                                    手動合併（推薦）
                                </button>
                            </div>
                            
                            <div className="mt-6 flex justify-end">
                                <button 
                                    onClick={() => setIsConflictDialogOpen(false)}
                                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                                >
                                    取消
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- START: Revamped Search Component --- */}
                <div className="fixed top-6 right-6 z-30">
                    <div 
                        className={`flex items-center justify-end bg-white rounded-full shadow-xl transition-all duration-300 ease-in-out overflow-hidden ${isSearchOpen ? 'w-80' : 'w-16 h-16'}`}
                    >
                        <Search className={`absolute left-5 top-1/2 -translate-y-1/2 text-gray-400 transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`} size={22} />
                        <input
                            ref={searchInputRef}
                            type="text"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="輸入品名進行模糊搜尋..."
                            className={`w-full h-16 pl-14 pr-20 bg-transparent border-none rounded-full outline-none text-lg transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`}
                            style={{pointerEvents: isSearchOpen ? 'auto' : 'none'}}
                        />
                        <button
                            onClick={handleSearchToggle}
                            className="absolute right-0 top-0 w-16 h-16 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 flex items-center justify-center"
                            aria-label={isSearchOpen ? "關閉搜尋" : "開啟搜尋"}
                        >
                            {isSearchOpen ? <X size={28} /> : <Search size={28} />}
                        </button>
                    </div>
                </div>
                {/* --- END: Revamped Search Component --- */}
            </div>
        </div>
    );
}

function EditModal({ record, onClose, onSave }) {
    const [price, setPrice] = useState(record.price);
    const [quantity, setQuantity] = useState(record.quantity || '');
    const [unitType, setUnitType] = useState(record.unitType || 'pcs');
    const [discount, setDiscount] = useState(record.discountDetails || '');
    const [originalPrice, setOriginalPrice] = useState(record.originalPrice || '');
    const [specialPrice, setSpecialPrice] = useState(record.specialPrice || '');
    const [productName, setProductName] = useState(record.productName || '');
    const [storeName, setStoreName] = useState(record.storeName || '');
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);

    const handleSave = () => {
        const newUnitPrice = calculateUnitPrice(price, quantity, unitType);
        if (newUnitPrice === null) {
            alert("請輸入有效的價格和數量。");
            return;
        }
        onSave({ 
            ...record, 
            price: parseFloat(price),
            quantity: parseFloat(quantity),
            unitType: unitType,
            unitPrice: newUnitPrice,
            discountDetails: discount,
            originalPrice: originalPrice ? parseFloat(originalPrice) : null,
            specialPrice: specialPrice ? parseFloat(specialPrice) : null,
            productName: productName,
            storeName: storeName
        });
    };

    const currentUnitPrice = calculateUnitPrice(price, quantity, unitType);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 overflow-hidden">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">編輯記錄</h2>
                <div className="space-y-3">
                    {/* 產品名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">產品名稱</label>
                        <input
                            type="text"
                            value={productName}
                            onChange={(e) => setProductName(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 商店名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">商店名稱</label>
                        <div className="mt-1 flex">
                            <input
                                type="text"
                                value={storeName}
                                onChange={(e) => setStoreName(e.target.value)}
                                className="block flex-grow border border-gray-300 rounded-l-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                placeholder="點擊選擇商店或手動輸入"
                                readOnly
                            />
                            <button 
                                onClick={() => setIsStoreSelectorOpen(true)}
                                className="bg-indigo-600 text-white px-4 py-2 rounded-r-md hover:bg-indigo-700"
                            >
                                選擇
                            </button>
                        </div>
                    </div>
                    
                    {/* 原價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">原價 ($)</label>
                        <input
                            type="number"
                            value={originalPrice}
                            onChange={(e) => setOriginalPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 特價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">特價 ($)</label>
                        <input
                            type="number"
                            value={specialPrice}
                            onChange={(e) => setSpecialPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 總價輸入（實際支付價格） */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">總價 ($)</label>
                        <input
                            type="number"
                            value={price}
                            onChange={(e) => setPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    <div>
                        <label className="block text-sm font-medium text-gray-700">數量</label>
                        <input
                            type="number"
                            value={quantity}
                            onChange={(e) => setQuantity(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單位</label>
                        <select
                            value={unitType}
                            onChange={(e) => setUnitType(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        >
                            <option value="ml">ml (毫升)</option>
                            <option value="g">g (克)</option>
                            <option value="pcs">pcs (個/包/支/條)</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單價 (自動計算)</label>
                        <input
                            type="text"
                            value={currentUnitPrice === null ? 'N/A' : currentUnitPrice.toFixed(2)}
                            readOnly
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-gray-100"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">折扣詳情</label>
                        <input
                            type="text"
                            value={discount}
                            onChange={(e) => setDiscount(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                </div>
                <div className="mt-4 flex justify-between">
                    <button onClick={onClose} className="flex-1 mr-2 items-center bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 flex justify-center">
                        <X size={18} className="mr-1" />
                        取消
                    </button>
                    <button onClick={handleSave} className="flex-1 ml-2 items-center bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 flex justify-center">
                        <Save size={18} className="mr-1" />
                        保存
                    </button>
                </div>
            </div>
            
            {isStoreSelectorOpen && (
                <StoreSelector 
                    onSelect={(selectedStore) => {
                        setStoreName(selectedStore);
                        setIsStoreSelectorOpen(false);
                    }}
                    onClose={() => setIsStoreSelectorOpen(false)}
                    theme={{ primary: 'bg-indigo-600', hover: 'hover:bg-indigo-700', text: 'text-indigo-600' }}
                />
            )}
        </div>
    );
}

function DeleteConfirmation({ record, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p>您確定要刪除這條價格為 ${record.price.toFixed(2)} 的記錄嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}

function SuccessMessage({ message }) {
    if (!message) return null;

    return (
        <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center z-50">
            <CheckCircle size={20} className="mr-2" />
            <span>{message}</span>
        </div>
    );
}



// 新增批量刪除確認對話框組件
function BulkDeleteConfirmation({ count, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認批量刪除</h2>
                <p>您確定要刪除選中的 {count} 個產品項目嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}



export default AllRecordsPage;
</file>

<file path="App.css">
/* 應用基本樣式 */
.App {
  text-align: center;
  min-height: 100vh;
}

/* 自定義樣式可以在這裡添加 */
</file>

<file path="App.js">
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PaintBucket, DollarSign, Barcode, ClipboardCheck, X, Camera, Zap, FileText, RotateCcw, Database, Settings as SettingsIcon } from 'lucide-react';
import AllRecordsPage from './AllRecordsPage';
import StoreSelector from './StoreSelector';
import AIOcrCaptureModal from './components/AIOcrCaptureModal';
import SettingsPage from './components/SettingsPage'; // 新增導入
import { db } from './firebase-config.js'; // <-- 引入 Firebase
import { getAuth, signInAnonymously } from "firebase/auth";
import { doc, getDoc, setDoc, collection, query, where, getDocs, addDoc, orderBy, serverTimestamp } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import OcrQueuePage from './OcrQueuePage';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具
import { v4 as uuidv4 } from 'uuid'; // 引入 uuid 函式庫來生成本地 ID

// ----------------------------------------------------------------------------
// 1. 核心設定與工具函數 (Core Setup & Utilities)
// ----------------------------------------------------------------------------

function djb2Hash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
}

// 以下函數已移至 src/components/AIOcrCaptureModal.js
// callGeminiApiWithRetry
// withExponentialBackoff


function generateProductId(barcode, productName, storeName) {
    if (barcode) {
        return djb2Hash(barcode).toString();
    } else {
        // Combine productName and storeName to create a unique ID for products without barcodes
        // This assumes productName + storeName is sufficiently unique for non-barcoded items
        return djb2Hash(`${productName}-${storeName}`).toString();
    }
}

// ----------------------------------------------------------------------------
// 2. UI 元件 (UI Components)
// ----------------------------------------------------------------------------

const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, theme }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間沒有足夠的變化來繪製趨勢圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1 text-gray-500"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                單價走勢
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke={theme.color === 'red' ? '#EF4444' : '#4F46E5'} strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === 0 ? '#10B981' : theme.primary.split('-')[1]} title={`$${record.displayPrice.toFixed(2)}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>最早: {new Date(minTimestamp).toLocaleDateString()}</span>
                <span>最新: {new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

function PriceHistoryDisplay({ historyRecords, theme }) {
    if (historyRecords.length === 0) {
        return <div className="text-center p-6 text-gray-500 bg-white rounded-xl shadow-md">尚無歷史價格紀錄。</div>;
    }

    const formattedRecords = historyRecords.map(record => ({
        ...record,
        timestamp: record.timestamp?.toDate ? record.timestamp.toDate() : new Date(record.timestamp),
        displayPrice: record.unitPrice !== undefined && record.unitPrice !== null ? record.unitPrice : record.price // Use unitPrice if available, else price
    }));

    return (
        <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${theme.border} mt-8`}>
            <h2 className={`text-xl font-semibold ${theme.text} mb-4`}>價格紀錄 ({formattedRecords.length} 筆)</h2>
            <div className="mb-6"><PriceTrendChart records={formattedRecords} theme={theme} /></div>
            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {formattedRecords.map((record, index) => (
                    <div key={index} className={`p-3 rounded-lg shadow-sm border border-gray-100 ${index === 0 ? theme.light : 'bg-white'}`}>
                        <div className="flex justify-between items-start font-bold">
                            {/* 顯示原價和特價信息 */}
                            {record.specialPrice ? (
                                <span className="text-[22px]">
                                    {record.originalPrice && (
                                        <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                    )}
                                    <span className="text-red-600 ml-2">${record.specialPrice.toFixed(2)}</span>
                                    <span className="text-gray-500 ml-2">@{formatUnitPrice(record.unitPrice)}</span>
                                </span>
                            ) : (
                                <span className="text-[22px] text-red-600">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</span>
                            )}
                            <span className="text-xs text-gray-500">{record.timestamp.toLocaleString()}</span>
                        </div>
                        <p className="text-sm text-gray-700 mt-1">商店: {record.storeName || '未標註'}</p>
                        {/* 顯示數量和單位資訊 */}
                        {record.quantity && record.unitType && <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType} (總價: ${(record.price || 0).toFixed(2)})</p>}
                        {record.discountDetails && <p className="text-xs text-indigo-600 italic">優惠: {record.discountDetails}</p>}
                        {index === 0 && <span className={`text-xs font-semibold px-2 py-0.5 rounded-full text-white ${theme.primary}`}>最新紀錄</span>}
                    </div>
                ))}
            </div>
        </div>
    );
}

const THEMES = {
    'Default (Indigo)': { primary: 'bg-indigo-600', light: 'bg-indigo-100', hover: 'hover:bg-indigo-700', border: 'border-indigo-600', text: 'text-indigo-600', color: 'indigo' },
    '海洋藍 (Ocean Blue)': { primary: 'bg-blue-600', light: 'bg-blue-100', hover: 'hover:bg-blue-700', border: 'border-blue-600', text: 'text-blue-600', color: 'blue' },
    '森林綠 (Forest Green)': { primary: 'bg-green-600', light: 'bg-green-100', hover: 'hover:bg-green-700', border: 'border-green-600', text: 'text-green-600', color: 'green' },
    '夕陽紅 (Sunset Red)': { primary: 'bg-red-600', light: 'bg-red-100', hover: 'hover:bg-red-700', border: 'border-red-600', text: 'text-red-600', color: 'red' },
    '活力橙 (Vibrant Orange)': { primary: 'bg-orange-600', light: 'bg-orange-100', hover: 'hover:bg-orange-700', border: 'border-orange-600', text: 'text-orange-600', color: 'orange' },
    '薰衣草紫 (Lavender)': { primary: 'bg-purple-600', light: 'bg-purple-100', hover: 'hover:bg-purple-700', border: 'border-purple-600', text: 'text-purple-600', color: 'purple' },
};
const DEFAULT_THEME_KEY = 'Default (Indigo)';

function ThemeSelector({ theme, saveTheme, onClose }) {
    const handleThemeChange = (themeKey) => { saveTheme(themeKey); };
    const handleReset = () => { saveTheme(DEFAULT_THEME_KEY); };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 transform transition-all">
                <h3 className={`text-xl font-bold ${theme.text} mb-4 border-b pb-2`}><PaintBucket className="inline-block w-5 h-5 mr-2" />介面配色選項</h3>
                <div className="grid grid-cols-2 gap-4 mb-6">
                    {Object.keys(THEMES).map((themeKey) => {
                        const themeData = THEMES[themeKey];
                        const isSelected = theme.color === themeData.color;
                        return (
                            <button key={themeKey} onClick={() => handleThemeChange(themeKey)}
                                className={`p-3 rounded-lg text-white font-medium shadow-md transition-all ${themeData.primary} ${themeData.hover} ${isSelected ? 'ring-4 ring-offset-2 ring-opacity-70 ring-gray-400' : ''}`}
                                style={{ transform: isSelected ? 'scale(1.05)' : 'scale(1)' }}>
                                {themeKey}
                            </button>
                        );
                    })}
                </div>
                <div className="flex justify-between items-center pt-4 border-t">
                    <button onClick={handleReset} className="flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                        <RotateCcw className="w-4 h-4 mr-1" />清除還原 (預設)
                    </button>
                    <button onClick={onClose} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg ${theme.primary} ${theme.hover} transition-all`}>關閉</button>
                </div>
            </div>
        </div>
    );
}

// AIOcrCaptureModal 組件已移至獨立檔案 src/components/AIOcrCaptureModal.js


// ----------------------------------------------------------------------------
// 3. Firebase 身份驗證與主題設定 (Firebase Auth & Theming)
// ----------------------------------------------------------------------------

function useFirebaseAuthentication() {
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        const auth = getAuth();
        signInAnonymously(auth)
            .then((userCredential) => {
                setUserId(userCredential.user.uid);
                setIsAuthReady(true);
            })
            .catch((error) => {
                console.error("Firebase 匿名登入失敗:", error);
            });
    }, []);

    const [currentTheme, setCurrentTheme] = useState(() => {
        const savedKey = localStorage.getItem('appTheme') || DEFAULT_THEME_KEY;
        return THEMES[savedKey] || THEMES[DEFAULT_THEME_KEY];
    });

    const saveUserTheme = useCallback((themeKey) => {
        localStorage.setItem('appTheme', themeKey);
        setCurrentTheme(THEMES[themeKey] || THEMES[DEFAULT_THEME_KEY]);
    }, []);

    return { userId, isAuthReady, currentTheme, saveUserTheme };
}

// ----------------------------------------------------------------------------
// 4. 結果提示框 (Result Toast)
// ----------------------------------------------------------------------------
function SaveResultToast({ result, onClose }) {
    useEffect(() => {
        let timer;
        if (result) {
            timer = setTimeout(onClose, 5000);
        }
        return () => clearTimeout(timer);
    }, [result, onClose]);

    if (!result) {
        return null;
    }

    const { status, message, productName } = result;

    const theme = {
        success: { bg: 'bg-green-500', text: 'text-white', icon: <ClipboardCheck className="w-6 h-6 mr-3" /> },
        warning: { bg: 'bg-yellow-400', text: 'text-gray-800', icon: <DollarSign className="w-6 h-6 mr-3" /> },
        error: { bg: 'bg-red-500', text: 'text-white', icon: <X className="w-6 h-6 mr-3" /> },
    };

    const currentTheme = theme[status];

    return (
        <div className={`fixed top-20 left-1/2 -translate-x-1/2 max-w-md w-full p-4 rounded-xl shadow-2xl z-[100] ${currentTheme.bg} ${currentTheme.text} transition-all duration-300 ease-in-out`}>
            <div className="flex items-center">
                {currentTheme.icon}
                <div className="flex-grow">
                    <p className="font-bold text-lg">{productName}</p>
                    <p className="text-sm">{message}</p>
                    <p className="text-sm font-semibold mt-1">
                        資料儲存: {status === 'error' ? '失敗' : '成功'} | 
                        比價結果: {status === 'success' ? '是最低價' : (status === 'warning' ? '非最低價' : 'N/A')}
                    </p>
                </div>
                <button onClick={onClose} className="ml-4 p-1 rounded-full hover:bg-white/20"><X className="w-5 h-5" /></button>
            </div>
        </div>
    );
}


// ----------------------------------------------------------------------------
// 5. 主應用程式元件 (App Component)
// ----------------------------------------------------------------------------

function App() {
    const { userId, isAuthReady, currentTheme, saveUserTheme } = useFirebaseAuthentication();
    const streamRef = useRef(null);
    
    const [saveResultToast, setSaveResultToast] = useState(null);

    // UI 狀態
    const [barcode, setBarcode] = useState('');
    const [productName, setProductName] = useState('');
    const [currentPrice, setCurrentPrice] = useState('');
    const [quantity, setQuantity] = useState('');
    const [unitType, setUnitType] = useState('pcs'); // 'g', 'ml', 'pcs'
    const [unitPrice, setUnitPrice] = useState(null);
    const [discountDetails, setDiscountDetails] = useState('');
    const [storeName, setStoreName] = useState('');
    const [productHistory, setProductHistory] = useState([]);
    const [comparisonResult, setComparisonResult] = useState({ message: '等待比價數據...' });
    const [statusMessage, setStatusMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [lookupStatus, setLookupStatus] = useState('ready');
    
    // Modal and Page 狀態
    const [isThemeModalOpen, setIsThemeModalOpen] = useState(false);
    const [isCaptureModalOpen, setIsCaptureModalOpen] = useState(false);
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);
    const [isOcrQueueStoreSelectorOpen, setIsOcrQueueStoreSelectorOpen] = useState(false); // 新增狀態
    const [isSettingsOpen, setIsSettingsOpen] = useState(false); // 新增狀態
    const [editingOcrCard, setEditingOcrCard] = useState(null); // 新增狀態
    
    // 新增 useEffect 來自動清除狀態消息
    useEffect(() => {
        let timer;
        if (statusMessage) {
            timer = setTimeout(() => {
                setStatusMessage('');
            }, 3000); // 3秒後清除消息
        }
        return () => clearTimeout(timer);
    }, [statusMessage]);
    
    // 新增函數：處理數據刷新
    const handleDataRefresh = useCallback((key) => {
        // 如果清除的是 pendingOcrCards，需要更新狀態
        if (key === 'pendingOcrCards' || key === 'ALL') {
            const savedCards = localStorage.getItem('pendingOcrCards');
            setPendingOcrCards(savedCards ? JSON.parse(savedCards) : []);
        }
        // 可以在這裡添加其他需要刷新的狀態
    }, []);

    const [currentPage, setCurrentPage] = useState('main'); // 'main', 'allRecords', 'ocrQueue'
    const [ocrResult, setOcrResult] = useState(null);
    const [capturedImage, setCapturedImage] = useState(null); // 新增的狀態
    
    // 新增狀態：待辨識序列
    const [pendingOcrCards, setPendingOcrCards] = useState(() => {
        // 從 localStorage 恢復待辨識卡片
        const savedCards = localStorage.getItem('pendingOcrCards');
        return savedCards ? JSON.parse(savedCards) : [];
    });
    
    // 新增狀態：跟踪是否已從 Firebase 加載數據
    const [isFirebaseDataLoaded, setIsFirebaseDataLoaded] = useState(false);
    
    // 新增狀態：跟踪上次同步的數據哈希值
    const [lastSyncedDataHash, setLastSyncedDataHash] = useState('');
    
    // 新增狀態：跟踪上次同步時間
    const [lastSyncTime, setLastSyncTime] = useState(0);
    
    // 計算數據哈希值的函數
    const calculateDataHash = useCallback((data) => {
        // 將數據轉換為字符串並計算簡單哈希
        const str = JSON.stringify(data, Object.keys(data).sort());
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 轉換為32位整數
        }
        return hash.toString();
    }, []);
    
    // 新增函數：同步 pendingOcrCards 到 Firebase
    const syncPendingOcrCardsToFirebase = useCallback(async (cards) => {
        // 只有在用戶已認證時才同步（不需要等待 Firebase 數據加載完成）
        if (!isAuthReady || !userId) {
            console.log("Firebase 尚未準備好或無用戶 ID，跳過雲端同步。");
            return;
        }
        
        // 計算當前數據的哈希值
        const currentDataHash = calculateDataHash(cards);
        
        // 檢查是否在短時間內重複同步（頻率限制）
        const now = Date.now();
        const timeSinceLastSync = now - lastSyncTime;
        if (timeSinceLastSync < 5000) { // 5秒內不重複同步
            console.log("同步頻率過高，跳過本次同步。");
            return;
        }
        
        // 如果數據沒有變化，則跳過同步
        if (currentDataHash === lastSyncedDataHash) {
            console.log("數據未發生變化，跳過雲端同步。");
            return;
        }

        try {
            // 使用用戶 ID 作為 Document ID，在 ocrQueues Collection 中
            const queueRef = doc(db, "ocrQueues", userId);

            // 儲存整個卡片陣列 (如果陣列大小在 Firestore 限制內)
            await setDoc(queueRef, {
                cards: cards, // 整個 pendingOcrCards 陣列
                lastUpdated: serverTimestamp(), // 記錄最後更新時間
                userId: userId // 保存用戶 ID
            }, { merge: true });

            console.log("待辨識序列已成功同步至 Firebase 雲端。");
            
            // 更新最後同步的數據哈希值和時間
            setLastSyncedDataHash(currentDataHash);
            setLastSyncTime(now);
            
            // 更新卡片的同步狀態為成功（只更新那些狀態不是成功的卡片）
            const updatedCards = cards.map(card => ({
                ...card,
                syncStatus: card.syncStatus === 'success' ? 'success' : 'success'
            }));
            
            // 只有當有卡片狀態需要更新時才更新狀態
            const needsUpdate = cards.some(card => card.syncStatus !== 'success');
            if (needsUpdate) {
                setPendingOcrCards(updatedCards);
            }
        } catch (error) {
            console.error("Firebase 雲端同步失敗:", error);
            // 不再顯示錯誤給用戶，因為這可能會干擾用戶體驗
            
            // 更新卡片的同步狀態為錯誤（只更新那些狀態不是錯誤的卡片）
            const updatedCards = cards.map(card => ({
                ...card,
                syncStatus: card.syncStatus === 'error' ? 'error' : 'error'
            }));
            
            // 只有當有卡片狀態需要更新時才更新狀態
            const needsUpdate = cards.some(card => card.syncStatus !== 'error');
            if (needsUpdate) {
                setPendingOcrCards(updatedCards);
            }
        }
    }, [isAuthReady, userId, lastSyncedDataHash, lastSyncTime, calculateDataHash]);
    
    // 添加 useEffect 來保存 pendingOcrCards 到 localStorage 和雲端
    useEffect(() => {
        // 1. 本地持久化
        localStorage.setItem('pendingOcrCards', JSON.stringify(pendingOcrCards));
        
        // 2. 雲端同步（不需要等待 Firebase 數據加載完成）
        // 只有當有卡片時才觸發同步
        if (pendingOcrCards.length > 0) {
            syncPendingOcrCardsToFirebase(pendingOcrCards);
        }
    }, [pendingOcrCards, syncPendingOcrCardsToFirebase]);
    
    // 新增 useEffect：從 Firebase 載入數據
    useEffect(() => {
        if (isAuthReady && userId && !isFirebaseDataLoaded) {
            const loadCards = async () => {
                try {
                    const queueRef = doc(db, "ocrQueues", userId);
                    const docSnap = await getDoc(queueRef);

                    // 獲取本地數據
                    const savedLocalCards = localStorage.getItem('pendingOcrCards');
                    let localCards = [];
                    if (savedLocalCards) {
                         try {
                             localCards = JSON.parse(savedLocalCards);
                         } catch (parseError) {
                             console.error("解析本地數據失敗:", parseError);
                             localStorage.removeItem('pendingOcrCards'); // 清除損壞的數據
                         }
                    }
                    
                    // 獲取本地最後更新時間
                    const localLastUpdated = localStorage.getItem('pendingOcrCardsLastUpdated');
                    const localLastUpdatedDate = localLastUpdated ? new Date(localLastUpdated) : new Date(0);

                    if (docSnap.exists() && Array.isArray(docSnap.data().cards)) {
                        const firebaseCards = docSnap.data().cards;
                        const firebaseLastUpdated = docSnap.data().lastUpdated?.toDate?.() || new Date(0);
                        
                        // 比較本地和雲端數據的時間戳
                        // 如果雲端數據比本地新，則使用雲端數據
                        if (firebaseLastUpdated > localLastUpdatedDate) {
                            setPendingOcrCards(firebaseCards);
                            localStorage.setItem('pendingOcrCards', JSON.stringify(firebaseCards)); // 用雲端數據覆蓋本地
                            localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString()); // 更新時間戳
                            console.log("已從 Firebase 恢復待辨識序列。");
                        } 
                        // 如果本地數據比雲端新，則上傳本地數據到雲端
                        else if (firebaseLastUpdated < localLastUpdatedDate && localCards.length > 0) {
                            // 觸發一次同步到雲端
                            syncPendingOcrCardsToFirebase(localCards);
                            console.log("本地數據較新，已同步到 Firebase。");
                        }
                        // 如果數據數量不同，合併數據
                        else if (firebaseCards.length !== localCards.length) {
                            // 創建一個基於 ID 的映射來避免重複
                            const localCardMap = new Map(localCards.map(card => [card.id, card]));
                            const firebaseCardMap = new Map(firebaseCards.map(card => [card.id, card]));
                            
                            // 合併兩個集合
                            const mergedCards = [...localCards];
                            for (const [id, firebaseCard] of firebaseCardMap) {
                                if (!localCardMap.has(id)) {
                                    mergedCards.push(firebaseCard);
                                }
                            }
                            
                            // 按時間戳排序
                            mergedCards.sort((a, b) => a.timestamp - b.timestamp);
                            
                            setPendingOcrCards(mergedCards);
                            localStorage.setItem('pendingOcrCards', JSON.stringify(mergedCards)); // 用合併後的數據覆蓋本地
                            localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString()); // 更新時間戳
                            console.log("已從 Firebase 合併待辨識序列。");
                        }
                        // 如果數據相同，則不需要做任何事情
                        else {
                            console.log("本地和雲端數據一致，無需同步。");
                        }
                    } else {
                        // 如果雲端沒有數據但本地有數據，則上傳本地數據到雲端
                        if (localCards.length > 0) {
                            // 注意：這裡我們不直接調用 syncPendingOcrCardsToFirebase，因為 setPendingOcrCards 會觸發上面的 useEffect
                            // 這樣可以確保數據同步到雲端
                            console.log("雲端沒有數據，本地數據將在下次更新時同步到 Firebase。");
                        }
                    }
                    
                    // 標記 Firebase 數據已加載
                    setIsFirebaseDataLoaded(true);
                } catch (error) {
                    console.error("從 Firebase 載入序列失敗:", error);
                    // 即使加載失敗，也標記為已加載以允許本地操作
                    setIsFirebaseDataLoaded(true);
                }
            };
            loadCards();
        }
    }, [isAuthReady, userId, setPendingOcrCards, syncPendingOcrCardsToFirebase, isFirebaseDataLoaded]);
    
    useEffect(() => {
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const price = parseFloat(finalPrice);
        const qty = parseFloat(quantity);

        if (!isNaN(price) && !isNaN(qty) && qty > 0) {
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(price, qty, unitType);
            setUnitPrice(calculatedUnitPrice);
        } else {
            setUnitPrice(null);
        }
    }, [currentPrice, quantity, unitType, ocrResult]);
    
    // 提前定義所有會被使用的函數，避免 no-use-before-define 警告
    const clearForm = useCallback(() => {
        setBarcode('');
        setProductName('');
        setCurrentPrice('');
        setQuantity('');
        setUnitType('pcs'); // Reset to default unit type
        setUnitPrice(null);
        setDiscountDetails('');
        setStoreName('');
        setProductHistory([]);
        setComparisonResult({ message: '等待比價數據...' });
        setOcrResult(null);
        setLookupStatus('ready');
        setCapturedImage(null); // 清除擷取的圖片
    }, []);

    const stopCameraStream = useCallback(() => {
        console.log("stopCameraStream: Attempting to stop camera.");
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
            console.log("stopCameraStream: Camera stream stopped.");
        }
    }, []);
    
    const startCameraStream = async () => {
        console.log("startCameraStream: Attempting to start camera.");
        if (streamRef.current) {
            return streamRef.current;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
            streamRef.current = stream;
            console.log("startCameraStream: Camera started successfully.");
            return stream;
        } catch (err) {
            console.error("無法存取攝影機:", err);
            setStatusMessage(`無法存取攝影機: ${err.name}`);
            return null;
        }
    };

    const lookupProduct = useCallback(async (barcodeData, currentProductName, currentStoreName) => {
        // 如果 Firebase 尚未初始化，則不執行查詢
        if (!isAuthReady || !userId) {
            return;
        }
        
        const numericalID = generateProductId(barcodeData, currentProductName, currentStoreName);

        // Adjust early exit condition:
        // If no barcode and no product name, or if barcode is too short and no product name,
        // then we can't look up a product.
        if (!numericalID) { // If numericalID couldn't be generated, then we can't look up a product.
            setProductName('');
            setLookupStatus('ready');
            setProductHistory([]);
            return;
        }
        
        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);

            if (productSnap.exists()) {
                setProductName(productSnap.data().productName);
                setLookupStatus('found');
            } else {
                setLookupStatus('new');
            }

            const recordsQueryString = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID), // numericalID is already a string
                orderBy("timestamp", "desc")
            );
            const recordsSnapString = await getDocs(recordsQueryString);
            let records = recordsSnapString.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Attempt to query for numericalID as a number, if it's a valid number string
            const numericalIDAsNumber = parseInt(numericalID, 10);
            if (!isNaN(numericalIDAsNumber) && numericalIDAsNumber.toString() === numericalID) { // Check if it's a pure number string
                const recordsQueryNumber = query(
                    collection(db, "priceRecords"),
                    where("numericalID", "==", numericalIDAsNumber),
                    orderBy("timestamp", "desc")
                );
                const recordsSnapNumber = await getDocs(recordsQueryNumber);
                const recordsNumber = recordsSnapNumber.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Merge and deduplicate records
                const mergedRecordsMap = new Map();
                records.forEach(record => mergedRecordsMap.set(record.id, record));
                recordsNumber.forEach(record => mergedRecordsMap.set(record.id, record));
                records = Array.from(mergedRecordsMap.values()).sort((a, b) => (b.timestamp?.toDate ? b.timestamp.toDate().getTime() : 0) - (a.timestamp?.toDate ? a.timestamp.toDate().getTime() : 0));
            }
            setProductHistory(records);

        } catch (error) {
            console.error("查詢產品失敗 (Firestore):", error);
            setStatusMessage("查詢產品資料時發生錯誤。");
            setLookupStatus('ready');
            setProductHistory([]);
        }
    }, [isAuthReady, userId, setProductName, setLookupStatus, setProductHistory, setStatusMessage]);

    // 新增函數：處理 OCR 隊列的商店選擇
    const handleOcrQueueStoreSelect = useCallback((card) => {
        setEditingOcrCard(card);
        setIsOcrQueueStoreSelectorOpen(true);
    }, [setEditingOcrCard, setIsOcrQueueStoreSelectorOpen]);

    // 新增函數：處理 OCR 隊列的商店選擇確認
    const handleOcrQueueStoreSelectConfirm = useCallback((selectedStore) => {
        if (editingOcrCard) {
            // 更新待辨識卡片的商店名稱
            const updatedCards = pendingOcrCards.map(card => 
                card.id === editingOcrCard.id ? { ...card, storeName: selectedStore } : card
            );
            setPendingOcrCards(updatedCards);
        }
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [editingOcrCard, pendingOcrCards, setPendingOcrCards, setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 新增函數：處理 OCR 隊列的商店選擇器關閉
    const handleOcrQueueStoreSelectorClose = useCallback(() => {
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 正確地提前定義 performSaveAndCompare 函數（必須在 saveAndComparePrice 之前定義）
    const performSaveAndCompare = useCallback(async (selectedStore) => {
        const finalStoreName = selectedStore || storeName;
        const numericalID = generateProductId(barcode, productName, finalStoreName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const priceValue = parseFloat(finalPrice);

        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, quantity, unitType);

        if (!userId || !productName || isNaN(priceValue) || isNaN(parseFloat(quantity)) || parseFloat(quantity) <= 0 || calculatedUnitPrice === null) {
            showUserFriendlyError("請確保已輸入條碼、產品名稱、有效總價、數量和單位！", "資料驗證");
            setIsLoading(false);
            return;
        }
        if (!finalStoreName.trim()) {
            setIsStoreSelectorOpen(true);
            setIsLoading(false);
            return;
        }

        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);
            
            // 準備產品文檔數據
            const productData = {
                numericalID,
                barcodeData: barcode,
                productName,
                createdAt: productSnap.exists() ? productSnap.data().createdAt : serverTimestamp(),
                lastUpdatedBy: userId,
            };

            // 準備價格記錄數據
            const priceRecord = {
                numericalID,
                productName,
                storeName: finalStoreName,
                price: priceValue, // 總價
                quantity: parseFloat(quantity),
                unitType: unitType,
                unitPrice: calculatedUnitPrice, // 單價
                discountDetails: discountDetails || '',
                timestamp: serverTimestamp(),
                recordedBy: userId,
                // 保存原價和特價信息（如果有的話）
                originalPrice: ocrResult?.originalPrice ? parseFloat(ocrResult.originalPrice) : null,
                specialPrice: ocrResult?.specialPrice ? parseFloat(ocrResult.specialPrice) : null
            };

            // 儲存價格記錄
            const priceRecordDocRef = await addDoc(collection(db, "priceRecords"), priceRecord);
            
            // 檢查是否需要更新產品文檔中的最佳單價
            let isBestPrice = false;
            if (productSnap.exists()) {
                const existingProductData = productSnap.data();
                // 如果產品文檔中沒有 bestUnitPrice 或新價格更低，則更新
                if (existingProductData.bestUnitPrice === undefined || calculatedUnitPrice < existingProductData.bestUnitPrice) {
                    productData.bestUnitPrice = calculatedUnitPrice;
                    productData.bestPriceRecordRef = priceRecordDocRef.path; // 儲存指向最佳價格記錄的引用路徑
                    isBestPrice = true;
                } else {
                    // 保持現有的最佳價格信息
                    productData.bestUnitPrice = existingProductData.bestUnitPrice;
                    productData.bestPriceRecordRef = existingProductData.bestPriceRecordRef;
                }
            } else {
                // 新產品，當前價格就是最佳價格
                productData.bestUnitPrice = calculatedUnitPrice;
                productData.bestPriceRecordRef = priceRecordDocRef.path;
                isBestPrice = true;
            }
            
            // 儲存或更新產品文檔
            await setDoc(productRef, productData);

            // 準備比價結果
            let toastStatus, toastMessage, isBest, bestPrice, bestStore;

            if (isBestPrice) {
                isBest = true;
                bestPrice = calculatedUnitPrice;
                bestStore = finalStoreName;
                toastStatus = 'success';
                toastMessage = '恭喜！這是目前紀錄中的最低單價！';
            } else {
                isBest = false;
                bestPrice = productData.bestUnitPrice;
                
                // 從 Firestore 獲取最佳價格記錄的商店名稱
                try {
                    const bestPriceRecordDoc = await getDoc(doc(db, productData.bestPriceRecordRef));
                    if (bestPriceRecordDoc.exists()) {
                        bestStore = bestPriceRecordDoc.data().storeName;
                    } else {
                        bestStore = '未知商店';
                    }
                } catch (error) {
                    console.error("獲取最佳價格記錄失敗:", error);
                    bestStore = '未知商店';
                }
                
                toastStatus = 'warning';
                toastMessage = `非最低單價。歷史最低單價為 $${formatUnitPrice(productData.bestUnitPrice)} (${bestStore})`;
            }

            setComparisonResult({ isBest, bestPrice, bestStore, message: toastMessage });
            // 儲存成功時顯示提示訊息
            setSaveResultToast({ status: toastStatus, message: toastMessage, productName: productName });
            
            lookupProduct(barcode, productName, finalStoreName);

        } catch (error) {
            console.error("儲存或比價失敗 (Firestore):", error);
            const userMessage = handleFirestoreSaveError(error, "儲存價格資訊");
            showUserFriendlyError(userMessage);
        } finally {
            setIsLoading(false);
        }
    }, [userId, barcode, productName, currentPrice, discountDetails, storeName, lookupProduct, quantity, unitType, setSaveResultToast, setComparisonResult, setIsLoading, setIsStoreSelectorOpen, ocrResult]);

    // 正確地提前定義 saveAndComparePrice 函數
    const saveAndComparePrice = useCallback(async (selectedStore) => {
        // 確保 Firebase 已初始化，如果尚未完成初始化則強制初始化
        if (!isAuthReady) {
            // 顯示加載訊息並等待初始化完成
            setIsLoading(true);
            // 等待 Firebase 初始化完成
            const checkAuth = () => {
                if (isAuthReady) {
                    // 初始化完成後繼續執行
                    performSaveAndCompare(selectedStore);
                } else {
                    // 繼續等待
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
            return;
        }
        
        // 如果 Firebase 已準備好，直接執行保存操作
        performSaveAndCompare(selectedStore);
    }, [isAuthReady, performSaveAndCompare]);
    
    const handleAiCaptureSuccess = useCallback((result) => {
        const { scannedBarcode, productName, extractedPrice, storeName, discountDetails, quantity, unitType, specialPrice, capturedImage: receivedImage } = result;
        setOcrResult(result);
        
        // 設置捕獲的圖像
        if (receivedImage) {
            setCapturedImage(receivedImage);
        }
        
        const newBarcode = scannedBarcode || '';
        setBarcode(newBarcode);

        if (!newBarcode) {
            setStatusMessage("AI 未能識別條碼，請手動輸入或確保條碼清晰！");
        } else {
            setStatusMessage(`AI 分析成功！`);
        }

        setProductName(productName || '');
        
        // 優先使用特價，如果有的話
        const finalPrice = specialPrice && !isNaN(parseFloat(specialPrice)) ? specialPrice : extractedPrice;
        setCurrentPrice(finalPrice || '');
        
        setStoreName(storeName || '');
        setDiscountDetails(discountDetails || '');

        setQuantity(quantity || '');
        setUnitType(unitType || 'pcs');

        if (productName && newBarcode) {
            setLookupStatus('found');
        } else {
            setLookupStatus('new');
        }
    }, [setBarcode, setProductName, setCurrentPrice, setStoreName, setDiscountDetails, setOcrResult, setStatusMessage, setLookupStatus, setQuantity, setUnitType, setCapturedImage]);

    // 定義一個新的函式來處理 Firebase 備份
    const backupOcrCardToFirebase = useCallback(async (cardData) => {
        // 檢查 Firebase 是否準備好
        if (!isAuthReady || !userId) {
            // 由於功能要求是自動備份，若服務未準備好，則將其視為 pending 或 error (可選)
            console.warn("Firebase 服務尚未準備好，跳過備份。");
            // 由於此專案似乎有 MVP 階段屏蔽 Firebase 的歷史需求，
            // 這裡可以選擇將狀態設為 'error' 或保留 'pending'。
            // 為避免影響核心功能，建議在此處直接返回，讓卡片保持 'pending' 狀態。
            return;
        }

        const cardToSave = {
            ...cardData,
            userId: userId, // 儲存用戶 ID
            timestamp: serverTimestamp(), // 使用 Firebase 服務器時間戳
            // 移除本地 ID 和同步狀態，因為這些只用於本地 UI
            id: undefined, 
            syncStatus: undefined
        };

        try {
            // 將卡片數據儲存到 pendingOcrCards 集合
            const docRef = await addDoc(collection(db, "pendingOcrCards"), cardToSave);
            
            // 成功後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'success', fbDocId: docRef.id } : c
                )
            );

        } catch (error) {
            console.error("Firebase 待辨識卡片備份失敗:", error);
            handleFirestoreSaveError(error, "備份待辨識卡片"); // 使用錯誤處理機制
            
            // 失敗後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'error' } : c
                )
            );
        }
    }, [isAuthReady, userId, setPendingOcrCards]);

    // 新增函數：將辨識結果加入待確認序列
    const handleQueueNextCapture = useCallback((result) => {
        // 1. 建立具有初始同步狀態的新卡片物件
        const newCard = {
            ...result,
            id: uuidv4(), // 確保本地狀態有一個唯一 ID
            timestamp: Date.now(), // 本地時間戳 (用於排序/顯示)
            syncStatus: 'pending', // 初始狀態設為處理中
        };
        
        // 2. 更新本地狀態 (立即顯示卡片)
        setPendingOcrCards(prev => [...prev, newCard]);
        
        // 3. 更新本地時間戳
        localStorage.setItem('pendingOcrCardsLastUpdated', new Date().toISOString());

        // 4. 觸發 Firebase 備份
        backupOcrCardToFirebase(newCard); 
        
        setStatusMessage(`已將辨識結果加入待確認序列！`);
    }, [setPendingOcrCards, backupOcrCardToFirebase]);

    // 新增函數：移除待確認的辨識卡片
    const handleRemovePendingOcrCard = useCallback((cardId) => {
        setPendingOcrCards(prev => prev.filter(item => item.id !== cardId));
    }, []);

    const handleStoreSelect = useCallback((selectedStore) => {
        setStoreName(selectedStore);
        setIsStoreSelectorOpen(false);
        // 不再自動觸發保存操作，與其他頁面保持一致
    }, [setStoreName, setIsStoreSelectorOpen]);

    const handleCaptureModalClose = useCallback(() => {
        setIsCaptureModalOpen(false);
        stopCameraStream();
    }, [stopCameraStream]);

    const handleNewScanClick = async () => {
        clearForm();
        const stream = await startCameraStream();
        if (stream) {
            setIsCaptureModalOpen(true);
        } else {
            // 如果無法啟動相機，顯示錯誤訊息
            setStatusMessage("無法啟動相機，請檢查權限設置");
        }
    };

    const themePrimary = currentTheme.primary;
    const themeText = currentTheme.text;
    const themeLight = currentTheme.light;
    const themeBorder = currentTheme.border;
    const themeHover = currentTheme.hover; // 添加這一行來定義 themeHover

    const productNamePlaceholder = useMemo(() => {
        switch(lookupStatus) {
            case 'searching': return '正在查詢產品資料...';
            case 'found': return '產品名稱已自動載入';
            case 'new': return '產品不存在，請手動輸入名稱';
            default: return '請先輸入條碼或掃描條碼';
        }
    }, [lookupStatus]);

    if (!isAuthReady) {
        return <div className="flex items-center justify-center min-h-screen bg-gray-50"><p className="text-xl text-gray-700">正在連線至雲端服務...</p></div>;
    }

    if (currentPage === 'allRecords') {
        return <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />;
    }

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${themeLight}`}>
            <SaveResultToast result={saveResultToast} onClose={() => setSaveResultToast(null)} />
            
            {/* 新增 SettingsPage 的渲染 */}
            {isSettingsOpen && (
                <SettingsPage 
                    theme={currentTheme} 
                    onClose={() => setIsSettingsOpen(false)} 
                    onDataChange={handleDataRefresh}
                />
            )}

            {/* 根據 currentPage 狀態渲染不同頁面 */}
            {currentPage === 'main' && (
                <div className="max-w-xl mx-auto">
                    <header className="flex justify-between items-center mb-6 border-b pb-4">
                        <h1 className={`text-3xl font-extrabold ${themeText} flex items-center`}><Barcode className="w-8 h-8 mr-2" />條碼比價神器 (Cloud)</h1>
                        <div className="flex items-center space-x-3">
                            {/* 新增待辨識的按鈕 */}
                            <button 
                                onClick={() => setCurrentPage('ocrQueue')}
                                className={`relative p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`}
                                title={`待辨識 (${pendingOcrCards.length})`}
                            >
                                <Zap className="w-5 h-5" />
                                {pendingOcrCards.length > 0 && (
                                    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                                        {pendingOcrCards.length}
                                    </span>
                                )}
                            </button>
                            <button onClick={() => setCurrentPage('allRecords')} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="查看所有記錄"><Database className="w-5 h-5" /></button>
                            <button onClick={() => setIsThemeModalOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定介面主題"><PaintBucket className="w-5 h-5" /></button>
                            {/* 新增設定按鈕 */}
                            <button onClick={() => setIsSettingsOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定"><SettingsIcon className="w-5 h-5" /></button>
                            <p className="text-sm text-gray-500 hidden sm:block">User: {userId.slice(0, 8)}...</p>
                        </div>
                    </header>

                    {statusMessage && <div className="bg-blue-500 text-white p-3 rounded-lg shadow-md mb-4 text-center font-medium">{statusMessage}</div>}

                    {ocrResult && (
                        <div className="bg-yellow-100 border border-yellow-300 rounded-lg p-4 mb-6">
                            <h3 className="text-lg font-semibold text-yellow-800 mb-2">AI 辨識結果 (開發者確認區)</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm">
                                <div>條碼:</div><div>{ocrResult.scannedBarcode || 'N/A'}</div>
                                <div>品名:</div><div>{ocrResult.productName || 'N/A'}</div>
                                {/* 顯示原價和特價信息 */}
                                {ocrResult.specialPrice ? (
                                    <>
                                        {ocrResult.originalPrice && (
                                            <>
                                                <div>原價:</div><div className="line-through text-red-500">${ocrResult.originalPrice.toFixed(2)}</div>
                                            </>
                                        )}
                                        <div>特價:</div><div className="text-green-600 font-bold">${ocrResult.specialPrice.toFixed(2)}</div>
                                    </>
                                ) : (
                                    <>
                                        <div>價格:</div><div>${ocrResult.extractedPrice || 'N/A'}</div>
                                    </>
                                )}
                                <div>數量:</div><div>{ocrResult.quantity || 'N/A'}</div>
                                <div>商店:</div><div>{ocrResult.storeName || 'N/A'}</div>
                                <div>折扣:</div><div>{ocrResult.discountDetails || '無'}</div>
                            </div>
                            <button onClick={() => setOcrResult(null)} className="mt-3 px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 text-sm">關閉</button>
                        </div>
                    )}

                    <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${themeBorder}`}>
                        <h2 className={`text-xl font-semibold ${themeText} mb-6 flex items-center`}><Zap className="w-5 h-5 mr-2" />步驟 1: AI 視覺自動擷取</h2>
                        <button className={`w-full p-4 rounded-lg text-white font-bold text-lg shadow-xl transition-all ${themePrimary} hover:opacity-80 flex items-center justify-center`} onClick={handleNewScanClick}>
                            <Camera className="inline-block w-6 h-6 mr-3" />開啟鏡頭擷取
                        </button>
                        <hr className="my-6 border-gray-200" />
                        <h2 className={`text-xl font-semibold text-gray-700 mb-4 flex items-center`}><FileText className="w-5 h-5 mr-2" />步驟 2: 檢查或手動輸入</h2>
                        
                        {/* 新增的擷取畫面顯示區塊 */}
                        {capturedImage && (
                            <div className="mb-6">
                                <label className="block text-gray-700 font-medium mb-2">擷取畫面 (請確認辨識資料是否正確)</label>
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                    <div className="relative w-full aspect-video">
                                        {capturedImage.startsWith('data:image') ? (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        ) : (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        )}
                                    </div>
                                </div>
                                <p className="text-sm text-gray-500 mt-2">此圖片將持續顯示直到進行下一次辨識或退出應用程式</p>
                            </div>
                        )}
                        
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">條碼數據</label>
                            <input type="text" value={barcode} onChange={(e) => setBarcode(e.target.value)} placeholder="AI 自動填入，或手動輸入" className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" />
                        </div>
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">產品名稱</label>
                            <input type="text" value={productName} onChange={(e) => setProductName(e.target.value)} placeholder={productNamePlaceholder} className={`w-full p-3 border border-gray-300 rounded-lg ${lookupStatus === 'found' ? 'bg-green-50' : lookupStatus === 'new' ? 'bg-yellow-50' : ''}`} readOnly={lookupStatus === 'found' && !ocrResult} />
                            <p className="text-sm text-gray-500 mt-1">ID (Hash): {barcode ? djb2Hash(barcode) : 'N/A'}</p>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">總價 ($) <span className="text-red-500">*</span></label>
                                <input type="number" value={currentPrice} onChange={(e) => setCurrentPrice(e.target.value)} placeholder="AI 擷取" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">商店名稱</label>
                                <input 
                                    type="text" 
                                    value={storeName} 
                                    onFocus={() => setIsStoreSelectorOpen(true)}
                                    readOnly
                                    placeholder="點擊選擇商店"
                                    className="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 cursor-pointer"
                                />
                            </div>
                        </div>
                        <div className="grid grid-cols-3 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">數量 <span className="text-red-500">*</span></label>
                                <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="例如: 500" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單位 <span className="text-red-500">*</span></label>
                                <select value={unitType} onChange={(e) => setUnitType(e.target.value)} className="w-full p-3 border border-gray-300 rounded-lg">
                                    <option value="ml">ml (毫升)</option>
                                    <option value="g">g (克)</option>
                                    <option value="pcs">pcs (個/包/支/條)</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單價 (每100g/ml)</label>
                                <input type="text" value={formatUnitPrice(unitPrice)} readOnly className="w-full p-3 border border-gray-300 rounded-lg bg-gray-100" />
                            </div>
                        </div>
                        <div className="mb-6">
                            <label className="block text-gray-700 font-medium mb-1">優惠細節</label>
                            <input type="text" value={discountDetails} onChange={(e) => setDiscountDetails(e.target.value)} placeholder="例如: 買二送一" className="w-full p-3 border border-gray-300 rounded-lg" />
                        </div>
                        <button className={`w-full mt-4 p-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-emerald-500 hover:bg-emerald-600`} onClick={() => saveAndComparePrice()} disabled={isLoading}>
                            <ClipboardCheck className="inline-block w-5 h-5 mr-2" />{isLoading ? '處理中...' : '步驟 3: 儲存紀錄並比價'}
                        </button>
                    </div>

                    <div className="mt-8">
                        <h2 className={`text-xl font-semibold ${themeText} mb-4 flex items-center`}>
                            <DollarSign className="w-5 h-5 mr-2" />
                            比價結果 {productName && <span className="ml-2 font-normal text-gray-500">- {productName}</span>}
                        </h2>
                        <div className={`p-6 rounded-xl shadow-xl border-2 ${comparisonResult.isBest ? 'border-green-500 bg-green-50' : 'border-yellow-500 bg-yellow-50'}`}>
                            <p className={`text-lg font-bold ${comparisonResult.isBest ? 'text-green-700' : 'text-yellow-700'}`}>{comparisonResult.message}</p>
                            {comparisonResult.bestPrice && <p className="text-sm text-gray-600 mt-2">歷史最低標價: ${comparisonResult.bestPrice}</p>}
                            <p className="text-xs text-gray-500 mt-2">**附註:** 您的紀錄已安全儲存在雲端。</p>
                        </div>
                    </div>

                    {(lookupStatus === 'found' || lookupStatus === 'new') && <PriceHistoryDisplay historyRecords={productHistory} theme={currentTheme} />}
                    
                    {/* 在主介面添加一個快捷處理待辨識卡片的按鈕 */}
                    {pendingOcrCards.length > 0 && (
                        <div className="mt-4 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold text-yellow-800">有待辨識的項目</h3>
                                    <p className="text-sm text-yellow-600">您有 {pendingOcrCards.length} 個待辨識的項目等待處理</p>
                                </div>
                                <button 
                                    onClick={() => {
                                        // 處理第一個待辨識的卡片
                                        const firstCard = pendingOcrCards[0];
                                        
                                        // 設置表單數據
                                        setOcrResult(firstCard);
                                        setCapturedImage(firstCard.capturedImage);
                                        setBarcode(firstCard.scannedBarcode || '');
                                        setProductName(firstCard.productName || '');
                                        setCurrentPrice(firstCard.extractedPrice || '');
                                        setStoreName(firstCard.storeName || '');
                                        setDiscountDetails(firstCard.discountDetails || '');
                                        setQuantity(firstCard.quantity || '');
                                        setUnitType(firstCard.unitType || 'pcs');
                                        
                                        // 計算單價
                                        const priceValue = parseFloat(firstCard.extractedPrice);
                                        const qty = parseFloat(firstCard.quantity);
                                        if (!isNaN(priceValue) && !isNaN(qty) && qty > 0) {
                                            const calculatedUnitPrice = calculateUnitPrice(priceValue, qty, firstCard.unitType);
                                            setUnitPrice(calculatedUnitPrice);
                                        }
                                        
                                        // 更新狀態
                                        if (firstCard.productName && firstCard.scannedBarcode) {
                                            setLookupStatus('found');
                                        } else {
                                            setLookupStatus('new');
                                        }
                                        
                                        // 從待辨識序列中移除該卡片
                                        setPendingOcrCards(prev => prev.filter(item => item.id !== firstCard.id));
                                        
                                        // 顯示提示訊息
                                        setStatusMessage(`已載入待辨識項目: ${firstCard.productName || '未命名產品'}`);
                                    }}
                                    className={`px-4 py-2 rounded-lg text-white font-medium ${themePrimary} ${themeHover}`}
                                >
                                    處理第一個待辨識項目
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            )}
            
            {currentPage === 'allRecords' && (
                <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />
            )}
            
            {currentPage === 'ocrQueue' && (
                <OcrQueuePage 
                    theme={currentTheme} 
                    onBack={() => setCurrentPage('main')} 
                    pendingOcrCards={pendingOcrCards}
                    onRemoveCard={handleRemovePendingOcrCard}
                    onStoreSelect={setPendingOcrCards}
                    isStoreSelectorOpen={isOcrQueueStoreSelectorOpen}
                    onStoreSelectCallback={handleOcrQueueStoreSelect}
                    onCloseStoreSelector={handleOcrQueueStoreSelectorClose}
                />
            )}

            {isThemeModalOpen && <ThemeSelector theme={currentTheme} saveTheme={saveUserTheme} onClose={() => setIsThemeModalOpen(false)} />}
            {isCaptureModalOpen && <AIOcrCaptureModal theme={currentTheme} onAnalysisSuccess={handleAiCaptureSuccess} onClose={handleCaptureModalClose} stream={streamRef.current} onQueueNextCapture={handleQueueNextCapture} />}
            {isStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleStoreSelect} onClose={() => setIsStoreSelectorOpen(false)} />}
            {isOcrQueueStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleOcrQueueStoreSelectConfirm} onClose={handleOcrQueueStoreSelectorClose} />}
        </div>
    );
}

export default App;
</file>

<file path="components/AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        
        // 計算預覽框在視頻中的實際像素位置和尺寸 (75% 中心區域)
        const cropWidth = video.videoWidth * 0.75;
        const cropHeight = video.videoHeight * 0.75;
        const cropX = (video.videoWidth - cropWidth) / 2;
        const cropY = (video.videoHeight - cropHeight) / 2;
        
        // 創建最終的 canvas 來繪製裁切後的圖片
        const canvas = document.createElement('canvas');
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        const ctx = canvas.getContext('2d');
        
        // 從視頻中裁切並繪製 75% 中心區域
        ctx.drawImage(
            video, 
            cropX, cropY, cropWidth, cropHeight,  // source rectangle
            0, 0, cropWidth, cropHeight           // destination rectangle
        );
        
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片

        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
components.xml
DataManagement.js
SettingsPage.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

</files>
</file>

<file path="DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

</files>
</file>

<file path="components/DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="components/SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

<file path="firebase-config.js">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAtaZL06wkWJHhOJdne2Z_h9fMIEYldgjM",
  authDomain: "barcodepricing-00898.firebaseapp.com",
  projectId: "barcodepricing-00898",
  storageBucket: "barcodepricing-00898.firebasestorage.app",
  messagingSenderId: "286146042453",
  appId: "1:286146042453:web:14a20a662dcf3d06f592dc",
  measurementId: "G-6GMRVJ4S52"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

export { db };
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="OcrQueuePage.js">
import React, { useState, useEffect, useCallback } from 'react';
import { ArrowLeft, Trash2, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { db } from './firebase-config.js';
import { doc, setDoc, addDoc, collection, serverTimestamp, getDoc, query, where, getDocs } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 計算 localStorage 使用量的函數
function getLocalStorageUsage() {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += (localStorage[key].length + key.length) * 2; // 每個字符佔用 2 bytes
    }
  }
  const used = (total / 1024).toFixed(2); // 轉換為 KB
  const quota = 5120; // 大多数瀏覽器的 localStorage 限制約為 5MB
  const percentage = ((used / quota) * 100).toFixed(2);
  
  return {
    used: used,
    quota: quota,
    percentage: percentage
  };
}

// 刪除確認對話框組件
function DeleteConfirmation({ card, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p className="mb-4">您確定要刪除此待辨識項目嗎？</p>
                <p className="mb-4 font-semibold text-gray-800">{card.productName || '未命名產品'}</p>
                <div className="flex justify-end space-x-3">
                    <button 
                        onClick={onClose}
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                    >
                        取消
                    </button>
                    <button 
                        onClick={onConfirm}
                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                    >
                        確認刪除
                    </button>
                </div>
            </div>
        </div>
    );
}

function OcrQueuePage({ theme, onBack, pendingOcrCards, onRemoveCard, onStoreSelect, 
    isStoreSelectorOpen, onStoreSelectCallback, onCloseStoreSelector }) {
    const [queueStats, setQueueStats] = useState({
        total: 0,
        oldest: null,
        newest: null
    });
    
    // 新增狀態：localStorage 使用量
    const [localStorageUsage, setLocalStorageUsage] = useState({
        used: 0,
        quota: 5120,
        percentage: 0
    });
    
    // 新增狀態：刪除確認對話框
    const [deleteConfirmation, setDeleteConfirmation] = useState(null);
    
    // 新增狀態：正在編輯的卡片
    // 移除 editingCard 狀態，因為現在由父組件控制
    // const [editingCard, setEditingCard] = useState(null);
    
    // 新增狀態：比價結果
    const [priceComparisonResults, setPriceComparisonResults] = useState({});

    useEffect(() => {
        if (pendingOcrCards.length > 0) {
            const timestamps = pendingOcrCards.map(card => card.timestamp);
            setQueueStats({
                total: pendingOcrCards.length,
                oldest: Math.min(...timestamps),
                newest: Math.max(...timestamps)
            });
        } else {
            setQueueStats({
                total: 0,
                oldest: null,
                newest: null
            });
        }
        
        // 更新 localStorage 使用量
        setLocalStorageUsage(getLocalStorageUsage());
    }, [pendingOcrCards]);

    const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleString('zh-TW');
    };

    const calculateDuration = (timestamp) => {
        const now = Date.now();
        const diffMs = now - timestamp;
        const diffSecs = Math.floor(diffMs / 1000);
        const diffMins = Math.floor(diffSecs / 60);
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            return `${diffHours}小時前`;
        } else if (diffMins > 0) {
            return `${diffMins}分鐘前`;
        } else {
            return `${diffSecs}秒前`;
        }
    };

    // 處理刪除操作
    const handleDeleteClick = (card) => {
        setDeleteConfirmation(card);
    };

    // 確認刪除
    const confirmDelete = () => {
        if (deleteConfirmation) {
            onRemoveCard(deleteConfirmation.id);
            setDeleteConfirmation(null);
            // 刪除後更新 localStorage 使用量
            setTimeout(() => {
                setLocalStorageUsage(getLocalStorageUsage());
            }, 100);
        }
    };

    // 取消刪除
    const cancelDelete = () => {
        setDeleteConfirmation(null);
    };

    // 處理儲存操作 - 檢查商店名稱
    const handleSaveClick = async (card) => {
        // 檢查商店名稱是否為空白
        if (!card.storeName || card.storeName.trim() === '') {
            // 如果商店名稱為空白，顯示商店選擇器
            onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
        } else {
            // 如果商店名稱不為空白，直接儲存（不再彈出確認對話框）
            try {
                // 儲存到 Firebase
                await saveOcrCardToFirebase(card);
                
                // 從待辨識序列中移除
                onRemoveCard(card.id);
                
                // 儲存後更新 localStorage 使用量
                setTimeout(() => {
                    setLocalStorageUsage(getLocalStorageUsage());
                }, 100);
                
                // 儲存成功時不顯示任何訊息
            } catch (error) {
                console.error("儲存失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "儲存待辨識卡片");
                showUserFriendlyError(userMessage);
            }
        }
    };

    // 處理卡片欄位變更
    const handleCardChange = (cardId, field, value) => {
        const updatedCards = pendingOcrCards.map(card => 
            card.id === cardId ? { ...card, [field]: value } : card
        );
        onStoreSelect(updatedCards);
        
        // 當價格相關欄位變更時，重新計算比價結果
        if (field === 'extractedPrice' || field === 'specialPrice' || field === 'originalPrice' || field === 'quantity' || field === 'unitType') {
            // 延遲一點時間再重新計算，確保狀態已更新
            setTimeout(() => {
                const fetchPriceComparisonResults = async () => {
                    const results = {};
                    for (const card of updatedCards) {
                        const result = await checkIfBestPrice(card, updatedCards);
                        results[card.id] = result;
                    }
                    setPriceComparisonResults(results);
                };
                
                fetchPriceComparisonResults();
            }, 0);
        }
    };

    // 處理商店欄位點擊
    const handleStoreClick = (card) => {
        // 阻止默认行为，防止移动设备上弹出键盘
        onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
    };

    // 儲存 OCR 卡片到 Firebase
    const saveOcrCardToFirebase = async (card) => {
        // 生成產品 ID
        const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
        const priceValue = parseFloat(finalPrice);
        
        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
        
        // 儲存產品資訊
        const productRef = doc(db, "products", numericalID.toString());
        const productSnap = await getDoc(productRef);
        if (!productSnap.exists()) {
            await setDoc(productRef, {
                numericalID,
                barcodeData: card.scannedBarcode,
                productName: card.productName,
                createdAt: serverTimestamp(),
                lastUpdatedBy: "ocr-queue", // 標記為來自 OCR 隊列
            });
        }
        
        // 儲存價格記錄
        const priceRecord = {
            numericalID,
            productName: card.productName,
            storeName: card.storeName,
            price: priceValue, // 總價
            quantity: parseFloat(card.quantity),
            unitType: card.unitType,
            unitPrice: calculatedUnitPrice, // 單價
            discountDetails: card.discountDetails || '',
            timestamp: serverTimestamp(),
            recordedBy: "ocr-queue", // 標記為來自 OCR 隊列
            // 保存原價和特價信息（如果有的話）
            originalPrice: card.originalPrice ? parseFloat(card.originalPrice) : null,
            specialPrice: card.specialPrice ? parseFloat(card.specialPrice) : null
        };
        
        await addDoc(collection(db, "priceRecords"), priceRecord);
    };

    // 生成產品 ID 的函數
    function generateProductId(barcode, productName, storeName) {
        function djb2Hash(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i);
            }
            return hash >>> 0;
        }
        
        if (barcode) {
            return djb2Hash(barcode).toString();
        } else {
            // Combine productName and storeName to create a unique ID for products without barcodes
            return djb2Hash(`${productName}-${storeName}`).toString();
        }
    }

    // 新增函數：檢查價格是否為歷史最低（包含待辨識序列中的卡片）
    const checkIfBestPrice = useCallback(async (card, allCards) => {
        try {
            // 生成產品 ID
            const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
            
            if (!numericalID) return null;
            
            // 使用新的價格計算函數來確定最終價格
            const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
            const priceValue = parseFloat(finalPrice);
            
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
            
            if (calculatedUnitPrice === null) return null;
            
            // 查詢 Firebase 中該產品的所有價格記錄
            const recordsQuery = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID)
            );
            
            const recordsSnap = await getDocs(recordsQuery);
            const records = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 準備所有記錄以進行比較（包括當前記錄和待辨識序列中的相同產品）
            let allRecordsForCompare = [...records, { 
                unitPrice: calculatedUnitPrice,
                timestamp: new Date()
            }];
            
            // 添加待辨識序列中相同產品的卡片（排除當前卡片）
            const sameProductCards = allCards.filter(c => 
                c.id !== card.id && 
                generateProductId(c.scannedBarcode, c.productName, c.storeName) === numericalID
            );
            
            // 將相同產品的卡片添加到比較列表中
            sameProductCards.forEach(c => {
                const cardFinalPrice = calculateFinalPrice(c.extractedPrice, c.specialPrice);
                const cardPriceValue = parseFloat(cardFinalPrice);
                const cardUnitPrice = calculateUnitPrice(cardPriceValue, c.quantity, c.unitType);
                
                if (cardUnitPrice !== null) {
                    allRecordsForCompare.push({
                        unitPrice: cardUnitPrice,
                        timestamp: new Date(c.id) // 使用卡片 ID 作為時間戳
                    });
                }
            });

            // 如果沒有歷史記錄，則當前價格就是最低價
            if (allRecordsForCompare.length <= 1) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            }
            
            // 使用與主頁面相同的比價邏輯
            const bestDeal = allRecordsForCompare.reduce((best, cur) => {
                const curUnitPrice = cur.unitPrice !== undefined && cur.unitPrice !== null ? cur.unitPrice : Infinity;
                const bestUnitPrice = best.unitPrice !== undefined && best.unitPrice !== null ? best.unitPrice : Infinity;
                return curUnitPrice < bestUnitPrice ? cur : best;
            });

            const isBest = calculatedUnitPrice <= (bestDeal.unitPrice !== undefined && bestDeal.unitPrice !== null ? bestDeal.unitPrice : Infinity);
            
            if (isBest) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            } else {
                return { isBest: false, message: "非歷史最低價", backgroundColor: "bg-yellow-100" };
            }
        } catch (error) {
            console.error("比價檢查失敗:", error);
            return null;
        }
    }, []);

    // 當待辨識卡片列表改變時，重新計算比價結果
    useEffect(() => {
        const fetchPriceComparisonResults = async () => {
            const results = {};
            for (const card of pendingOcrCards) {
                const result = await checkIfBestPrice(card, pendingOcrCards);
                results[card.id] = result;
            }
            setPriceComparisonResults(results);
        };
        
        if (pendingOcrCards.length > 0) {
            fetchPriceComparisonResults();
        } else {
            setPriceComparisonResults({});
        }
    }, [pendingOcrCards, checkIfBestPrice]);

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${theme.bg}`}>
            <div className="max-w-2xl mx-auto">
                <div className="flex items-center mb-6 border-b pb-4">
                    <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4">
                        <ArrowLeft className="mr-1" size={20} />返回
                    </button>
                    <h1 className={`text-2xl font-bold ${theme.text} flex items-center`}>
                        <Clock className="w-6 h-6 mr-2" />待辨識序列管理
                    </h1>
                </div>

                {queueStats.total > 0 ? (
                    <div className="mb-6 p-4 bg-white rounded-lg shadow">
                        <h2 className="text-lg font-semibold mb-3">序列統計</h2>
                        {/* 改為橫式條列呈現 */}
                        <div className="flex flex-wrap gap-4">
                            <div className="flex items-center">
                                <div className="bg-blue-100 p-2 rounded-full mr-2">
                                    <span className="text-blue-600 font-bold">{queueStats.total}</span>
                                </div>
                                <span className="text-gray-600">總數</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-green-100 p-2 rounded-full mr-2">
                                    <span className="text-green-600 font-bold">{queueStats.oldest ? formatTime(queueStats.oldest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最早</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-purple-100 p-2 rounded-full mr-2">
                                    <span className="text-purple-600 font-bold">{queueStats.newest ? formatTime(queueStats.newest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最新</span>
                            </div>
                        </div>
                        
                        {/* localStorage 使用量顯示 */}
                        <div className="mt-4 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                ) : (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <AlertCircle size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">無待辨識項目</h3>
                        <p className="text-gray-500">目前沒有任何待確認的辨識卡片</p>
                        
                        {/* localStorage 使用量顯示（即使沒有項目也顯示） */}
                        <div className="mt-6 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                )}

                <div className="space-y-4">
                    {pendingOcrCards.map((card) => (
                        <div 
                            key={card.id} 
                            className={`bg-white p-4 rounded-lg shadow border-4 relative ${
                                priceComparisonResults[card.id]?.isBest 
                                    ? 'border-green-500' 
                                    : 'border-yellow-500'
                            }`}
                        >
                            <div className="flex justify-between items-start">
                                <div className="flex-1">
                                    {/* 將比價結果移到卡片頂部 */}
                                    {priceComparisonResults[card.id] && (
                                        <div className={`mb-3 p-2 rounded text-center text-base font-bold ${
                                            priceComparisonResults[card.id].isBest 
                                                ? 'bg-green-500 text-white' 
                                                : 'bg-yellow-500 text-pink-800'
                                        }`}>
                                            {priceComparisonResults[card.id].message}
                                        </div>
                                    )}
                                    
                                    <input
                                        type="text"
                                        value={card.productName || ''}
                                        onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                        className="font-bold text-lg text-gray-800 w-full p-1 mb-2 border-b border-gray-300 focus:border-blue-500 focus:outline-none"
                                        placeholder="產品名稱"
                                    />
                                    
                                    {/* 擷取畫面顯示 */}
                                    {card.capturedImage && (
                                        <div className="mt-3 mb-3">
                                            <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                                <div className="relative w-full aspect-video">
                                                    {card.capturedImage.startsWith('data:image') ? (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    ) : (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-1 mt-1 text-sm">
                                        {/* 條碼欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">條碼數據</label>
                                            <input
                                                type="text"
                                                value={card.scannedBarcode || ''}
                                                onChange={(e) => handleCardChange(card.id, 'scannedBarcode', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="條碼"
                                            />
                                        </div>
                                        
                                        {/* 產品名稱欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">產品名稱</label>
                                            <input
                                                type="text"
                                                value={card.productName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="產品名稱"
                                            />
                                        </div>
                                        
                                        {/* 商店欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">商店名稱</label>
                                            <input
                                                type="text"
                                                value={card.storeName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'storeName', e.target.value)}
                                                onClick={(e) => {
                                                    e.preventDefault();
                                                    handleStoreClick(card);
                                                }}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 bg-gray-50 cursor-pointer"
                                                placeholder="點擊選擇商店"
                                            />
                                        </div>
                                        
                                        {/* 價格欄位 */}
                                        {card.specialPrice !== undefined ? (
                                            <>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">原價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.originalPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'originalPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                        placeholder="原價"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">特價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.specialPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'specialPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 text-green-600 font-bold"
                                                        placeholder="特價"
                                                    />
                                                </div>
                                            </>
                                        ) : (
                                            <div className="col-span-2">
                                                <label className="block text-gray-700 font-medium mb-0.5">總價 ($)</label>
                                                <input
                                                    type="number"
                                                    value={card.extractedPrice || ''}
                                                    onChange={(e) => handleCardChange(card.id, 'extractedPrice', e.target.value)}
                                                    className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                    placeholder="價格"
                                                />
                                            </div>
                                        )}
                                        
                                        {/* 數量和單位 */}
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">數量</label>
                                            <input
                                                type="text"
                                                value={card.quantity || ''}
                                                onChange={(e) => handleCardChange(card.id, 'quantity', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="數量"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">單位</label>
                                            <select
                                                value={card.unitType || 'pcs'}
                                                onChange={(e) => handleCardChange(card.id, 'unitType', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                            >
                                                <option value="ml">ml (毫升)</option>
                                                <option value="g">g (克)</option>
                                                <option value="pcs">pcs (個/包/支/條)</option>
                                            </select>
                                        </div>
                                        
                                        {/* 單價 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">單價 (每100g/ml)</label>
                                            <input
                                                type="text"
                                                value={formatUnitPrice(card.unitPrice)}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded bg-gray-100"
                                            />
                                        </div>
                                        
                                        {/* 優惠資訊 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">優惠細節</label>
                                            <input
                                                type="text"
                                                value={card.discountDetails || ''}
                                                onChange={(e) => handleCardChange(card.id, 'discountDetails', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="優惠資訊"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>加入時間: {formatTime(card.timestamp)}</p>
                                        <p>運行時間: {calculateDuration(card.timestamp)}</p>
                                    </div>
                                    
                                    {/* 新增狀態圖示區塊 - 位於運行時間下面 */}
                                    <div className="absolute bottom-2 right-2">
                                        {card.syncStatus === 'pending' && (
                                            <Clock 
                                                className="w-4 h-4 text-yellow-500 animate-spin" 
                                                title="正在同步至 Firebase..." 
                                            />
                                        )}
                                        {card.syncStatus === 'success' && (
                                            <CheckCircle 
                                                className="w-4 h-4 text-green-500" 
                                                title="已成功同步至 Firebase" 
                                            />
                                        )}
                                        {card.syncStatus === 'error' && (
                                            <AlertCircle 
                                                className="w-4 h-4 text-red-500" 
                                                title="同步失敗，請檢查網路或重試" 
                                            />
                                        )}
                                    </div>
                                </div>
                                <div className="flex flex-col">
                                    <button 
                                        onClick={() => handleSaveClick(card)}
                                        className="p-2 text-green-500 hover:text-green-700 hover:bg-green-50 rounded-full"
                                        title="確認儲存"
                                    >
                                        <CheckCircle size={20} />
                                    </button>
                                    <button 
                                        onClick={() => handleDeleteClick(card)}
                                        className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full mt-5"
                                        title="刪除"
                                    >
                                        <Trash2 size={20} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            
            {/* 刪除確認對話框 - 保留 */}
            {deleteConfirmation && (
                <DeleteConfirmation 
                    card={deleteConfirmation}
                    onClose={cancelDelete}
                    onConfirm={confirmDelete}
                />
            )}
        </div>
    );
}

export default OcrQueuePage;
</file>

<file path="src.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AllRecordsPage.js
App.css
App.js
components/AIOcrCaptureModal.js
components/AIOcrCaptureModal備份
components/components.xml
components/DataManagement.js
components/SettingsPage.js
firebase-config.js
index.css
index.js
OcrQueuePage.js
src.xml
StoreSelector.js
utils/errorHandler.js
utils/errorHandler.test.js
utils/priceCalculations.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AllRecordsPage.js">
import React, { useState, useEffect, useMemo, useRef, useCallback, useLayoutEffect } from 'react';
import { ArrowLeft, Database, TrendingUp, Edit, Trash2, Save, X, CheckCircle, Search } from 'lucide-react';
import { collection, getDocs, query, orderBy, updateDoc, deleteDoc, doc } from 'firebase/firestore';
import { calculateUnitPrice, formatUnitPrice } from './utils/priceCalculations';
import StoreSelector from './StoreSelector';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 圖表組件
const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, productName }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp).sort((a, b) => a.timestamp - b.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間無足夠變化可繪圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <TrendingUp className="mr-1 text-gray-500" size={16} />
                單價走勢 - {productName}
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke="#4F46E5" strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === validRecords.length - 1 ? '#10B981' : '#4F46E5'} title={`${record.displayPrice.toFixed(2)} at ${record.timestamp.toLocaleDateString()}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>{new Date(minTimestamp).toLocaleDateString()}</span>
                <span>{new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

// Fuzzy search function
function fuzzyMatch(pattern, text) {
    const pattern_lower = pattern.toLowerCase();
    const text_lower = text.toLowerCase();
    let patternIdx = 0;
    let textIdx = 0;
    let score = 0;
    let consecutive = 0;
    let firstMatchIndex = -1;

    // Iterate through text to find pattern characters
    while (patternIdx < pattern_lower.length && textIdx < text_lower.length) {
        if (pattern_lower[patternIdx] === text_lower[textIdx]) {
            if (firstMatchIndex === -1) {
                firstMatchIndex = textIdx;
            }
            score += 1;
            // Add bonus for consecutive matches
            if (consecutive > 0) {
                score += consecutive;
            }
            consecutive++;
            patternIdx++;
        } else {
            consecutive = 0;
        }
        textIdx++;
    }

    // If the whole pattern was found
    if (patternIdx === pattern_lower.length) {
        // Add bonus for being a prefix
        if (firstMatchIndex === 0) {
            score += 5;
        }
        // Add bonus for tightness of the match
        const matchDensity = pattern.length / (textIdx - firstMatchIndex);
        score *= (1 + matchDensity);

        return score;
    }

    return 0;
}

// 可滑動的記錄項目
function SwipeableRecord({ children, onEdit, onDelete }) {
    const [translateX, setTranslateX] = useState(0);
    const touchStartX = useRef(0);
    const itemRef = useRef(null);
    const buttonsRef = useRef(null);

    const handleTouchStart = (e) => {
        touchStartX.current = e.touches[0].clientX;
    };

    const handleTouchMove = (e) => {
        const touchCurrentX = e.touches[0].clientX;
        const diff = touchCurrentX - touchStartX.current;
        if (diff < 0) { // 只允許向左滑動
            setTranslateX(Math.max(diff, -160)); // -160 是按鈕寬度的總和
        }
    };

    const handleTouchEnd = () => {
        if (translateX < -80) {
            setTranslateX(-160);
        } else {
            setTranslateX(0);
        }
    };

    useEffect(() => {
        const handleGlobalClick = (e) => {
            if (buttonsRef.current && !buttonsRef.current.contains(e.target)) {
                setTranslateX(0);
            }
        };

        if (translateX !== 0) {
            document.addEventListener('click', handleGlobalClick, true);
        }

        return () => {
            document.removeEventListener('click', handleGlobalClick, true);
        };
    }, [translateX]);

    const handleEdit = () => {
        onEdit();
        setTranslateX(0);
    };

    const handleDelete = () => {
        onDelete();
        setTranslateX(0);
    };

    return (
        <div className="relative overflow-hidden">
            <div ref={buttonsRef} className="absolute top-0 right-0 h-full flex items-center">
                <button onClick={handleEdit} className="bg-blue-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Edit size={20} />
                    <span>編輯</span>
                </button>
                <button onClick={handleDelete} className="bg-red-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Trash2 size={20} />
                    <span>刪除</span>
                </button>
            </div>
            <div
                ref={itemRef}
                className="transition-transform duration-300 ease-in-out"
                style={{ transform: `translateX(${translateX}px)` }}
                onTouchStart={handleTouchStart}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleTouchEnd}
            >
                {children}
            </div>
        </div>
    );
}


// 產品記錄組件
function ProductRecord({ product, records, theme, onEdit, onDelete }) {
    const formattedRecords = records.map(r => ({ ...r, timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp) })).sort((a, b) => b.timestamp - a.timestamp);
    
    const latestRecord = formattedRecords[0];
    if (!latestRecord) return null; // 如果沒有記錄，則不渲染此組件

    const validUnitPrices = formattedRecords.map(r => r.unitPrice).filter(p => !isNaN(p) && p !== undefined && p !== null);
    const lowestUnitPrice = validUnitPrices.length > 0 ? Math.min(...validUnitPrices) : 0;
    const highestUnitPrice = validUnitPrices.length > 0 ? Math.max(...validUnitPrices) : 0;
    const avgUnitPrice = validUnitPrices.length > 0 ? validUnitPrices.reduce((sum, p) => sum + p, 0) / validUnitPrices.length : 0;

    return (
        <div className={`p-4 rounded-xl shadow-lg bg-white border-t-4 ${theme.border} mb-6`}>
            <div className="flex justify-between items-start">
                <div>
                    <h3 className="text-lg font-bold text-gray-800">{product.productName}</h3>
                    <p className="text-sm text-gray-600">條碼: {product.barcodeData}</p>
                    <p className="text-xs text-gray-500">ID: {product.numericalID}</p>
                </div>
                <div className="text-right">
                    {/* 顯示原價和特價信息 */}
                    {latestRecord.specialPrice ? (
                        <div>
                            {latestRecord.originalPrice && (
                                <p className="text-lg text-gray-500 line-through">${latestRecord.originalPrice.toFixed(2)}</p>
                            )}
                            <p className="text-2xl font-bold text-indigo-600">${latestRecord.specialPrice.toFixed(2)}</p>
                            <p className="text-xs text-gray-500">@{formatUnitPrice(latestRecord.unitPrice)}</p>
                        </div>
                    ) : (
                        <p className="text-2xl font-bold text-indigo-600">{formatUnitPrice(latestRecord.unitPrice) === '--' ? (isNaN(latestRecord.price) ? 'N/A' : `$${(latestRecord.price || 0).toFixed(2)}`) : `$${(latestRecord.price || 0).toFixed(2)} @${formatUnitPrice(latestRecord.unitPrice)}`}</p>
                    )}
                    <p className="text-xs text-gray-500">{latestRecord.timestamp.toLocaleDateString()}</p>
                    {/* 顯示數量和單位 */}
                    {latestRecord.quantity && latestRecord.unitType && (
                        <p className="text-xs text-gray-500">數量: {latestRecord.quantity} {latestRecord.unitType}</p>
                    )}
                </div>
            </div>

            <div className="grid grid-cols-3 gap-2 my-3 text-center">
                <div className="bg-green-50 p-2 rounded"><p className="text-xs text-gray-500">最低單價</p><p className="font-bold text-green-600">{isNaN(lowestUnitPrice) ? 'N/A' : `${lowestUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-blue-50 p-2 rounded"><p className="text-xs text-gray-500">平均單價</p><p className="font-bold text-blue-600">{isNaN(avgUnitPrice) ? 'N/A' : `${avgUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-red-50 p-2 rounded"><p className="text-xs text-gray-500">最高單價</p><p className="font-bold text-red-600">{isNaN(highestUnitPrice) ? 'N/A' : `${highestUnitPrice.toFixed(2)}`}</p></div>
            </div>

            <div className="mb-4"><PriceTrendChart records={formattedRecords} productName={product.productName} /></div>

            <div className="mt-4">
                <h4 className="font-semibold text-gray-700 mb-2">價格記錄詳情</h4>
                <div className="space-y-2 max-h-40 overflow-y-auto">
                    {formattedRecords.map((record, index) => (
                        <SwipeableRecord
                            key={index}
                            onEdit={() => onEdit(record)}
                            onDelete={() => onDelete(record)}
                        >
                            <div className="flex justify-between items-center p-2 bg-gray-50 rounded">
                                <div>
                                    {/* 顯示原價和特價信息 */}
                                    {record.specialPrice ? (
                                        <p className="font-medium">
                                            {record.originalPrice && (
                                                <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                            )}
                                            <span className="text-red-600 ml-1">${record.specialPrice.toFixed(2)}</span>
                                            <span className="text-gray-500 ml-1">@{formatUnitPrice(record.unitPrice)}</span>
                                        </p>
                                    ) : (
                                        <p className="font-medium">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</p>
                                    )}
                                    {record.discountDetails && <p className="text-xs text-indigo-600">{record.discountDetails}</p>}
                                    {/* 顯示數量和單位 */}
                                    {record.quantity && record.unitType && (
                                        <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType}</p>
                                    )}
                                </div>
                                <div className="text-right">
                                    <p className="text-xs text-gray-500">{record.storeName || '未標註'}</p>
                                    <p className="text-xs text-gray-500">{record.timestamp.toLocaleDateString()}</p>
                                </div>
                            </div>
                        </SwipeableRecord>
                    ))}
                </div>
            </div>
        </div>
    );
}

// 主組件
function AllRecordsPage({ theme, onBack, db, userId, isAuthReady }) {
    const [allProducts, setAllProducts] = useState([]);
    const [allRecords, setAllRecords] = useState({});
    const [loading, setLoading] = useState(true);
    const [sortOption, setSortOption] = useState('latest'); // latest, name, price
    const [editingRecord, setEditingRecord] = useState(null);
    const [deletingRecord, setDeletingRecord] = useState(null);
    const [successMessage, setSuccessMessage] = useState('');
    const scrollPositionRef = useRef(0); // For scroll restoration
    const [isAfterDelete, setIsAfterDelete] = useState(false); // Signal for scroll restoration
    const [searchQuery, setSearchQuery] = useState('');
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const searchInputRef = useRef(null);
    
    // Edit mode states
    const [isEditMode, setIsEditMode] = useState(false);
    const [selectedItems, setSelectedItems] = useState(new Set());
    const [localProducts, setLocalProducts] = useState([]);
    const [localRecords, setLocalRecords] = useState({});
    // 新增狀態：批量刪除確認對話框
    const [isBulkDeleteConfirmationOpen, setIsBulkDeleteConfirmationOpen] = useState(false);
    // 新增狀態：原始數據快照和衝突解決
    const [originalDataSnapshot, setOriginalDataSnapshot] = useState(null);
    const [isConflictDialogOpen, setIsConflictDialogOpen] = useState(false);

    const fetchData = useCallback(async () => {
        if (!db) return;
        setLoading(true);
        try {
            // 1. Fetch all products
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const productsArray = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 2. Fetch all records
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const recordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // 3. Group records by product ID
            const recordsByProduct = {};
            recordsArray.forEach(record => {
                if (!recordsByProduct[record.numericalID]) {
                    recordsByProduct[record.numericalID] = [];
                }
                recordsByProduct[record.numericalID].push(record);
            });

            setAllProducts(productsArray);
            setAllRecords(recordsByProduct);

        } catch (error) {
            console.error('讀取 Firestore 數據失敗:', error);
            const userMessage = handleFirestoreSaveError(error, "讀取產品數據");
            showUserFriendlyError(userMessage);
        } finally {
            setLoading(false);
        }
    }, [db]);

    useEffect(() => {
        // 只有在 Firebase 已準備好時才執行查詢
        if (!isAuthReady || !userId) {
            // 如果 Firebase 尚未準備好，不應該顯示加載狀態
            // 讓用戶知道需要等待 Firebase 初始化
            return;
        }
        
        // Firebase 已準備好且有 userId，執行數據獲取
        fetchData();
    }, [fetchData, isAuthReady, userId]);

    useEffect(() => {
        if (isSearchOpen && searchInputRef.current) {
            setTimeout(() => searchInputRef.current.focus(), 100); // Shorter delay for responsiveness
        }
    }, [isSearchOpen]);

    useLayoutEffect(() => {
        if (isAfterDelete && !loading) {
            // Use requestAnimationFrame to ensure scroll happens after browser paints
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollPositionRef.current);
                setIsAfterDelete(false); // Reset the signal after scrolling
            });
        }
    }, [loading, isAfterDelete]);

    const filteredProducts = useMemo(() => {
        // Use local data in edit mode, otherwise use Firebase data
        const products = isEditMode ? localProducts : allProducts;
        const records = isEditMode ? localRecords : allRecords;

        if (searchQuery.trim() === '') {
            // No search query, just sort the products
            return [...products].sort((a, b) => {
                const recordsA = records[a.numericalID] || [];
                const recordsB = records[b.numericalID] || [];
                
                if (sortOption === 'name') {
                    return a.productName.localeCompare(b.productName);
                }
                
                const latestRecordA = recordsA[0];
                const latestRecordB = recordsB[0];

                if (sortOption === 'price') {
                    const priceA = latestRecordA?.price || -1;
                    const priceB = latestRecordB?.price || -1;
                    return priceB - priceA;
                }

                // Default to 'latest'
                const timeA = latestRecordA?.timestamp?.toDate ? latestRecordA.timestamp.toDate().getTime() : 0;
                const timeB = latestRecordB?.timestamp?.toDate ? latestRecordB.timestamp.toDate().getTime() : 0;
                return timeB - timeA;
            });
        }

        // Fuzzy search logic
        const scoredProducts = products
            .map(product => ({
                product,
                score: fuzzyMatch(searchQuery, product.productName)
            }))
            .filter(item => item.score > 0)
            .sort((a, b) => b.score - a.score);
        
        return scoredProducts.map(item => item.product);

    }, [allProducts, allRecords, sortOption, searchQuery, isEditMode, localProducts, localRecords]);

    const showSuccessMessage = (message) => {
        setSuccessMessage(message);
        setTimeout(() => {
            setSuccessMessage('');
        }, 2000);
    };

    const handleEdit = (record) => {
        setEditingRecord(record);
    };

    const handleDelete = (record) => {
        scrollPositionRef.current = window.scrollY; // Save scroll position
        setDeletingRecord(record);
    };

    // New function to handle checkbox selection
    const handleItemSelect = (productId) => {
        setSelectedItems(prev => {
            const newSet = new Set(prev);
            if (newSet.has(productId)) {
                newSet.delete(productId);
            } else {
                newSet.add(productId);
            }
            return newSet;
        });
    };

    // 修改批量刪除功能以使用確認對話框
    const handleBulkDeleteClick = () => {
        if (selectedItems.size === 0) return;
        setIsBulkDeleteConfirmationOpen(true);
    };

    // New function to delete selected items
    const deleteSelectedItems = async () => {
        if (selectedItems.size === 0) return;
        
        try {
            // Update local state
            setLocalProducts(prev => prev.filter(product => !selectedItems.has(product.numericalID)));
            setLocalRecords(prev => {
                const newRecords = {...prev};
                selectedItems.forEach(productId => {
                    delete newRecords[productId];
                });
                return newRecords;
            });
            
            // Clear selection
            setSelectedItems(new Set());
            setIsBulkDeleteConfirmationOpen(false);
        } catch (error) {
            console.error("Error deleting selected items:", error);
            const userMessage = handleFirestoreSaveError(error, "批量刪除產品");
            showUserFriendlyError(userMessage);
        }
    };

    // 新增函數：檢查衝突並退出編輯模式
    const checkForConflictsAndExit = async () => {
        if (!db || !originalDataSnapshot) return;
        
        try {
            // 獲取當前 Firebase 數據
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const currentProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 將記錄按產品 ID 分組
            const currentRecords = {};
            currentRecordsArray.forEach(record => {
                if (!currentRecords[record.numericalID]) {
                    currentRecords[record.numericalID] = [];
                }
                currentRecords[record.numericalID].push(record);
            });
            
            // 比較當前數據與原始快照
            const hasConflicts = checkForDataConflicts(originalDataSnapshot, {products: currentProducts, records: currentRecords});
            
            if (hasConflicts) {
                // 如果有衝突，顯示衝突解決對話框
                setIsConflictDialogOpen(true);
            } else {
                // 如果沒有衝突，直接退出編輯模式
                await exitEditMode(currentProducts, currentRecords);
            }
        } catch (error) {
            console.error("檢查數據衝突時出錯:", error);
            const userMessage = handleFirestoreSaveError(error, "檢查數據衝突");
            showUserFriendlyError(userMessage);
            // 出錯時仍然退出編輯模式
            await exitEditMode();
        }
    };
    
    // 新增函數：檢查數據衝突
    const checkForDataConflicts = (original, current) => {
        // 比較產品數量
        if (original.products.length !== current.products.length) {
            return true;
        }
        
        // 比較記錄數量
        const originalRecordCount = Object.values(original.records).reduce((count, records) => count + records.length, 0);
        const currentRecordCount = Object.values(current.records).reduce((count, records) => count + records.length, 0);
        
        if (originalRecordCount !== currentRecordCount) {
            return true;
        }
        
        // 更詳細的比較可以在此處添加
        // 為了簡化，我們只檢查數量變化
        
        return false;
    };
    
    // 修改 exitEditMode 函數以接受當前數據
    const exitEditMode = async (currentProducts = null, currentRecords = null) => {
        if (!db) return;
        
        try {
            // 如果沒有提供當前數據，則獲取最新數據
            let latestProducts = currentProducts;
            let latestRecords = currentRecords;
            
            if (!latestProducts || !latestRecords) {
                const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
                const productsSnap = await getDocs(productsQuery);
                latestProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
                const recordsSnap = await getDocs(recordsQuery);
                const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 將記錄按產品 ID 分組
                latestRecords = {};
                currentRecordsArray.forEach(record => {
                    if (!latestRecords[record.numericalID]) {
                        latestRecords[record.numericalID] = [];
                    }
                    latestRecords[record.numericalID].push(record);
                });
            }
            
            // 計算需要從 Firebase 刪除的產品
            const productsToDelete = latestProducts.filter(product => 
                !localProducts.some(localProduct => localProduct.numericalID === product.numericalID)
            );
            
            // 刪除 Firebase 中的產品及其記錄
            for (const product of productsToDelete) {
                // 刪除所有記錄
                const productRecords = latestRecords[product.numericalID] || [];
                for (const record of productRecords) {
                    const recordRef = doc(db, "priceRecords", record.id);
                    await deleteDoc(recordRef);
                }
            }
            
            // 計算需要從 Firebase 刪除的記錄（編輯模式下刪除的記錄）
            const recordsToDelete = [];
            for (const [productId, records] of Object.entries(latestRecords)) {
                const localRecordsForProduct = localRecords[productId] || [];
                // 找出在原始記錄中存在但在本地記錄中不存在的記錄
                const deletedRecords = records.filter(record => 
                    !localRecordsForProduct.some(localRecord => localRecord.id === record.id)
                );
                recordsToDelete.push(...deletedRecords);
            }
            
            // 刪除 Firebase 中的記錄
            for (const record of recordsToDelete) {
                const recordRef = doc(db, "priceRecords", record.id);
                await deleteDoc(recordRef);
            }
            
            // 重新從 Firebase 獲取數據
            await fetchData();
            setIsEditMode(false);
            setSelectedItems(new Set());
            setOriginalDataSnapshot(null);

        } catch (error) {
            console.error("Error syncing with Firebase:", error);
            const userMessage = handleFirestoreSaveError(error, "同步編輯數據");
            showUserFriendlyError(userMessage);
        }
    };

    const handleSaveEdit = async (updatedRecord) => {
        if (!db) return;
        try {
            const recordRef = doc(db, "priceRecords", updatedRecord.id);
            // 更新所有字段，不僅僅是價格和折扣詳情
            await updateDoc(recordRef, {
                price: updatedRecord.price,
                discountDetails: updatedRecord.discountDetails,
                productName: updatedRecord.productName,
                storeName: updatedRecord.storeName,
                quantity: updatedRecord.quantity,
                unitType: updatedRecord.unitType,
                unitPrice: updatedRecord.unitPrice,
                originalPrice: updatedRecord.originalPrice,
                specialPrice: updatedRecord.specialPrice
            });
            
            // 在編輯模式下，更新本地狀態而不是重新獲取所有數據
            if (isEditMode) {
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    
                    // 確保更新的記錄所屬的產品在 localRecords 中存在
                    if (!newRecords[updatedRecord.numericalID]) {
                        newRecords[updatedRecord.numericalID] = [];
                    }
                    
                    // 更新記錄
                    Object.keys(newRecords).forEach(productId => {
                        if (newRecords[productId]) {
                            newRecords[productId] = newRecords[productId].map(record => 
                                record.id === updatedRecord.id ? updatedRecord : record
                            ).filter(record => record !== undefined); // 過濾掉可能的 undefined 值
                        }
                    });
                    
                    // 確保當前更新的記錄存在於其對應的產品記錄中
                    if (!newRecords[updatedRecord.numericalID].some(record => record.id === updatedRecord.id)) {
                        newRecords[updatedRecord.numericalID].push(updatedRecord);
                    }
                    
                    return newRecords;
                });
                
                // 同時更新本地產品列表中的產品名稱
                setLocalProducts(prev => 
                    prev.map(product => 
                        product.numericalID === updatedRecord.numericalID 
                            ? {...product, productName: updatedRecord.productName} 
                            : product
                    )
                );
            } else {
                await fetchData(); // 非編輯模式下重新獲取數據以更新UI
            }
            
            showSuccessMessage('記錄已成功更新');
        } catch (error) {
            console.error("更新記錄失敗:", error);
            const userMessage = handleFirestoreSaveError(error, "更新價格記錄");
            showUserFriendlyError(userMessage);
        }
        setEditingRecord(null);
    };

    // 新增函數：處理衝突解決
    const handleConflictResolution = async (resolutionType) => {
        setIsConflictDialogOpen(false);
        
        switch (resolutionType) {
            case 'local':
                // 保留本地更改，直接退出編輯模式
                await exitEditMode();
                break;
            case 'remote':
                // 保留遠程數據，重新獲取最新數據並退出
                await fetchData();
                setIsEditMode(false);
                setSelectedItems(new Set());
                setOriginalDataSnapshot(null);

                break;
            case 'merge':
                // 手動合併，重新獲取數據並保持編輯模式
                await fetchData();
                setLocalProducts([...allProducts]);
                setLocalRecords({...allRecords});
                // 保持編輯模式開啟，讓用戶繼續編輯
                setOriginalDataSnapshot({
                    products: [...allProducts],
                    records: {...allRecords},
                    timestamp: Date.now()
                });

                break;
            default:
                // 默認情況下直接退出編輯模式
                await exitEditMode();
        }
    };

    const confirmDelete = async () => {
        if (!db || !deletingRecord) return;
        
        // 在編輯模式下，我們只需要更新本地狀態，不需要重新整理畫面
        if (isEditMode) {
            try {
                // 更新本地狀態而不是調用 Firebase
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    if (newRecords[deletingRecord.numericalID]) {
                        newRecords[deletingRecord.numericalID] = newRecords[deletingRecord.numericalID].filter(
                            record => record.id !== deletingRecord.id
                        );
                    }
                    return newRecords;
                });
                
                // 顯示成功消息
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            } finally {
                setDeletingRecord(null);
            }
        } else {
            // 非編輯模式下保持原有行為
            setIsAfterDelete(true); // Signal that the next data fetch is after a delete
            try {
                const recordRef = doc(db, "priceRecords", deletingRecord.id);
                await deleteDoc(recordRef);
                await fetchData(); // 重新獲取數據以更新UI
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            }
            setDeletingRecord(null);
        }
    };

    const handleSearchToggle = () => {
        if (isSearchOpen) {
            setSearchQuery('');
        }
        setIsSearchOpen(!isSearchOpen);
    };

    if (loading) {
        return (
            <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
                <div className="max-w-4xl mx-auto">
                    <div className="flex items-center mb-6">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800">所有記錄</h1>
                    </div>
                    <div className="text-center py-10">
                        {!isAuthReady ? (
                            <p>正在初始化雲端服務，請稍候...</p>
                        ) : !userId ? (
                            <p>正在獲取用戶信息，請稍候...</p>
                        ) : (
                            <p>正在從雲端加載數據...</p>
                        )}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
            <div className="max-w-4xl mx-auto pb-28"> {/* Added pb-28 for floating button */}
                <SuccessMessage message={successMessage} />
                <div className="flex flex-col sm:flex-row sm:items-center justify-between mb-6">
                    <div className="flex items-center mb-4 sm:mb-0">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800 flex items-center"><Database className="mr-2" />所有記錄</h1>
                    </div>
                    <div className="flex items-center">
                        <label className="mr-2 text-gray-700">排序:</label>
                        <select value={sortOption} onChange={(e) => setSortOption(e.target.value)} className="border border-gray-300 rounded p-2 mr-2">
                            <option value="latest">最新記錄</option>
                            <option value="name">產品名稱</option>
                            <option value="price">最新價格</option>
                        </select>
                        <button 
                            onClick={() => {
                                if (!isEditMode) {
                                    // Enter edit mode - copy current data to local state
                                    setLocalProducts([...allProducts]);
                                    setLocalRecords({...allRecords});
                                    // 保存原始數據快照和時間戳
                                    setOriginalDataSnapshot({
                                        products: [...allProducts],
                                        records: {...allRecords},
                                        timestamp: Date.now()
                                    });
                                } else {
                                    // Exit edit mode - 檢查數據版本衝突
                                    checkForConflictsAndExit();
                                }
                                setIsEditMode(!isEditMode);
                                setSelectedItems(new Set());
                            }}
                            className={`px-3 py-2 rounded text-white text-sm ${
                                isEditMode ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'
                            }`}
                        >
                            {isEditMode ? '退出編輯模式' : '編輯模式'}
                        </button>
                    </div>
                </div>

                {/* Floating Delete Button - 修改為固定位置 */}
                {isEditMode && selectedItems.size > 0 && (
                    <div className="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-4 shadow-lg z-50 flex items-center"
                         style={{bottom: '6rem'}}>
                        <button 
                            onClick={handleBulkDeleteClick}
                            className="flex items-center"
                        >
                            <Trash2 size={20} className="mr-2" />
                            刪除選取項目 ({selectedItems.size})
                        </button>
                    </div>
                )}

                {/* Floating Exit Edit Mode Button - 修改為固定位置 */}
                {isEditMode && (
                    <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white rounded-full p-4 shadow-lg z-50">
                        <button 
                            onClick={checkForConflictsAndExit}
                            className="flex items-center"
                        >
                            <X size={20} className="mr-2" />
                            退出編輯模式
                        </button>
                    </div>
                )}

                {filteredProducts.length === 0 ? (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <Database size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">{searchQuery ? '找不到結果' : '暫無記錄'}</h3>
                        <p className="text-gray-500">{searchQuery ? `找不到符合 "${searchQuery}" 的產品` : '還沒有任何產品和價格記錄'}</p>
                    </div>
                ) : (
                    <div>
                        <div className="mb-4 p-4 bg-white rounded-lg shadow">
                            <div className="flex justify-between">
                                <p className="text-gray-700">總共 <span className="font-bold">{filteredProducts.length}</span> 個產品</p>
                                <p className="text-gray-700">總共 <span className="font-bold">{Object.values(allRecords).flat().length}</span> 條記錄</p>
                            </div>
                        </div>
                        {filteredProducts.map(product => {
                            // 修復：確保 records 始終有默認值
                            const records = isEditMode ? (localRecords[product.numericalID] || []) : (allRecords[product.numericalID] || []);
                            // 修改：即使沒有記錄也顯示產品卡片，但只在編輯模式下
                            if (records.length === 0 && !isEditMode) return null;
                            return (
                                // 修改：為選中的項目添加增強的視覺反饋
                                <div key={product.numericalID} className={`relative transition-all duration-200 ${isEditMode && selectedItems.has(product.numericalID) ? 'bg-blue-50 border-2 border-blue-500 rounded-lg' : ''}`}>
                                    {isEditMode && (
                                        <div className="absolute top-4 left-4 z-10">
                                            <input
                                                type="checkbox"
                                                checked={selectedItems.has(product.numericalID)}
                                                onChange={() => handleItemSelect(product.numericalID)}
                                                className="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                                            />
                                        </div>
                                    )}
                                    <div className={isEditMode ? "pl-12" : ""}>
                                        <ProductRecord 
                                            product={product} 
                                            records={records} 
                                            theme={theme} 
                                            onEdit={handleEdit} 
                                            onDelete={handleDelete} 
                                        />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}

                {editingRecord && (
                    <EditModal
                        record={editingRecord}
                        onClose={() => setEditingRecord(null)}
                        onSave={handleSaveEdit}
                    />
                )}

                {deletingRecord && (
                    <DeleteConfirmation
                        record={deletingRecord}
                        onClose={() => setDeletingRecord(null)}
                        onConfirm={confirmDelete}
                    />
                )}

                {/* 新增批量刪除確認對話框 */}
                {isBulkDeleteConfirmationOpen && (
                    <BulkDeleteConfirmation
                        count={selectedItems.size}
                        onClose={() => setIsBulkDeleteConfirmationOpen(false)}
                        onConfirm={deleteSelectedItems}
                    />
                )}

                {/* 新增衝突解決對話框 */}
                {isConflictDialogOpen && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                            <h2 className="text-xl font-bold mb-4">檢測到數據衝突</h2>
                            <p className="mb-4">在您編輯期間，其他用戶修改了部分數據。請選擇如何解決衝突：</p>
                            
                            <div className="mb-6 p-4 bg-yellow-50 rounded-lg">
                                <h3 className="font-semibold text-yellow-800 mb-2">衝突詳情：</h3>
                                <ul className="list-disc pl-5 text-sm text-yellow-700">
                                    <li>數據可能已被人修改</li>
                                    <li>您的更改可能與其他用戶的更改衝突</li>
                                </ul>
                            </div>
                            
                            <div className="space-y-3">
                                <button 
                                    onClick={() => handleConflictResolution('local')}
                                    className="w-full p-3 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                                >
                                    保留我的更改
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('remote')}
                                    className="w-full p-3 bg-green-500 text-white rounded-md hover:bg-green-600"
                                >
                                    保留最新數據
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('merge')}
                                    className="w-full p-3 bg-purple-500 text-white rounded-md hover:bg-purple-600"
                                >
                                    手動合併（推薦）
                                </button>
                            </div>
                            
                            <div className="mt-6 flex justify-end">
                                <button 
                                    onClick={() => setIsConflictDialogOpen(false)}
                                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                                >
                                    取消
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- START: Revamped Search Component --- */}
                <div className="fixed top-6 right-6 z-30">
                    <div 
                        className={`flex items-center justify-end bg-white rounded-full shadow-xl transition-all duration-300 ease-in-out overflow-hidden ${isSearchOpen ? 'w-80' : 'w-16 h-16'}`}
                    >
                        <Search className={`absolute left-5 top-1/2 -translate-y-1/2 text-gray-400 transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`} size={22} />
                        <input
                            ref={searchInputRef}
                            type="text"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="輸入品名進行模糊搜尋..."
                            className={`w-full h-16 pl-14 pr-20 bg-transparent border-none rounded-full outline-none text-lg transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`}
                            style={{pointerEvents: isSearchOpen ? 'auto' : 'none'}}
                        />
                        <button
                            onClick={handleSearchToggle}
                            className="absolute right-0 top-0 w-16 h-16 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 flex items-center justify-center"
                            aria-label={isSearchOpen ? "關閉搜尋" : "開啟搜尋"}
                        >
                            {isSearchOpen ? <X size={28} /> : <Search size={28} />}
                        </button>
                    </div>
                </div>
                {/* --- END: Revamped Search Component --- */}
            </div>
        </div>
    );
}

function EditModal({ record, onClose, onSave }) {
    const [price, setPrice] = useState(record.price);
    const [quantity, setQuantity] = useState(record.quantity || '');
    const [unitType, setUnitType] = useState(record.unitType || 'pcs');
    const [discount, setDiscount] = useState(record.discountDetails || '');
    const [originalPrice, setOriginalPrice] = useState(record.originalPrice || '');
    const [specialPrice, setSpecialPrice] = useState(record.specialPrice || '');
    const [productName, setProductName] = useState(record.productName || '');
    const [storeName, setStoreName] = useState(record.storeName || '');
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);

    const handleSave = () => {
        const newUnitPrice = calculateUnitPrice(price, quantity, unitType);
        if (newUnitPrice === null) {
            alert("請輸入有效的價格和數量。");
            return;
        }
        onSave({ 
            ...record, 
            price: parseFloat(price),
            quantity: parseFloat(quantity),
            unitType: unitType,
            unitPrice: newUnitPrice,
            discountDetails: discount,
            originalPrice: originalPrice ? parseFloat(originalPrice) : null,
            specialPrice: specialPrice ? parseFloat(specialPrice) : null,
            productName: productName,
            storeName: storeName
        });
    };

    const currentUnitPrice = calculateUnitPrice(price, quantity, unitType);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 overflow-hidden">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">編輯記錄</h2>
                <div className="space-y-3">
                    {/* 產品名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">產品名稱</label>
                        <input
                            type="text"
                            value={productName}
                            onChange={(e) => setProductName(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 商店名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">商店名稱</label>
                        <div className="mt-1 flex">
                            <input
                                type="text"
                                value={storeName}
                                onChange={(e) => setStoreName(e.target.value)}
                                className="block flex-grow border border-gray-300 rounded-l-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                placeholder="點擊選擇商店或手動輸入"
                                readOnly
                            />
                            <button 
                                onClick={() => setIsStoreSelectorOpen(true)}
                                className="bg-indigo-600 text-white px-4 py-2 rounded-r-md hover:bg-indigo-700"
                            >
                                選擇
                            </button>
                        </div>
                    </div>
                    
                    {/* 原價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">原價 ($)</label>
                        <input
                            type="number"
                            value={originalPrice}
                            onChange={(e) => setOriginalPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 特價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">特價 ($)</label>
                        <input
                            type="number"
                            value={specialPrice}
                            onChange={(e) => setSpecialPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 總價輸入（實際支付價格） */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">總價 ($)</label>
                        <input
                            type="number"
                            value={price}
                            onChange={(e) => setPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    <div>
                        <label className="block text-sm font-medium text-gray-700">數量</label>
                        <input
                            type="number"
                            value={quantity}
                            onChange={(e) => setQuantity(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單位</label>
                        <select
                            value={unitType}
                            onChange={(e) => setUnitType(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        >
                            <option value="ml">ml (毫升)</option>
                            <option value="g">g (克)</option>
                            <option value="pcs">pcs (個/包/支/條)</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單價 (自動計算)</label>
                        <input
                            type="text"
                            value={currentUnitPrice === null ? 'N/A' : currentUnitPrice.toFixed(2)}
                            readOnly
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-gray-100"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">折扣詳情</label>
                        <input
                            type="text"
                            value={discount}
                            onChange={(e) => setDiscount(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                </div>
                <div className="mt-4 flex justify-between">
                    <button onClick={onClose} className="flex-1 mr-2 items-center bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 flex justify-center">
                        <X size={18} className="mr-1" />
                        取消
                    </button>
                    <button onClick={handleSave} className="flex-1 ml-2 items-center bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 flex justify-center">
                        <Save size={18} className="mr-1" />
                        保存
                    </button>
                </div>
            </div>
            
            {isStoreSelectorOpen && (
                <StoreSelector 
                    onSelect={(selectedStore) => {
                        setStoreName(selectedStore);
                        setIsStoreSelectorOpen(false);
                    }}
                    onClose={() => setIsStoreSelectorOpen(false)}
                    theme={{ primary: 'bg-indigo-600', hover: 'hover:bg-indigo-700', text: 'text-indigo-600' }}
                />
            )}
        </div>
    );
}

function DeleteConfirmation({ record, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p>您確定要刪除這條價格為 ${record.price.toFixed(2)} 的記錄嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}

function SuccessMessage({ message }) {
    if (!message) return null;

    return (
        <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center z-50">
            <CheckCircle size={20} className="mr-2" />
            <span>{message}</span>
        </div>
    );
}



// 新增批量刪除確認對話框組件
function BulkDeleteConfirmation({ count, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認批量刪除</h2>
                <p>您確定要刪除選中的 {count} 個產品項目嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}



export default AllRecordsPage;
</file>

<file path="App.css">
/* 應用基本樣式 */
.App {
  text-align: center;
  min-height: 100vh;
}

/* 自定義樣式可以在這裡添加 */
</file>

<file path="App.js">
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PaintBucket, DollarSign, Barcode, ClipboardCheck, X, Camera, Zap, FileText, RotateCcw, Database, Settings as SettingsIcon } from 'lucide-react';
import AllRecordsPage from './AllRecordsPage';
import StoreSelector from './StoreSelector';
import AIOcrCaptureModal from './components/AIOcrCaptureModal';
import SettingsPage from './components/SettingsPage'; // 新增導入
import { db } from './firebase-config.js'; // <-- 引入 Firebase
import { getAuth, signInAnonymously } from "firebase/auth";
import { doc, getDoc, setDoc, collection, query, where, getDocs, addDoc, orderBy, serverTimestamp } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import OcrQueuePage from './OcrQueuePage';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具
import { v4 as uuidv4 } from 'uuid'; // 引入 uuid 函式庫來生成本地 ID

// ----------------------------------------------------------------------------
// 1. 核心設定與工具函數 (Core Setup & Utilities)
// ----------------------------------------------------------------------------

function djb2Hash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
}

// 以下函數已移至 src/components/AIOcrCaptureModal.js
// callGeminiApiWithRetry
// withExponentialBackoff


function generateProductId(barcode, productName, storeName) {
    if (barcode) {
        return djb2Hash(barcode).toString();
    } else {
        // Combine productName and storeName to create a unique ID for products without barcodes
        // This assumes productName + storeName is sufficiently unique for non-barcoded items
        return djb2Hash(`${productName}-${storeName}`).toString();
    }
}

// ----------------------------------------------------------------------------
// 2. UI 元件 (UI Components)
// ----------------------------------------------------------------------------

const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, theme }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間沒有足夠的變化來繪製趨勢圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1 text-gray-500"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                單價走勢
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke={theme.color === 'red' ? '#EF4444' : '#4F46E5'} strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === 0 ? '#10B981' : theme.primary.split('-')[1]} title={`$${record.displayPrice.toFixed(2)}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>最早: {new Date(minTimestamp).toLocaleDateString()}</span>
                <span>最新: {new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

function PriceHistoryDisplay({ historyRecords, theme }) {
    if (historyRecords.length === 0) {
        return <div className="text-center p-6 text-gray-500 bg-white rounded-xl shadow-md">尚無歷史價格紀錄。</div>;
    }

    const formattedRecords = historyRecords.map(record => ({
        ...record,
        timestamp: record.timestamp?.toDate ? record.timestamp.toDate() : new Date(record.timestamp),
        displayPrice: record.unitPrice !== undefined && record.unitPrice !== null ? record.unitPrice : record.price // Use unitPrice if available, else price
    }));

    return (
        <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${theme.border} mt-8`}>
            <h2 className={`text-xl font-semibold ${theme.text} mb-4`}>價格紀錄 ({formattedRecords.length} 筆)</h2>
            <div className="mb-6"><PriceTrendChart records={formattedRecords} theme={theme} /></div>
            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {formattedRecords.map((record, index) => (
                    <div key={index} className={`p-3 rounded-lg shadow-sm border border-gray-100 ${index === 0 ? theme.light : 'bg-white'}`}>
                        <div className="flex justify-between items-start font-bold">
                            {/* 顯示原價和特價信息 */}
                            {record.specialPrice ? (
                                <span className="text-[22px]">
                                    {record.originalPrice && (
                                        <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                    )}
                                    <span className="text-red-600 ml-2">${record.specialPrice.toFixed(2)}</span>
                                    <span className="text-gray-500 ml-2">@{formatUnitPrice(record.unitPrice)}</span>
                                </span>
                            ) : (
                                <span className="text-[22px] text-red-600">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</span>
                            )}
                            <span className="text-xs text-gray-500">{record.timestamp.toLocaleString()}</span>
                        </div>
                        <p className="text-sm text-gray-700 mt-1">商店: {record.storeName || '未標註'}</p>
                        {/* 顯示數量和單位資訊 */}
                        {record.quantity && record.unitType && <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType} (總價: ${(record.price || 0).toFixed(2)})</p>}
                        {record.discountDetails && <p className="text-xs text-indigo-600 italic">優惠: {record.discountDetails}</p>}
                        {index === 0 && <span className={`text-xs font-semibold px-2 py-0.5 rounded-full text-white ${theme.primary}`}>最新紀錄</span>}
                    </div>
                ))}
            </div>
        </div>
    );
}

const THEMES = {
    'Default (Indigo)': { primary: 'bg-indigo-600', light: 'bg-indigo-100', hover: 'hover:bg-indigo-700', border: 'border-indigo-600', text: 'text-indigo-600', color: 'indigo' },
    '海洋藍 (Ocean Blue)': { primary: 'bg-blue-600', light: 'bg-blue-100', hover: 'hover:bg-blue-700', border: 'border-blue-600', text: 'text-blue-600', color: 'blue' },
    '森林綠 (Forest Green)': { primary: 'bg-green-600', light: 'bg-green-100', hover: 'hover:bg-green-700', border: 'border-green-600', text: 'text-green-600', color: 'green' },
    '夕陽紅 (Sunset Red)': { primary: 'bg-red-600', light: 'bg-red-100', hover: 'hover:bg-red-700', border: 'border-red-600', text: 'text-red-600', color: 'red' },
    '活力橙 (Vibrant Orange)': { primary: 'bg-orange-600', light: 'bg-orange-100', hover: 'hover:bg-orange-700', border: 'border-orange-600', text: 'text-orange-600', color: 'orange' },
    '薰衣草紫 (Lavender)': { primary: 'bg-purple-600', light: 'bg-purple-100', hover: 'hover:bg-purple-700', border: 'border-purple-600', text: 'text-purple-600', color: 'purple' },
};
const DEFAULT_THEME_KEY = 'Default (Indigo)';

function ThemeSelector({ theme, saveTheme, onClose }) {
    const handleThemeChange = (themeKey) => { saveTheme(themeKey); };
    const handleReset = () => { saveTheme(DEFAULT_THEME_KEY); };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 transform transition-all">
                <h3 className={`text-xl font-bold ${theme.text} mb-4 border-b pb-2`}><PaintBucket className="inline-block w-5 h-5 mr-2" />介面配色選項</h3>
                <div className="grid grid-cols-2 gap-4 mb-6">
                    {Object.keys(THEMES).map((themeKey) => {
                        const themeData = THEMES[themeKey];
                        const isSelected = theme.color === themeData.color;
                        return (
                            <button key={themeKey} onClick={() => handleThemeChange(themeKey)}
                                className={`p-3 rounded-lg text-white font-medium shadow-md transition-all ${themeData.primary} ${themeData.hover} ${isSelected ? 'ring-4 ring-offset-2 ring-opacity-70 ring-gray-400' : ''}`}
                                style={{ transform: isSelected ? 'scale(1.05)' : 'scale(1)' }}>
                                {themeKey}
                            </button>
                        );
                    })}
                </div>
                <div className="flex justify-between items-center pt-4 border-t">
                    <button onClick={handleReset} className="flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                        <RotateCcw className="w-4 h-4 mr-1" />清除還原 (預設)
                    </button>
                    <button onClick={onClose} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg ${theme.primary} ${theme.hover} transition-all`}>關閉</button>
                </div>
            </div>
        </div>
    );
}

// AIOcrCaptureModal 組件已移至獨立檔案 src/components/AIOcrCaptureModal.js


// ----------------------------------------------------------------------------
// 3. Firebase 身份驗證與主題設定 (Firebase Auth & Theming)
// ----------------------------------------------------------------------------

function useFirebaseAuthentication() {
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        const auth = getAuth();
        signInAnonymously(auth)
            .then((userCredential) => {
                setUserId(userCredential.user.uid);
                setIsAuthReady(true);
            })
            .catch((error) => {
                console.error("Firebase 匿名登入失敗:", error);
            });
    }, []);

    const [currentTheme, setCurrentTheme] = useState(() => {
        const savedKey = localStorage.getItem('appTheme') || DEFAULT_THEME_KEY;
        return THEMES[savedKey] || THEMES[DEFAULT_THEME_KEY];
    });

    const saveUserTheme = useCallback((themeKey) => {
        localStorage.setItem('appTheme', themeKey);
        setCurrentTheme(THEMES[themeKey] || THEMES[DEFAULT_THEME_KEY]);
    }, []);

    return { userId, isAuthReady, currentTheme, saveUserTheme };
}

// ----------------------------------------------------------------------------
// 4. 結果提示框 (Result Toast)
// ----------------------------------------------------------------------------
function SaveResultToast({ result, onClose }) {
    useEffect(() => {
        let timer;
        if (result) {
            timer = setTimeout(onClose, 5000);
        }
        return () => clearTimeout(timer);
    }, [result, onClose]);

    if (!result) {
        return null;
    }

    const { status, message, productName } = result;

    const theme = {
        success: { bg: 'bg-green-500', text: 'text-white', icon: <ClipboardCheck className="w-6 h-6 mr-3" /> },
        warning: { bg: 'bg-yellow-400', text: 'text-gray-800', icon: <DollarSign className="w-6 h-6 mr-3" /> },
        error: { bg: 'bg-red-500', text: 'text-white', icon: <X className="w-6 h-6 mr-3" /> },
    };

    const currentTheme = theme[status];

    return (
        <div className={`fixed top-20 left-1/2 -translate-x-1/2 max-w-md w-full p-4 rounded-xl shadow-2xl z-[100] ${currentTheme.bg} ${currentTheme.text} transition-all duration-300 ease-in-out`}>
            <div className="flex items-center">
                {currentTheme.icon}
                <div className="flex-grow">
                    <p className="font-bold text-lg">{productName}</p>
                    <p className="text-sm">{message}</p>
                    <p className="text-sm font-semibold mt-1">
                        資料儲存: {status === 'error' ? '失敗' : '成功'} | 
                        比價結果: {status === 'success' ? '是最低價' : (status === 'warning' ? '非最低價' : 'N/A')}
                    </p>
                </div>
                <button onClick={onClose} className="ml-4 p-1 rounded-full hover:bg-white/20"><X className="w-5 h-5" /></button>
            </div>
        </div>
    );
}


// ----------------------------------------------------------------------------
// 5. 主應用程式元件 (App Component)
// ----------------------------------------------------------------------------

function App() {
    const { userId, isAuthReady, currentTheme, saveUserTheme } = useFirebaseAuthentication();
    const streamRef = useRef(null);
    
    const [saveResultToast, setSaveResultToast] = useState(null);

    // UI 狀態
    const [barcode, setBarcode] = useState('');
    const [productName, setProductName] = useState('');
    const [currentPrice, setCurrentPrice] = useState('');
    const [quantity, setQuantity] = useState('');
    const [unitType, setUnitType] = useState('pcs'); // 'g', 'ml', 'pcs'
    const [unitPrice, setUnitPrice] = useState(null);
    const [discountDetails, setDiscountDetails] = useState('');
    const [storeName, setStoreName] = useState('');
    const [productHistory, setProductHistory] = useState([]);
    const [comparisonResult, setComparisonResult] = useState({ message: '等待比價數據...' });
    const [statusMessage, setStatusMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [lookupStatus, setLookupStatus] = useState('ready');
    
    // Modal and Page 狀態
    const [isThemeModalOpen, setIsThemeModalOpen] = useState(false);
    const [isCaptureModalOpen, setIsCaptureModalOpen] = useState(false);
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);
    const [isOcrQueueStoreSelectorOpen, setIsOcrQueueStoreSelectorOpen] = useState(false); // 新增狀態
    const [isSettingsOpen, setIsSettingsOpen] = useState(false); // 新增狀態
    const [editingOcrCard, setEditingOcrCard] = useState(null); // 新增狀態
    
    // 新增函數：處理數據刷新
    const handleDataRefresh = useCallback((key) => {
        // 如果清除的是 pendingOcrCards，需要更新狀態
        if (key === 'pendingOcrCards' || key === 'ALL') {
            const savedCards = localStorage.getItem('pendingOcrCards');
            setPendingOcrCards(savedCards ? JSON.parse(savedCards) : []);
        }
        // 可以在這裡添加其他需要刷新的狀態
    }, []);

    const [currentPage, setCurrentPage] = useState('main'); // 'main', 'allRecords', 'ocrQueue'
    const [ocrResult, setOcrResult] = useState(null);
    const [capturedImage, setCapturedImage] = useState(null); // 新增的狀態
    
    // 新增狀態：待辨識序列
    const [pendingOcrCards, setPendingOcrCards] = useState(() => {
        // 從 localStorage 恢復待辨識卡片
        const savedCards = localStorage.getItem('pendingOcrCards');
        return savedCards ? JSON.parse(savedCards) : [];
    });
    
    // 添加 useEffect 來保存 pendingOcrCards 到 localStorage
    useEffect(() => {
        localStorage.setItem('pendingOcrCards', JSON.stringify(pendingOcrCards));
    }, [pendingOcrCards]);
    
    useEffect(() => {
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const price = parseFloat(finalPrice);
        const qty = parseFloat(quantity);

        if (!isNaN(price) && !isNaN(qty) && qty > 0) {
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(price, qty, unitType);
            setUnitPrice(calculatedUnitPrice);
        } else {
            setUnitPrice(null);
        }
    }, [currentPrice, quantity, unitType, ocrResult]);
    
    // 提前定義所有會被使用的函數，避免 no-use-before-define 警告
    const clearForm = useCallback(() => {
        setBarcode('');
        setProductName('');
        setCurrentPrice('');
        setQuantity('');
        setUnitType('pcs'); // Reset to default unit type
        setUnitPrice(null);
        setDiscountDetails('');
        setStoreName('');
        setProductHistory([]);
        setComparisonResult({ message: '等待比價數據...' });
        setOcrResult(null);
        setLookupStatus('ready');
        setCapturedImage(null); // 清除擷取的圖片
    }, []);

    const stopCameraStream = useCallback(() => {
        console.log("stopCameraStream: Attempting to stop camera.");
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
            console.log("stopCameraStream: Camera stream stopped.");
        }
    }, []);
    
    const startCameraStream = async () => {
        console.log("startCameraStream: Attempting to start camera.");
        if (streamRef.current) {
            return streamRef.current;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
            streamRef.current = stream;
            console.log("startCameraStream: Camera started successfully.");
            return stream;
        } catch (err) {
            console.error("無法存取攝影機:", err);
            setStatusMessage(`無法存取攝影機: ${err.name}`);
            return null;
        }
    };

    const lookupProduct = useCallback(async (barcodeData, currentProductName, currentStoreName) => {
        // 如果 Firebase 尚未初始化，則不執行查詢
        if (!isAuthReady || !userId) {
            return;
        }
        
        const numericalID = generateProductId(barcodeData, currentProductName, currentStoreName);

        // Adjust early exit condition:
        // If no barcode and no product name, or if barcode is too short and no product name,
        // then we can't look up a product.
        if (!numericalID) { // If numericalID couldn't be generated, then we can't look up a product.
            setProductName('');
            setLookupStatus('ready');
            setProductHistory([]);
            return;
        }
        
        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);

            if (productSnap.exists()) {
                setProductName(productSnap.data().productName);
                setLookupStatus('found');
            } else {
                setLookupStatus('new');
            }

            const recordsQueryString = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID), // numericalID is already a string
                orderBy("timestamp", "desc")
            );
            const recordsSnapString = await getDocs(recordsQueryString);
            let records = recordsSnapString.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Attempt to query for numericalID as a number, if it's a valid number string
            const numericalIDAsNumber = parseInt(numericalID, 10);
            if (!isNaN(numericalIDAsNumber) && numericalIDAsNumber.toString() === numericalID) { // Check if it's a pure number string
                const recordsQueryNumber = query(
                    collection(db, "priceRecords"),
                    where("numericalID", "==", numericalIDAsNumber),
                    orderBy("timestamp", "desc")
                );
                const recordsSnapNumber = await getDocs(recordsQueryNumber);
                const recordsNumber = recordsSnapNumber.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Merge and deduplicate records
                const mergedRecordsMap = new Map();
                records.forEach(record => mergedRecordsMap.set(record.id, record));
                recordsNumber.forEach(record => mergedRecordsMap.set(record.id, record));
                records = Array.from(mergedRecordsMap.values()).sort((a, b) => (b.timestamp?.toDate ? b.timestamp.toDate().getTime() : 0) - (a.timestamp?.toDate ? a.timestamp.toDate().getTime() : 0));
            }
            setProductHistory(records);

        } catch (error) {
            console.error("查詢產品失敗 (Firestore):", error);
            setStatusMessage("查詢產品資料時發生錯誤。");
            setLookupStatus('ready');
            setProductHistory([]);
        }
    }, [isAuthReady, userId, setProductName, setLookupStatus, setProductHistory, setStatusMessage]);

    // 新增函數：處理 OCR 隊列的商店選擇
    const handleOcrQueueStoreSelect = useCallback((card) => {
        setEditingOcrCard(card);
        setIsOcrQueueStoreSelectorOpen(true);
    }, [setEditingOcrCard, setIsOcrQueueStoreSelectorOpen]);

    // 新增函數：處理 OCR 隊列的商店選擇確認
    const handleOcrQueueStoreSelectConfirm = useCallback((selectedStore) => {
        if (editingOcrCard) {
            // 更新待辨識卡片的商店名稱
            const updatedCards = pendingOcrCards.map(card => 
                card.id === editingOcrCard.id ? { ...card, storeName: selectedStore } : card
            );
            setPendingOcrCards(updatedCards);
        }
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [editingOcrCard, pendingOcrCards, setPendingOcrCards, setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 新增函數：處理 OCR 隊列的商店選擇器關閉
    const handleOcrQueueStoreSelectorClose = useCallback(() => {
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 正確地提前定義 performSaveAndCompare 函數（必須在 saveAndComparePrice 之前定義）
    const performSaveAndCompare = useCallback(async (selectedStore) => {
        const finalStoreName = selectedStore || storeName;
        const numericalID = generateProductId(barcode, productName, finalStoreName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const priceValue = parseFloat(finalPrice);

        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, quantity, unitType);

        if (!userId || !productName || isNaN(priceValue) || isNaN(parseFloat(quantity)) || parseFloat(quantity) <= 0 || calculatedUnitPrice === null) {
            showUserFriendlyError("請確保已輸入條碼、產品名稱、有效總價、數量和單位！", "資料驗證");
            setIsLoading(false);
            return;
        }
        if (!finalStoreName.trim()) {
            setIsStoreSelectorOpen(true);
            setIsLoading(false);
            return;
        }

        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);
            
            // 準備產品文檔數據
            const productData = {
                numericalID,
                barcodeData: barcode,
                productName,
                createdAt: productSnap.exists() ? productSnap.data().createdAt : serverTimestamp(),
                lastUpdatedBy: userId,
            };

            // 準備價格記錄數據
            const priceRecord = {
                numericalID,
                productName,
                storeName: finalStoreName,
                price: priceValue, // 總價
                quantity: parseFloat(quantity),
                unitType: unitType,
                unitPrice: calculatedUnitPrice, // 單價
                discountDetails: discountDetails || '',
                timestamp: serverTimestamp(),
                recordedBy: userId,
                // 保存原價和特價信息（如果有的話）
                originalPrice: ocrResult?.originalPrice ? parseFloat(ocrResult.originalPrice) : null,
                specialPrice: ocrResult?.specialPrice ? parseFloat(ocrResult.specialPrice) : null
            };

            // 儲存價格記錄
            const priceRecordDocRef = await addDoc(collection(db, "priceRecords"), priceRecord);
            
            // 檢查是否需要更新產品文檔中的最佳單價
            let isBestPrice = false;
            if (productSnap.exists()) {
                const existingProductData = productSnap.data();
                // 如果產品文檔中沒有 bestUnitPrice 或新價格更低，則更新
                if (existingProductData.bestUnitPrice === undefined || calculatedUnitPrice < existingProductData.bestUnitPrice) {
                    productData.bestUnitPrice = calculatedUnitPrice;
                    productData.bestPriceRecordRef = priceRecordDocRef.path; // 儲存指向最佳價格記錄的引用路徑
                    isBestPrice = true;
                } else {
                    // 保持現有的最佳價格信息
                    productData.bestUnitPrice = existingProductData.bestUnitPrice;
                    productData.bestPriceRecordRef = existingProductData.bestPriceRecordRef;
                }
            } else {
                // 新產品，當前價格就是最佳價格
                productData.bestUnitPrice = calculatedUnitPrice;
                productData.bestPriceRecordRef = priceRecordDocRef.path;
                isBestPrice = true;
            }
            
            // 儲存或更新產品文檔
            await setDoc(productRef, productData);

            // 準備比價結果
            let toastStatus, toastMessage, isBest, bestPrice, bestStore;

            if (isBestPrice) {
                isBest = true;
                bestPrice = calculatedUnitPrice;
                bestStore = finalStoreName;
                toastStatus = 'success';
                toastMessage = '恭喜！這是目前紀錄中的最低單價！';
            } else {
                isBest = false;
                bestPrice = productData.bestUnitPrice;
                
                // 從 Firestore 獲取最佳價格記錄的商店名稱
                try {
                    const bestPriceRecordDoc = await getDoc(doc(db, productData.bestPriceRecordRef));
                    if (bestPriceRecordDoc.exists()) {
                        bestStore = bestPriceRecordDoc.data().storeName;
                    } else {
                        bestStore = '未知商店';
                    }
                } catch (error) {
                    console.error("獲取最佳價格記錄失敗:", error);
                    bestStore = '未知商店';
                }
                
                toastStatus = 'warning';
                toastMessage = `非最低單價。歷史最低單價為 $${formatUnitPrice(productData.bestUnitPrice)} (${bestStore})`;
            }

            setComparisonResult({ isBest, bestPrice, bestStore, message: toastMessage });
            // 儲存成功時顯示提示訊息
            setSaveResultToast({ status: toastStatus, message: toastMessage, productName: productName });
            
            lookupProduct(barcode, productName, finalStoreName);

        } catch (error) {
            console.error("儲存或比價失敗 (Firestore):", error);
            const userMessage = handleFirestoreSaveError(error, "儲存價格資訊");
            showUserFriendlyError(userMessage);
        } finally {
            setIsLoading(false);
        }
    }, [userId, barcode, productName, currentPrice, discountDetails, storeName, lookupProduct, quantity, unitType, setSaveResultToast, setComparisonResult, setIsLoading, setIsStoreSelectorOpen, ocrResult]);

    // 正確地提前定義 saveAndComparePrice 函數
    const saveAndComparePrice = useCallback(async (selectedStore) => {
        // 確保 Firebase 已初始化，如果尚未完成初始化則強制初始化
        if (!isAuthReady) {
            // 顯示加載訊息並等待初始化完成
            setIsLoading(true);
            // 等待 Firebase 初始化完成
            const checkAuth = () => {
                if (isAuthReady) {
                    // 初始化完成後繼續執行
                    performSaveAndCompare(selectedStore);
                } else {
                    // 繼續等待
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
            return;
        }
        
        // 如果 Firebase 已準備好，直接執行保存操作
        performSaveAndCompare(selectedStore);
    }, [isAuthReady, performSaveAndCompare]);
    
    const handleAiCaptureSuccess = useCallback((result) => {
        const { scannedBarcode, productName, extractedPrice, storeName, discountDetails, quantity, unitType, specialPrice, capturedImage: receivedImage } = result;
        setOcrResult(result);
        
        // 設置捕獲的圖像
        if (receivedImage) {
            setCapturedImage(receivedImage);
        }
        
        const newBarcode = scannedBarcode || '';
        setBarcode(newBarcode);

        if (!newBarcode) {
            setStatusMessage("AI 未能識別條碼，請手動輸入或確保條碼清晰！");
        } else {
            setStatusMessage(`AI 分析成功！`);
        }

        setProductName(productName || '');
        
        // 優先使用特價，如果有的話
        const finalPrice = specialPrice && !isNaN(parseFloat(specialPrice)) ? specialPrice : extractedPrice;
        setCurrentPrice(finalPrice || '');
        
        setStoreName(storeName || '');
        setDiscountDetails(discountDetails || '');

        setQuantity(quantity || '');
        setUnitType(unitType || 'pcs');

        if (productName && newBarcode) {
            setLookupStatus('found');
        } else {
            setLookupStatus('new');
        }
    }, [setBarcode, setProductName, setCurrentPrice, setStoreName, setDiscountDetails, setOcrResult, setStatusMessage, setLookupStatus, setQuantity, setUnitType, setCapturedImage]);

    // 定義一個新的函式來處理 Firebase 備份
    const backupOcrCardToFirebase = useCallback(async (cardData) => {
        // 檢查 Firebase 是否準備好
        if (!isAuthReady || !userId) {
            // 由於功能要求是自動備份，若服務未準備好，則將其視為 pending 或 error (可選)
            console.warn("Firebase 服務尚未準備好，跳過備份。");
            // 由於此專案似乎有 MVP 階段屏蔽 Firebase 的歷史需求，
            // 這裡可以選擇將狀態設為 'error' 或保留 'pending'。
            // 為避免影響核心功能，建議在此處直接返回，讓卡片保持 'pending' 狀態。
            return;
        }

        const cardToSave = {
            ...cardData,
            userId: userId, // 儲存用戶 ID
            timestamp: serverTimestamp(), // 使用 Firebase 服務器時間戳
            // 移除本地 ID 和同步狀態，因為這些只用於本地 UI
            id: undefined, 
            syncStatus: undefined
        };

        try {
            // 將卡片數據儲存到 pendingOcrCards 集合
            const docRef = await addDoc(collection(db, "pendingOcrCards"), cardToSave);
            
            // 成功後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'success', fbDocId: docRef.id } : c
                )
            );

        } catch (error) {
            console.error("Firebase 待辨識卡片備份失敗:", error);
            handleFirestoreSaveError(error, "備份待辨識卡片"); // 使用錯誤處理機制
            
            // 失敗後更新本地狀態
            setPendingOcrCards(prevCards => 
                prevCards.map(c => 
                    c.id === cardData.id ? { ...c, syncStatus: 'error' } : c
                )
            );
        }
    }, [isAuthReady, userId, setPendingOcrCards]);

    // 新增函數：將辨識結果加入待確認序列
    const handleQueueNextCapture = useCallback((result) => {
        // 1. 建立具有初始同步狀態的新卡片物件
        const newCard = {
            ...result,
            id: uuidv4(), // 確保本地狀態有一個唯一 ID
            timestamp: Date.now(), // 本地時間戳 (用於排序/顯示)
            syncStatus: 'pending', // 初始狀態設為處理中
        };
        
        // 2. 更新本地狀態 (立即顯示卡片)
        setPendingOcrCards(prev => [...prev, newCard]);

        // 3. 觸發 Firebase 備份
        backupOcrCardToFirebase(newCard); 
        
        setStatusMessage(`已將辨識結果加入待確認序列！`);
    }, [setPendingOcrCards, backupOcrCardToFirebase]);

    // 新增函數：移除待確認的辨識卡片
    const handleRemovePendingOcrCard = useCallback((cardId) => {
        setPendingOcrCards(prev => prev.filter(item => item.id !== cardId));
    }, []);

    const handleStoreSelect = useCallback((selectedStore) => {
        setStoreName(selectedStore);
        setIsStoreSelectorOpen(false);
        // 不再自動觸發保存操作，與其他頁面保持一致
    }, [setStoreName, setIsStoreSelectorOpen]);

    const handleCaptureModalClose = useCallback(() => {
        setIsCaptureModalOpen(false);
        stopCameraStream();
    }, [stopCameraStream]);

    const handleNewScanClick = async () => {
        clearForm();
        const stream = await startCameraStream();
        if (stream) {
            setIsCaptureModalOpen(true);
        } else {
            // 如果無法啟動相機，顯示錯誤訊息
            setStatusMessage("無法啟動相機，請檢查權限設置");
        }
    };

    const themePrimary = currentTheme.primary;
    const themeText = currentTheme.text;
    const themeLight = currentTheme.light;
    const themeBorder = currentTheme.border;
    const themeHover = currentTheme.hover; // 添加這一行來定義 themeHover

    const productNamePlaceholder = useMemo(() => {
        switch(lookupStatus) {
            case 'searching': return '正在查詢產品資料...';
            case 'found': return '產品名稱已自動載入';
            case 'new': return '產品不存在，請手動輸入名稱';
            default: return '請先輸入條碼或掃描條碼';
        }
    }, [lookupStatus]);

    if (!isAuthReady) {
        return <div className="flex items-center justify-center min-h-screen bg-gray-50"><p className="text-xl text-gray-700">正在連線至雲端服務...</p></div>;
    }

    if (currentPage === 'allRecords') {
        return <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />;
    }

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${themeLight}`}>
            <SaveResultToast result={saveResultToast} onClose={() => setSaveResultToast(null)} />
            
            {/* 新增 SettingsPage 的渲染 */}
            {isSettingsOpen && (
                <SettingsPage 
                    theme={currentTheme} 
                    onClose={() => setIsSettingsOpen(false)} 
                    onDataChange={handleDataRefresh}
                />
            )}

            {/* 根據 currentPage 狀態渲染不同頁面 */}
            {currentPage === 'main' && (
                <div className="max-w-xl mx-auto">
                    <header className="flex justify-between items-center mb-6 border-b pb-4">
                        <h1 className={`text-3xl font-extrabold ${themeText} flex items-center`}><Barcode className="w-8 h-8 mr-2" />條碼比價神器 (Cloud)</h1>
                        <div className="flex items-center space-x-3">
                            {/* 新增待辨識的按鈕 */}
                            <button 
                                onClick={() => setCurrentPage('ocrQueue')}
                                className={`relative p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`}
                                title={`待辨識 (${pendingOcrCards.length})`}
                            >
                                <Zap className="w-5 h-5" />
                                {pendingOcrCards.length > 0 && (
                                    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                                        {pendingOcrCards.length}
                                    </span>
                                )}
                            </button>
                            <button onClick={() => setCurrentPage('allRecords')} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="查看所有記錄"><Database className="w-5 h-5" /></button>
                            <button onClick={() => setIsThemeModalOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定介面主題"><PaintBucket className="w-5 h-5" /></button>
                            {/* 新增設定按鈕 */}
                            <button onClick={() => setIsSettingsOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定"><SettingsIcon className="w-5 h-5" /></button>
                            <p className="text-sm text-gray-500 hidden sm:block">User: {userId.slice(0, 8)}...</p>
                        </div>
                    </header>

                    {statusMessage && <div className="bg-blue-500 text-white p-3 rounded-lg shadow-md mb-4 text-center font-medium">{statusMessage}</div>}

                    {ocrResult && (
                        <div className="bg-yellow-100 border border-yellow-300 rounded-lg p-4 mb-6">
                            <h3 className="text-lg font-semibold text-yellow-800 mb-2">AI 辨識結果 (開發者確認區)</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm">
                                <div>條碼:</div><div>{ocrResult.scannedBarcode || 'N/A'}</div>
                                <div>品名:</div><div>{ocrResult.productName || 'N/A'}</div>
                                {/* 顯示原價和特價信息 */}
                                {ocrResult.specialPrice ? (
                                    <>
                                        {ocrResult.originalPrice && (
                                            <>
                                                <div>原價:</div><div className="line-through text-red-500">${ocrResult.originalPrice.toFixed(2)}</div>
                                            </>
                                        )}
                                        <div>特價:</div><div className="text-green-600 font-bold">${ocrResult.specialPrice.toFixed(2)}</div>
                                    </>
                                ) : (
                                    <>
                                        <div>價格:</div><div>${ocrResult.extractedPrice || 'N/A'}</div>
                                    </>
                                )}
                                <div>數量:</div><div>{ocrResult.quantity || 'N/A'}</div>
                                <div>商店:</div><div>{ocrResult.storeName || 'N/A'}</div>
                                <div>折扣:</div><div>{ocrResult.discountDetails || '無'}</div>
                            </div>
                            <button onClick={() => setOcrResult(null)} className="mt-3 px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 text-sm">關閉</button>
                        </div>
                    )}

                    <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${themeBorder}`}>
                        <h2 className={`text-xl font-semibold ${themeText} mb-6 flex items-center`}><Zap className="w-5 h-5 mr-2" />步驟 1: AI 視覺自動擷取</h2>
                        <button className={`w-full p-4 rounded-lg text-white font-bold text-lg shadow-xl transition-all ${themePrimary} hover:opacity-80 flex items-center justify-center`} onClick={handleNewScanClick}>
                            <Camera className="inline-block w-6 h-6 mr-3" />開啟鏡頭擷取
                        </button>
                        <hr className="my-6 border-gray-200" />
                        <h2 className={`text-xl font-semibold text-gray-700 mb-4 flex items-center`}><FileText className="w-5 h-5 mr-2" />步驟 2: 檢查或手動輸入</h2>
                        
                        {/* 新增的擷取畫面顯示區塊 */}
                        {capturedImage && (
                            <div className="mb-6">
                                <label className="block text-gray-700 font-medium mb-2">擷取畫面 (請確認辨識資料是否正確)</label>
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                    <div className="relative w-full aspect-video">
                                        {capturedImage.startsWith('data:image') ? (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        ) : (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        )}
                                    </div>
                                </div>
                                <p className="text-sm text-gray-500 mt-2">此圖片將持續顯示直到進行下一次辨識或退出應用程式</p>
                            </div>
                        )}
                        
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">條碼數據</label>
                            <input type="text" value={barcode} onChange={(e) => setBarcode(e.target.value)} placeholder="AI 自動填入，或手動輸入" className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" />
                        </div>
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">產品名稱</label>
                            <input type="text" value={productName} onChange={(e) => setProductName(e.target.value)} placeholder={productNamePlaceholder} className={`w-full p-3 border border-gray-300 rounded-lg ${lookupStatus === 'found' ? 'bg-green-50' : lookupStatus === 'new' ? 'bg-yellow-50' : ''}`} readOnly={lookupStatus === 'found' && !ocrResult} />
                            <p className="text-sm text-gray-500 mt-1">ID (Hash): {barcode ? djb2Hash(barcode) : 'N/A'}</p>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">總價 ($) <span className="text-red-500">*</span></label>
                                <input type="number" value={currentPrice} onChange={(e) => setCurrentPrice(e.target.value)} placeholder="AI 擷取" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">商店名稱</label>
                                <input 
                                    type="text" 
                                    value={storeName} 
                                    onFocus={() => setIsStoreSelectorOpen(true)}
                                    readOnly
                                    placeholder="點擊選擇商店"
                                    className="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 cursor-pointer"
                                />
                            </div>
                        </div>
                        <div className="grid grid-cols-3 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">數量 <span className="text-red-500">*</span></label>
                                <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="例如: 500" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單位 <span className="text-red-500">*</span></label>
                                <select value={unitType} onChange={(e) => setUnitType(e.target.value)} className="w-full p-3 border border-gray-300 rounded-lg">
                                    <option value="ml">ml (毫升)</option>
                                    <option value="g">g (克)</option>
                                    <option value="pcs">pcs (個/包/支/條)</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單價 (每100g/ml)</label>
                                <input type="text" value={formatUnitPrice(unitPrice)} readOnly className="w-full p-3 border border-gray-300 rounded-lg bg-gray-100" />
                            </div>
                        </div>
                        <div className="mb-6">
                            <label className="block text-gray-700 font-medium mb-1">優惠細節</label>
                            <input type="text" value={discountDetails} onChange={(e) => setDiscountDetails(e.target.value)} placeholder="例如: 買二送一" className="w-full p-3 border border-gray-300 rounded-lg" />
                        </div>
                        <button className={`w-full mt-4 p-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-emerald-500 hover:bg-emerald-600`} onClick={() => saveAndComparePrice()} disabled={isLoading}>
                            <ClipboardCheck className="inline-block w-5 h-5 mr-2" />{isLoading ? '處理中...' : '步驟 3: 儲存紀錄並比價'}
                        </button>
                    </div>

                    <div className="mt-8">
                        <h2 className={`text-xl font-semibold ${themeText} mb-4 flex items-center`}>
                            <DollarSign className="w-5 h-5 mr-2" />
                            比價結果 {productName && <span className="ml-2 font-normal text-gray-500">- {productName}</span>}
                        </h2>
                        <div className={`p-6 rounded-xl shadow-xl border-2 ${comparisonResult.isBest ? 'border-green-500 bg-green-50' : 'border-yellow-500 bg-yellow-50'}`}>
                            <p className={`text-lg font-bold ${comparisonResult.isBest ? 'text-green-700' : 'text-yellow-700'}`}>{comparisonResult.message}</p>
                            {comparisonResult.bestPrice && <p className="text-sm text-gray-600 mt-2">歷史最低標價: ${comparisonResult.bestPrice}</p>}
                            <p className="text-xs text-gray-500 mt-2">**附註:** 您的紀錄已安全儲存在雲端。</p>
                        </div>
                    </div>

                    {(lookupStatus === 'found' || lookupStatus === 'new') && <PriceHistoryDisplay historyRecords={productHistory} theme={currentTheme} />}
                    
                    {/* 在主介面添加一個快捷處理待辨識卡片的按鈕 */}
                    {pendingOcrCards.length > 0 && (
                        <div className="mt-4 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold text-yellow-800">有待辨識的項目</h3>
                                    <p className="text-sm text-yellow-600">您有 {pendingOcrCards.length} 個待辨識的項目等待處理</p>
                                </div>
                                <button 
                                    onClick={() => {
                                        // 處理第一個待辨識的卡片
                                        const firstCard = pendingOcrCards[0];
                                        
                                        // 設置表單數據
                                        setOcrResult(firstCard);
                                        setCapturedImage(firstCard.capturedImage);
                                        setBarcode(firstCard.scannedBarcode || '');
                                        setProductName(firstCard.productName || '');
                                        setCurrentPrice(firstCard.extractedPrice || '');
                                        setStoreName(firstCard.storeName || '');
                                        setDiscountDetails(firstCard.discountDetails || '');
                                        setQuantity(firstCard.quantity || '');
                                        setUnitType(firstCard.unitType || 'pcs');
                                        
                                        // 計算單價
                                        const priceValue = parseFloat(firstCard.extractedPrice);
                                        const qty = parseFloat(firstCard.quantity);
                                        if (!isNaN(priceValue) && !isNaN(qty) && qty > 0) {
                                            const calculatedUnitPrice = calculateUnitPrice(priceValue, qty, firstCard.unitType);
                                            setUnitPrice(calculatedUnitPrice);
                                        }
                                        
                                        // 更新狀態
                                        if (firstCard.productName && firstCard.scannedBarcode) {
                                            setLookupStatus('found');
                                        } else {
                                            setLookupStatus('new');
                                        }
                                        
                                        // 從待辨識序列中移除該卡片
                                        setPendingOcrCards(prev => prev.filter(item => item.id !== firstCard.id));
                                        
                                        // 顯示提示訊息
                                        setStatusMessage(`已載入待辨識項目: ${firstCard.productName || '未命名產品'}`);
                                    }}
                                    className={`px-4 py-2 rounded-lg text-white font-medium ${themePrimary} ${themeHover}`}
                                >
                                    處理第一個待辨識項目
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            )}
            
            {currentPage === 'allRecords' && (
                <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />
            )}
            
            {currentPage === 'ocrQueue' && (
                <OcrQueuePage 
                    theme={currentTheme} 
                    onBack={() => setCurrentPage('main')} 
                    pendingOcrCards={pendingOcrCards}
                    onRemoveCard={handleRemovePendingOcrCard}
                    onStoreSelect={setPendingOcrCards}
                    isStoreSelectorOpen={isOcrQueueStoreSelectorOpen}
                    onStoreSelectCallback={handleOcrQueueStoreSelect}
                    onCloseStoreSelector={handleOcrQueueStoreSelectorClose}
                />
            )}

            {isThemeModalOpen && <ThemeSelector theme={currentTheme} saveTheme={saveUserTheme} onClose={() => setIsThemeModalOpen(false)} />}
            {isCaptureModalOpen && <AIOcrCaptureModal theme={currentTheme} onAnalysisSuccess={handleAiCaptureSuccess} onClose={handleCaptureModalClose} stream={streamRef.current} onQueueNextCapture={handleQueueNextCapture} />}
            {isStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleStoreSelect} onClose={() => setIsStoreSelectorOpen(false)} />}
            {isOcrQueueStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleOcrQueueStoreSelectConfirm} onClose={handleOcrQueueStoreSelectorClose} />}
        </div>
    );
}

export default App;
</file>

<file path="components/AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

</files>
</file>

<file path="components/DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="components/SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

<file path="firebase-config.js">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAtaZL06wkWJHhOJdne2Z_h9fMIEYldgjM",
  authDomain: "barcodepricing-00898.firebaseapp.com",
  projectId: "barcodepricing-00898",
  storageBucket: "barcodepricing-00898.firebasestorage.app",
  messagingSenderId: "286146042453",
  appId: "1:286146042453:web:14a20a662dcf3d06f592dc",
  measurementId: "G-6GMRVJ4S52"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

export { db };
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="OcrQueuePage.js">
import React, { useState, useEffect, useCallback } from 'react';
import { ArrowLeft, Trash2, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { db } from './firebase-config.js';
import { doc, setDoc, addDoc, collection, serverTimestamp, getDoc, query, where, getDocs } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 計算 localStorage 使用量的函數
function getLocalStorageUsage() {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += (localStorage[key].length + key.length) * 2; // 每個字符佔用 2 bytes
    }
  }
  const used = (total / 1024).toFixed(2); // 轉換為 KB
  const quota = 5120; // 大多数瀏覽器的 localStorage 限制約為 5MB
  const percentage = ((used / quota) * 100).toFixed(2);
  
  return {
    used: used,
    quota: quota,
    percentage: percentage
  };
}

// 刪除確認對話框組件
function DeleteConfirmation({ card, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p className="mb-4">您確定要刪除此待辨識項目嗎？</p>
                <p className="mb-4 font-semibold text-gray-800">{card.productName || '未命名產品'}</p>
                <div className="flex justify-end space-x-3">
                    <button 
                        onClick={onClose}
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                    >
                        取消
                    </button>
                    <button 
                        onClick={onConfirm}
                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                    >
                        確認刪除
                    </button>
                </div>
            </div>
        </div>
    );
}

function OcrQueuePage({ theme, onBack, pendingOcrCards, onRemoveCard, onStoreSelect, 
    isStoreSelectorOpen, onStoreSelectCallback, onCloseStoreSelector }) {
    const [queueStats, setQueueStats] = useState({
        total: 0,
        oldest: null,
        newest: null
    });
    
    // 新增狀態：localStorage 使用量
    const [localStorageUsage, setLocalStorageUsage] = useState({
        used: 0,
        quota: 5120,
        percentage: 0
    });
    
    // 新增狀態：刪除確認對話框
    const [deleteConfirmation, setDeleteConfirmation] = useState(null);
    
    // 新增狀態：正在編輯的卡片
    // 移除 editingCard 狀態，因為現在由父組件控制
    // const [editingCard, setEditingCard] = useState(null);
    
    // 新增狀態：比價結果
    const [priceComparisonResults, setPriceComparisonResults] = useState({});

    useEffect(() => {
        if (pendingOcrCards.length > 0) {
            const timestamps = pendingOcrCards.map(card => card.id);
            setQueueStats({
                total: pendingOcrCards.length,
                oldest: Math.min(...timestamps),
                newest: Math.max(...timestamps)
            });
        } else {
            setQueueStats({
                total: 0,
                oldest: null,
                newest: null
            });
        }
        
        // 更新 localStorage 使用量
        setLocalStorageUsage(getLocalStorageUsage());
    }, [pendingOcrCards]);

    const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleString('zh-TW');
    };

    const calculateDuration = (timestamp) => {
        const now = Date.now();
        const diffMs = now - timestamp;
        const diffSecs = Math.floor(diffMs / 1000);
        const diffMins = Math.floor(diffSecs / 60);
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            return `${diffHours}小時前`;
        } else if (diffMins > 0) {
            return `${diffMins}分鐘前`;
        } else {
            return `${diffSecs}秒前`;
        }
    };

    // 處理刪除操作
    const handleDeleteClick = (card) => {
        setDeleteConfirmation(card);
    };

    // 確認刪除
    const confirmDelete = () => {
        if (deleteConfirmation) {
            onRemoveCard(deleteConfirmation.id);
            setDeleteConfirmation(null);
            // 刪除後更新 localStorage 使用量
            setTimeout(() => {
                setLocalStorageUsage(getLocalStorageUsage());
            }, 100);
        }
    };

    // 取消刪除
    const cancelDelete = () => {
        setDeleteConfirmation(null);
    };

    // 處理儲存操作 - 檢查商店名稱
    const handleSaveClick = async (card) => {
        // 檢查商店名稱是否為空白
        if (!card.storeName || card.storeName.trim() === '') {
            // 如果商店名稱為空白，顯示商店選擇器
            onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
        } else {
            // 如果商店名稱不為空白，直接儲存（不再彈出確認對話框）
            try {
                // 儲存到 Firebase
                await saveOcrCardToFirebase(card);
                
                // 從待辨識序列中移除
                onRemoveCard(card.id);
                
                // 儲存後更新 localStorage 使用量
                setTimeout(() => {
                    setLocalStorageUsage(getLocalStorageUsage());
                }, 100);
                
                // 儲存成功時不顯示任何訊息
            } catch (error) {
                console.error("儲存失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "儲存待辨識卡片");
                showUserFriendlyError(userMessage);
            }
        }
    };

    // 處理卡片欄位變更
    const handleCardChange = (cardId, field, value) => {
        const updatedCards = pendingOcrCards.map(card => 
            card.id === cardId ? { ...card, [field]: value } : card
        );
        onStoreSelect(updatedCards);
        
        // 當價格相關欄位變更時，重新計算比價結果
        if (field === 'extractedPrice' || field === 'specialPrice' || field === 'originalPrice' || field === 'quantity' || field === 'unitType') {
            // 延遲一點時間再重新計算，確保狀態已更新
            setTimeout(() => {
                const fetchPriceComparisonResults = async () => {
                    const results = {};
                    for (const card of updatedCards) {
                        const result = await checkIfBestPrice(card, updatedCards);
                        results[card.id] = result;
                    }
                    setPriceComparisonResults(results);
                };
                
                fetchPriceComparisonResults();
            }, 0);
        }
    };

    // 處理商店欄位點擊
    const handleStoreClick = (card) => {
        onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
    };

    // 儲存 OCR 卡片到 Firebase
    const saveOcrCardToFirebase = async (card) => {
        // 生成產品 ID
        const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
        const priceValue = parseFloat(finalPrice);
        
        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
        
        // 儲存產品資訊
        const productRef = doc(db, "products", numericalID.toString());
        const productSnap = await getDoc(productRef);
        if (!productSnap.exists()) {
            await setDoc(productRef, {
                numericalID,
                barcodeData: card.scannedBarcode,
                productName: card.productName,
                createdAt: serverTimestamp(),
                lastUpdatedBy: "ocr-queue", // 標記為來自 OCR 隊列
            });
        }
        
        // 儲存價格記錄
        const priceRecord = {
            numericalID,
            productName: card.productName,
            storeName: card.storeName,
            price: priceValue, // 總價
            quantity: parseFloat(card.quantity),
            unitType: card.unitType,
            unitPrice: calculatedUnitPrice, // 單價
            discountDetails: card.discountDetails || '',
            timestamp: serverTimestamp(),
            recordedBy: "ocr-queue", // 標記為來自 OCR 隊列
            // 保存原價和特價信息（如果有的話）
            originalPrice: card.originalPrice ? parseFloat(card.originalPrice) : null,
            specialPrice: card.specialPrice ? parseFloat(card.specialPrice) : null
        };
        
        await addDoc(collection(db, "priceRecords"), priceRecord);
    };

    // 生成產品 ID 的函數
    function generateProductId(barcode, productName, storeName) {
        function djb2Hash(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i);
            }
            return hash >>> 0;
        }
        
        if (barcode) {
            return djb2Hash(barcode).toString();
        } else {
            // Combine productName and storeName to create a unique ID for products without barcodes
            return djb2Hash(`${productName}-${storeName}`).toString();
        }
    }

    // 新增函數：檢查價格是否為歷史最低（包含待辨識序列中的卡片）
    const checkIfBestPrice = useCallback(async (card, allCards) => {
        try {
            // 生成產品 ID
            const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
            
            if (!numericalID) return null;
            
            // 使用新的價格計算函數來確定最終價格
            const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
            const priceValue = parseFloat(finalPrice);
            
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
            
            if (calculatedUnitPrice === null) return null;
            
            // 查詢 Firebase 中該產品的所有價格記錄
            const recordsQuery = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID)
            );
            
            const recordsSnap = await getDocs(recordsQuery);
            const records = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 準備所有記錄以進行比較（包括當前記錄和待辨識序列中的相同產品）
            let allRecordsForCompare = [...records, { 
                unitPrice: calculatedUnitPrice,
                timestamp: new Date()
            }];
            
            // 添加待辨識序列中相同產品的卡片（排除當前卡片）
            const sameProductCards = allCards.filter(c => 
                c.id !== card.id && 
                generateProductId(c.scannedBarcode, c.productName, c.storeName) === numericalID
            );
            
            // 將相同產品的卡片添加到比較列表中
            sameProductCards.forEach(c => {
                const cardFinalPrice = calculateFinalPrice(c.extractedPrice, c.specialPrice);
                const cardPriceValue = parseFloat(cardFinalPrice);
                const cardUnitPrice = calculateUnitPrice(cardPriceValue, c.quantity, c.unitType);
                
                if (cardUnitPrice !== null) {
                    allRecordsForCompare.push({
                        unitPrice: cardUnitPrice,
                        timestamp: new Date(c.id) // 使用卡片 ID 作為時間戳
                    });
                }
            });

            // 如果沒有歷史記錄，則當前價格就是最低價
            if (allRecordsForCompare.length <= 1) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            }
            
            // 使用與主頁面相同的比價邏輯
            const bestDeal = allRecordsForCompare.reduce((best, cur) => {
                const curUnitPrice = cur.unitPrice !== undefined && cur.unitPrice !== null ? cur.unitPrice : Infinity;
                const bestUnitPrice = best.unitPrice !== undefined && best.unitPrice !== null ? best.unitPrice : Infinity;
                return curUnitPrice < bestUnitPrice ? cur : best;
            });

            const isBest = calculatedUnitPrice <= (bestDeal.unitPrice !== undefined && bestDeal.unitPrice !== null ? bestDeal.unitPrice : Infinity);
            
            if (isBest) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            } else {
                return { isBest: false, message: "非歷史最低價", backgroundColor: "bg-yellow-100" };
            }
        } catch (error) {
            console.error("比價檢查失敗:", error);
            return null;
        }
    }, []);

    // 當待辨識卡片列表改變時，重新計算比價結果
    useEffect(() => {
        const fetchPriceComparisonResults = async () => {
            const results = {};
            for (const card of pendingOcrCards) {
                const result = await checkIfBestPrice(card, pendingOcrCards);
                results[card.id] = result;
            }
            setPriceComparisonResults(results);
        };
        
        if (pendingOcrCards.length > 0) {
            fetchPriceComparisonResults();
        } else {
            setPriceComparisonResults({});
        }
    }, [pendingOcrCards, checkIfBestPrice]);

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${theme.bg}`}>
            <div className="max-w-2xl mx-auto">
                <div className="flex items-center mb-6 border-b pb-4">
                    <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4">
                        <ArrowLeft className="mr-1" size={20} />返回
                    </button>
                    <h1 className={`text-2xl font-bold ${theme.text} flex items-center`}>
                        <Clock className="w-6 h-6 mr-2" />待辨識序列管理
                    </h1>
                </div>

                {queueStats.total > 0 ? (
                    <div className="mb-6 p-4 bg-white rounded-lg shadow">
                        <h2 className="text-lg font-semibold mb-3">序列統計</h2>
                        {/* 改為橫式條列呈現 */}
                        <div className="flex flex-wrap gap-4">
                            <div className="flex items-center">
                                <div className="bg-blue-100 p-2 rounded-full mr-2">
                                    <span className="text-blue-600 font-bold">{queueStats.total}</span>
                                </div>
                                <span className="text-gray-600">總數</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-green-100 p-2 rounded-full mr-2">
                                    <span className="text-green-600 font-bold">{queueStats.oldest ? formatTime(queueStats.oldest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最早</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-purple-100 p-2 rounded-full mr-2">
                                    <span className="text-purple-600 font-bold">{queueStats.newest ? formatTime(queueStats.newest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最新</span>
                            </div>
                        </div>
                        
                        {/* localStorage 使用量顯示 */}
                        <div className="mt-4 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                ) : (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <AlertCircle size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">無待辨識項目</h3>
                        <p className="text-gray-500">目前沒有任何待確認的辨識卡片</p>
                        
                        {/* localStorage 使用量顯示（即使沒有項目也顯示） */}
                        <div className="mt-6 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                )}

                <div className="space-y-4">
                    {pendingOcrCards.map((card) => (
                        <div 
                            key={card.id} 
                            className={`bg-white p-4 rounded-lg shadow border-4 relative ${
                                priceComparisonResults[card.id]?.isBest 
                                    ? 'border-green-500' 
                                    : 'border-yellow-500'
                            }`}
                        >
                            <div className="flex justify-between items-start">
                                <div className="flex-1">
                                    {/* 將比價結果移到卡片頂部 */}
                                    {priceComparisonResults[card.id] && (
                                        <div className={`mb-3 p-2 rounded text-center text-base font-bold ${
                                            priceComparisonResults[card.id].isBest 
                                                ? 'bg-green-500 text-white' 
                                                : 'bg-yellow-500 text-pink-800'
                                        }`}>
                                            {priceComparisonResults[card.id].message}
                                        </div>
                                    )}
                                    
                                    <input
                                        type="text"
                                        value={card.productName || ''}
                                        onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                        className="font-bold text-lg text-gray-800 w-full p-1 mb-2 border-b border-gray-300 focus:border-blue-500 focus:outline-none"
                                        placeholder="產品名稱"
                                    />
                                    
                                    {/* 擷取畫面顯示 */}
                                    {card.capturedImage && (
                                        <div className="mt-3 mb-3">
                                            <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                                <div className="relative w-full aspect-video">
                                                    {card.capturedImage.startsWith('data:image') ? (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    ) : (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-1 mt-1 text-sm">
                                        {/* 條碼欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">條碼數據</label>
                                            <input
                                                type="text"
                                                value={card.scannedBarcode || ''}
                                                onChange={(e) => handleCardChange(card.id, 'scannedBarcode', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="條碼"
                                            />
                                        </div>
                                        
                                        {/* 產品名稱欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">產品名稱</label>
                                            <input
                                                type="text"
                                                value={card.productName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="產品名稱"
                                            />
                                        </div>
                                        
                                        {/* 商店欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">商店名稱</label>
                                            <input
                                                type="text"
                                                value={card.storeName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'storeName', e.target.value)}
                                                onClick={() => handleStoreClick(card)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 bg-gray-50 cursor-pointer"
                                                placeholder="點擊選擇商店"
                                            />
                                        </div>
                                        
                                        {/* 價格欄位 */}
                                        {card.specialPrice !== undefined ? (
                                            <>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">原價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.originalPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'originalPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                        placeholder="原價"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">特價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.specialPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'specialPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 text-green-600 font-bold"
                                                        placeholder="特價"
                                                    />
                                                </div>
                                            </>
                                        ) : (
                                            <div className="col-span-2">
                                                <label className="block text-gray-700 font-medium mb-0.5">總價 ($)</label>
                                                <input
                                                    type="number"
                                                    value={card.extractedPrice || ''}
                                                    onChange={(e) => handleCardChange(card.id, 'extractedPrice', e.target.value)}
                                                    className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                    placeholder="價格"
                                                />
                                            </div>
                                        )}
                                        
                                        {/* 數量和單位 */}
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">數量</label>
                                            <input
                                                type="text"
                                                value={card.quantity || ''}
                                                onChange={(e) => handleCardChange(card.id, 'quantity', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="數量"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">單位</label>
                                            <select
                                                value={card.unitType || 'pcs'}
                                                onChange={(e) => handleCardChange(card.id, 'unitType', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                            >
                                                <option value="ml">ml (毫升)</option>
                                                <option value="g">g (克)</option>
                                                <option value="pcs">pcs (個/包/支/條)</option>
                                            </select>
                                        </div>
                                        
                                        {/* 單價 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">單價 (每100g/ml)</label>
                                            <input
                                                type="text"
                                                value={formatUnitPrice(card.unitPrice)}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded bg-gray-100"
                                            />
                                        </div>
                                        
                                        {/* 優惠資訊 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">優惠細節</label>
                                            <input
                                                type="text"
                                                value={card.discountDetails || ''}
                                                onChange={(e) => handleCardChange(card.id, 'discountDetails', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="優惠資訊"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>加入時間: {formatTime(card.id)}</p>
                                        <p>運行時間: {calculateDuration(card.id)}</p>
                                    </div>
                                    
                                    {/* 新增狀態圖示區塊 - 位於運行時間下面 */}
                                    <div className="absolute bottom-2 right-2">
                                        {card.syncStatus === 'pending' && (
                                            <Clock 
                                                className="w-4 h-4 text-yellow-500 animate-spin" 
                                                title="正在同步至 Firebase..." 
                                            />
                                        )}
                                        {card.syncStatus === 'success' && (
                                            <CheckCircle 
                                                className="w-4 h-4 text-green-500" 
                                                title="已成功同步至 Firebase" 
                                            />
                                        )}
                                        {card.syncStatus === 'error' && (
                                            <AlertCircle 
                                                className="w-4 h-4 text-red-500" 
                                                title="同步失敗，請檢查網路或重試" 
                                            />
                                        )}
                                    </div>
                                </div>
                                <div className="flex flex-col">
                                    <button 
                                        onClick={() => handleSaveClick(card)}
                                        className="p-2 text-green-500 hover:text-green-700 hover:bg-green-50 rounded-full"
                                        title="確認儲存"
                                    >
                                        <CheckCircle size={20} />
                                    </button>
                                    <button 
                                        onClick={() => handleDeleteClick(card)}
                                        className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full mt-5"
                                        title="刪除"
                                    >
                                        <Trash2 size={20} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            
            {/* 刪除確認對話框 - 保留 */}
            {deleteConfirmation && (
                <DeleteConfirmation 
                    card={deleteConfirmation}
                    onClose={cancelDelete}
                    onConfirm={confirmDelete}
                />
            )}
        </div>
    );
}

export default OcrQueuePage;
</file>

<file path="src.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AllRecordsPage.js
App.css
App.js
components/AIOcrCaptureModal.js
components/AIOcrCaptureModal備份
firebase-config.js
index.css
index.js
OcrQueuePage.js
StoreSelector.js
utils/errorHandler.js
utils/errorHandler.test.js
utils/priceCalculations.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AllRecordsPage.js">
import React, { useState, useEffect, useMemo, useRef, useCallback, useLayoutEffect } from 'react';
import { ArrowLeft, Database, TrendingUp, Edit, Trash2, Save, X, CheckCircle, Search } from 'lucide-react';
import { collection, getDocs, query, orderBy, updateDoc, deleteDoc, doc } from 'firebase/firestore';
import { calculateUnitPrice, formatUnitPrice } from './utils/priceCalculations';
import StoreSelector from './StoreSelector';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 圖表組件
const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, productName }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp).sort((a, b) => a.timestamp - b.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間無足夠變化可繪圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <TrendingUp className="mr-1 text-gray-500" size={16} />
                單價走勢 - {productName}
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke="#4F46E5" strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === validRecords.length - 1 ? '#10B981' : '#4F46E5'} title={`${record.displayPrice.toFixed(2)} at ${record.timestamp.toLocaleDateString()}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>{new Date(minTimestamp).toLocaleDateString()}</span>
                <span>{new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

// Fuzzy search function
function fuzzyMatch(pattern, text) {
    const pattern_lower = pattern.toLowerCase();
    const text_lower = text.toLowerCase();
    let patternIdx = 0;
    let textIdx = 0;
    let score = 0;
    let consecutive = 0;
    let firstMatchIndex = -1;

    // Iterate through text to find pattern characters
    while (patternIdx < pattern_lower.length && textIdx < text_lower.length) {
        if (pattern_lower[patternIdx] === text_lower[textIdx]) {
            if (firstMatchIndex === -1) {
                firstMatchIndex = textIdx;
            }
            score += 1;
            // Add bonus for consecutive matches
            if (consecutive > 0) {
                score += consecutive;
            }
            consecutive++;
            patternIdx++;
        } else {
            consecutive = 0;
        }
        textIdx++;
    }

    // If the whole pattern was found
    if (patternIdx === pattern_lower.length) {
        // Add bonus for being a prefix
        if (firstMatchIndex === 0) {
            score += 5;
        }
        // Add bonus for tightness of the match
        const matchDensity = pattern.length / (textIdx - firstMatchIndex);
        score *= (1 + matchDensity);

        return score;
    }

    return 0;
}

// 可滑動的記錄項目
function SwipeableRecord({ children, onEdit, onDelete }) {
    const [translateX, setTranslateX] = useState(0);
    const touchStartX = useRef(0);
    const itemRef = useRef(null);
    const buttonsRef = useRef(null);

    const handleTouchStart = (e) => {
        touchStartX.current = e.touches[0].clientX;
    };

    const handleTouchMove = (e) => {
        const touchCurrentX = e.touches[0].clientX;
        const diff = touchCurrentX - touchStartX.current;
        if (diff < 0) { // 只允許向左滑動
            setTranslateX(Math.max(diff, -160)); // -160 是按鈕寬度的總和
        }
    };

    const handleTouchEnd = () => {
        if (translateX < -80) {
            setTranslateX(-160);
        } else {
            setTranslateX(0);
        }
    };

    useEffect(() => {
        const handleGlobalClick = (e) => {
            if (buttonsRef.current && !buttonsRef.current.contains(e.target)) {
                setTranslateX(0);
            }
        };

        if (translateX !== 0) {
            document.addEventListener('click', handleGlobalClick, true);
        }

        return () => {
            document.removeEventListener('click', handleGlobalClick, true);
        };
    }, [translateX]);

    const handleEdit = () => {
        onEdit();
        setTranslateX(0);
    };

    const handleDelete = () => {
        onDelete();
        setTranslateX(0);
    };

    return (
        <div className="relative overflow-hidden">
            <div ref={buttonsRef} className="absolute top-0 right-0 h-full flex items-center">
                <button onClick={handleEdit} className="bg-blue-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Edit size={20} />
                    <span>編輯</span>
                </button>
                <button onClick={handleDelete} className="bg-red-500 text-white h-full w-20 flex flex-col items-center justify-center">
                    <Trash2 size={20} />
                    <span>刪除</span>
                </button>
            </div>
            <div
                ref={itemRef}
                className="transition-transform duration-300 ease-in-out"
                style={{ transform: `translateX(${translateX}px)` }}
                onTouchStart={handleTouchStart}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleTouchEnd}
            >
                {children}
            </div>
        </div>
    );
}


// 產品記錄組件
function ProductRecord({ product, records, theme, onEdit, onDelete }) {
    const formattedRecords = records.map(r => ({ ...r, timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp) })).sort((a, b) => b.timestamp - a.timestamp);
    
    const latestRecord = formattedRecords[0];
    if (!latestRecord) return null; // 如果沒有記錄，則不渲染此組件

    const validUnitPrices = formattedRecords.map(r => r.unitPrice).filter(p => !isNaN(p) && p !== undefined && p !== null);
    const lowestUnitPrice = validUnitPrices.length > 0 ? Math.min(...validUnitPrices) : 0;
    const highestUnitPrice = validUnitPrices.length > 0 ? Math.max(...validUnitPrices) : 0;
    const avgUnitPrice = validUnitPrices.length > 0 ? validUnitPrices.reduce((sum, p) => sum + p, 0) / validUnitPrices.length : 0;

    return (
        <div className={`p-4 rounded-xl shadow-lg bg-white border-t-4 ${theme.border} mb-6`}>
            <div className="flex justify-between items-start">
                <div>
                    <h3 className="text-lg font-bold text-gray-800">{product.productName}</h3>
                    <p className="text-sm text-gray-600">條碼: {product.barcodeData}</p>
                    <p className="text-xs text-gray-500">ID: {product.numericalID}</p>
                </div>
                <div className="text-right">
                    {/* 顯示原價和特價信息 */}
                    {latestRecord.specialPrice ? (
                        <div>
                            {latestRecord.originalPrice && (
                                <p className="text-lg text-gray-500 line-through">${latestRecord.originalPrice.toFixed(2)}</p>
                            )}
                            <p className="text-2xl font-bold text-indigo-600">${latestRecord.specialPrice.toFixed(2)}</p>
                            <p className="text-xs text-gray-500">@{formatUnitPrice(latestRecord.unitPrice)}</p>
                        </div>
                    ) : (
                        <p className="text-2xl font-bold text-indigo-600">{formatUnitPrice(latestRecord.unitPrice) === '--' ? (isNaN(latestRecord.price) ? 'N/A' : `$${(latestRecord.price || 0).toFixed(2)}`) : `$${(latestRecord.price || 0).toFixed(2)} @${formatUnitPrice(latestRecord.unitPrice)}`}</p>
                    )}
                    <p className="text-xs text-gray-500">{latestRecord.timestamp.toLocaleDateString()}</p>
                    {/* 顯示數量和單位 */}
                    {latestRecord.quantity && latestRecord.unitType && (
                        <p className="text-xs text-gray-500">數量: {latestRecord.quantity} {latestRecord.unitType}</p>
                    )}
                </div>
            </div>

            <div className="grid grid-cols-3 gap-2 my-3 text-center">
                <div className="bg-green-50 p-2 rounded"><p className="text-xs text-gray-500">最低單價</p><p className="font-bold text-green-600">{isNaN(lowestUnitPrice) ? 'N/A' : `${lowestUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-blue-50 p-2 rounded"><p className="text-xs text-gray-500">平均單價</p><p className="font-bold text-blue-600">{isNaN(avgUnitPrice) ? 'N/A' : `${avgUnitPrice.toFixed(2)}`}</p></div>
                <div className="bg-red-50 p-2 rounded"><p className="text-xs text-gray-500">最高單價</p><p className="font-bold text-red-600">{isNaN(highestUnitPrice) ? 'N/A' : `${highestUnitPrice.toFixed(2)}`}</p></div>
            </div>

            <div className="mb-4"><PriceTrendChart records={formattedRecords} productName={product.productName} /></div>

            <div className="mt-4">
                <h4 className="font-semibold text-gray-700 mb-2">價格記錄詳情</h4>
                <div className="space-y-2 max-h-40 overflow-y-auto">
                    {formattedRecords.map((record, index) => (
                        <SwipeableRecord
                            key={index}
                            onEdit={() => onEdit(record)}
                            onDelete={() => onDelete(record)}
                        >
                            <div className="flex justify-between items-center p-2 bg-gray-50 rounded">
                                <div>
                                    {/* 顯示原價和特價信息 */}
                                    {record.specialPrice ? (
                                        <p className="font-medium">
                                            {record.originalPrice && (
                                                <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                            )}
                                            <span className="text-red-600 ml-1">${record.specialPrice.toFixed(2)}</span>
                                            <span className="text-gray-500 ml-1">@{formatUnitPrice(record.unitPrice)}</span>
                                        </p>
                                    ) : (
                                        <p className="font-medium">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</p>
                                    )}
                                    {record.discountDetails && <p className="text-xs text-indigo-600">{record.discountDetails}</p>}
                                    {/* 顯示數量和單位 */}
                                    {record.quantity && record.unitType && (
                                        <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType}</p>
                                    )}
                                </div>
                                <div className="text-right">
                                    <p className="text-xs text-gray-500">{record.storeName || '未標註'}</p>
                                    <p className="text-xs text-gray-500">{record.timestamp.toLocaleDateString()}</p>
                                </div>
                            </div>
                        </SwipeableRecord>
                    ))}
                </div>
            </div>
        </div>
    );
}

// 主組件
function AllRecordsPage({ theme, onBack, db, userId, isAuthReady }) {
    const [allProducts, setAllProducts] = useState([]);
    const [allRecords, setAllRecords] = useState({});
    const [loading, setLoading] = useState(true);
    const [sortOption, setSortOption] = useState('latest'); // latest, name, price
    const [editingRecord, setEditingRecord] = useState(null);
    const [deletingRecord, setDeletingRecord] = useState(null);
    const [successMessage, setSuccessMessage] = useState('');
    const scrollPositionRef = useRef(0); // For scroll restoration
    const [isAfterDelete, setIsAfterDelete] = useState(false); // Signal for scroll restoration
    const [searchQuery, setSearchQuery] = useState('');
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const searchInputRef = useRef(null);
    
    // Edit mode states
    const [isEditMode, setIsEditMode] = useState(false);
    const [selectedItems, setSelectedItems] = useState(new Set());
    const [localProducts, setLocalProducts] = useState([]);
    const [localRecords, setLocalRecords] = useState({});
    // 新增狀態：批量刪除確認對話框
    const [isBulkDeleteConfirmationOpen, setIsBulkDeleteConfirmationOpen] = useState(false);
    // 新增狀態：原始數據快照和衝突解決
    const [originalDataSnapshot, setOriginalDataSnapshot] = useState(null);
    const [isConflictDialogOpen, setIsConflictDialogOpen] = useState(false);

    const fetchData = useCallback(async () => {
        if (!db) return;
        setLoading(true);
        try {
            // 1. Fetch all products
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const productsArray = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 2. Fetch all records
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const recordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // 3. Group records by product ID
            const recordsByProduct = {};
            recordsArray.forEach(record => {
                if (!recordsByProduct[record.numericalID]) {
                    recordsByProduct[record.numericalID] = [];
                }
                recordsByProduct[record.numericalID].push(record);
            });

            setAllProducts(productsArray);
            setAllRecords(recordsByProduct);

        } catch (error) {
            console.error('讀取 Firestore 數據失敗:', error);
            const userMessage = handleFirestoreSaveError(error, "讀取產品數據");
            showUserFriendlyError(userMessage);
        } finally {
            setLoading(false);
        }
    }, [db]);

    useEffect(() => {
        // 只有在 Firebase 已準備好時才執行查詢
        if (!isAuthReady || !userId) {
            // 如果 Firebase 尚未準備好，不應該顯示加載狀態
            // 讓用戶知道需要等待 Firebase 初始化
            return;
        }
        
        // Firebase 已準備好且有 userId，執行數據獲取
        fetchData();
    }, [fetchData, isAuthReady, userId]);

    useEffect(() => {
        if (isSearchOpen && searchInputRef.current) {
            setTimeout(() => searchInputRef.current.focus(), 100); // Shorter delay for responsiveness
        }
    }, [isSearchOpen]);

    useLayoutEffect(() => {
        if (isAfterDelete && !loading) {
            // Use requestAnimationFrame to ensure scroll happens after browser paints
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollPositionRef.current);
                setIsAfterDelete(false); // Reset the signal after scrolling
            });
        }
    }, [loading, isAfterDelete]);

    const filteredProducts = useMemo(() => {
        // Use local data in edit mode, otherwise use Firebase data
        const products = isEditMode ? localProducts : allProducts;
        const records = isEditMode ? localRecords : allRecords;

        if (searchQuery.trim() === '') {
            // No search query, just sort the products
            return [...products].sort((a, b) => {
                const recordsA = records[a.numericalID] || [];
                const recordsB = records[b.numericalID] || [];
                
                if (sortOption === 'name') {
                    return a.productName.localeCompare(b.productName);
                }
                
                const latestRecordA = recordsA[0];
                const latestRecordB = recordsB[0];

                if (sortOption === 'price') {
                    const priceA = latestRecordA?.price || -1;
                    const priceB = latestRecordB?.price || -1;
                    return priceB - priceA;
                }

                // Default to 'latest'
                const timeA = latestRecordA?.timestamp?.toDate ? latestRecordA.timestamp.toDate().getTime() : 0;
                const timeB = latestRecordB?.timestamp?.toDate ? latestRecordB.timestamp.toDate().getTime() : 0;
                return timeB - timeA;
            });
        }

        // Fuzzy search logic
        const scoredProducts = products
            .map(product => ({
                product,
                score: fuzzyMatch(searchQuery, product.productName)
            }))
            .filter(item => item.score > 0)
            .sort((a, b) => b.score - a.score);
        
        return scoredProducts.map(item => item.product);

    }, [allProducts, allRecords, sortOption, searchQuery, isEditMode, localProducts, localRecords]);

    const showSuccessMessage = (message) => {
        setSuccessMessage(message);
        setTimeout(() => {
            setSuccessMessage('');
        }, 2000);
    };

    const handleEdit = (record) => {
        setEditingRecord(record);
    };

    const handleDelete = (record) => {
        scrollPositionRef.current = window.scrollY; // Save scroll position
        setDeletingRecord(record);
    };

    // New function to handle checkbox selection
    const handleItemSelect = (productId) => {
        setSelectedItems(prev => {
            const newSet = new Set(prev);
            if (newSet.has(productId)) {
                newSet.delete(productId);
            } else {
                newSet.add(productId);
            }
            return newSet;
        });
    };

    // 修改批量刪除功能以使用確認對話框
    const handleBulkDeleteClick = () => {
        if (selectedItems.size === 0) return;
        setIsBulkDeleteConfirmationOpen(true);
    };

    // New function to delete selected items
    const deleteSelectedItems = async () => {
        if (selectedItems.size === 0) return;
        
        try {
            // Update local state
            setLocalProducts(prev => prev.filter(product => !selectedItems.has(product.numericalID)));
            setLocalRecords(prev => {
                const newRecords = {...prev};
                selectedItems.forEach(productId => {
                    delete newRecords[productId];
                });
                return newRecords;
            });
            
            // Clear selection
            setSelectedItems(new Set());
            setIsBulkDeleteConfirmationOpen(false);
        } catch (error) {
            console.error("Error deleting selected items:", error);
            const userMessage = handleFirestoreSaveError(error, "批量刪除產品");
            showUserFriendlyError(userMessage);
        }
    };

    // 新增函數：檢查衝突並退出編輯模式
    const checkForConflictsAndExit = async () => {
        if (!db || !originalDataSnapshot) return;
        
        try {
            // 獲取當前 Firebase 數據
            const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
            const productsSnap = await getDocs(productsQuery);
            const currentProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
            const recordsSnap = await getDocs(recordsQuery);
            const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 將記錄按產品 ID 分組
            const currentRecords = {};
            currentRecordsArray.forEach(record => {
                if (!currentRecords[record.numericalID]) {
                    currentRecords[record.numericalID] = [];
                }
                currentRecords[record.numericalID].push(record);
            });
            
            // 比較當前數據與原始快照
            const hasConflicts = checkForDataConflicts(originalDataSnapshot, {products: currentProducts, records: currentRecords});
            
            if (hasConflicts) {
                // 如果有衝突，顯示衝突解決對話框
                setIsConflictDialogOpen(true);
            } else {
                // 如果沒有衝突，直接退出編輯模式
                await exitEditMode(currentProducts, currentRecords);
            }
        } catch (error) {
            console.error("檢查數據衝突時出錯:", error);
            const userMessage = handleFirestoreSaveError(error, "檢查數據衝突");
            showUserFriendlyError(userMessage);
            // 出錯時仍然退出編輯模式
            await exitEditMode();
        }
    };
    
    // 新增函數：檢查數據衝突
    const checkForDataConflicts = (original, current) => {
        // 比較產品數量
        if (original.products.length !== current.products.length) {
            return true;
        }
        
        // 比較記錄數量
        const originalRecordCount = Object.values(original.records).reduce((count, records) => count + records.length, 0);
        const currentRecordCount = Object.values(current.records).reduce((count, records) => count + records.length, 0);
        
        if (originalRecordCount !== currentRecordCount) {
            return true;
        }
        
        // 更詳細的比較可以在此處添加
        // 為了簡化，我們只檢查數量變化
        
        return false;
    };
    
    // 修改 exitEditMode 函數以接受當前數據
    const exitEditMode = async (currentProducts = null, currentRecords = null) => {
        if (!db) return;
        
        try {
            // 如果沒有提供當前數據，則獲取最新數據
            let latestProducts = currentProducts;
            let latestRecords = currentRecords;
            
            if (!latestProducts || !latestRecords) {
                const productsQuery = query(collection(db, "products"), orderBy("createdAt", "desc"));
                const productsSnap = await getDocs(productsQuery);
                latestProducts = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const recordsQuery = query(collection(db, "priceRecords"), orderBy("timestamp", "desc"));
                const recordsSnap = await getDocs(recordsQuery);
                const currentRecordsArray = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 將記錄按產品 ID 分組
                latestRecords = {};
                currentRecordsArray.forEach(record => {
                    if (!latestRecords[record.numericalID]) {
                        latestRecords[record.numericalID] = [];
                    }
                    latestRecords[record.numericalID].push(record);
                });
            }
            
            // 計算需要從 Firebase 刪除的產品
            const productsToDelete = latestProducts.filter(product => 
                !localProducts.some(localProduct => localProduct.numericalID === product.numericalID)
            );
            
            // 刪除 Firebase 中的產品及其記錄
            for (const product of productsToDelete) {
                // 刪除所有記錄
                const productRecords = latestRecords[product.numericalID] || [];
                for (const record of productRecords) {
                    const recordRef = doc(db, "priceRecords", record.id);
                    await deleteDoc(recordRef);
                }
            }
            
            // 計算需要從 Firebase 刪除的記錄（編輯模式下刪除的記錄）
            const recordsToDelete = [];
            for (const [productId, records] of Object.entries(latestRecords)) {
                const localRecordsForProduct = localRecords[productId] || [];
                // 找出在原始記錄中存在但在本地記錄中不存在的記錄
                const deletedRecords = records.filter(record => 
                    !localRecordsForProduct.some(localRecord => localRecord.id === record.id)
                );
                recordsToDelete.push(...deletedRecords);
            }
            
            // 刪除 Firebase 中的記錄
            for (const record of recordsToDelete) {
                const recordRef = doc(db, "priceRecords", record.id);
                await deleteDoc(recordRef);
            }
            
            // 重新從 Firebase 獲取數據
            await fetchData();
            setIsEditMode(false);
            setSelectedItems(new Set());
            setOriginalDataSnapshot(null);

        } catch (error) {
            console.error("Error syncing with Firebase:", error);
            const userMessage = handleFirestoreSaveError(error, "同步編輯數據");
            showUserFriendlyError(userMessage);
        }
    };

    const handleSaveEdit = async (updatedRecord) => {
        if (!db) return;
        try {
            const recordRef = doc(db, "priceRecords", updatedRecord.id);
            // 更新所有字段，不僅僅是價格和折扣詳情
            await updateDoc(recordRef, {
                price: updatedRecord.price,
                discountDetails: updatedRecord.discountDetails,
                productName: updatedRecord.productName,
                storeName: updatedRecord.storeName,
                quantity: updatedRecord.quantity,
                unitType: updatedRecord.unitType,
                unitPrice: updatedRecord.unitPrice,
                originalPrice: updatedRecord.originalPrice,
                specialPrice: updatedRecord.specialPrice
            });
            
            // 在編輯模式下，更新本地狀態而不是重新獲取所有數據
            if (isEditMode) {
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    
                    // 確保更新的記錄所屬的產品在 localRecords 中存在
                    if (!newRecords[updatedRecord.numericalID]) {
                        newRecords[updatedRecord.numericalID] = [];
                    }
                    
                    // 更新記錄
                    Object.keys(newRecords).forEach(productId => {
                        if (newRecords[productId]) {
                            newRecords[productId] = newRecords[productId].map(record => 
                                record.id === updatedRecord.id ? updatedRecord : record
                            ).filter(record => record !== undefined); // 過濾掉可能的 undefined 值
                        }
                    });
                    
                    // 確保當前更新的記錄存在於其對應的產品記錄中
                    if (!newRecords[updatedRecord.numericalID].some(record => record.id === updatedRecord.id)) {
                        newRecords[updatedRecord.numericalID].push(updatedRecord);
                    }
                    
                    return newRecords;
                });
                
                // 同時更新本地產品列表中的產品名稱
                setLocalProducts(prev => 
                    prev.map(product => 
                        product.numericalID === updatedRecord.numericalID 
                            ? {...product, productName: updatedRecord.productName} 
                            : product
                    )
                );
            } else {
                await fetchData(); // 非編輯模式下重新獲取數據以更新UI
            }
            
            showSuccessMessage('記錄已成功更新');
        } catch (error) {
            console.error("更新記錄失敗:", error);
            const userMessage = handleFirestoreSaveError(error, "更新價格記錄");
            showUserFriendlyError(userMessage);
        }
        setEditingRecord(null);
    };

    // 新增函數：處理衝突解決
    const handleConflictResolution = async (resolutionType) => {
        setIsConflictDialogOpen(false);
        
        switch (resolutionType) {
            case 'local':
                // 保留本地更改，直接退出編輯模式
                await exitEditMode();
                break;
            case 'remote':
                // 保留遠程數據，重新獲取最新數據並退出
                await fetchData();
                setIsEditMode(false);
                setSelectedItems(new Set());
                setOriginalDataSnapshot(null);

                break;
            case 'merge':
                // 手動合併，重新獲取數據並保持編輯模式
                await fetchData();
                setLocalProducts([...allProducts]);
                setLocalRecords({...allRecords});
                // 保持編輯模式開啟，讓用戶繼續編輯
                setOriginalDataSnapshot({
                    products: [...allProducts],
                    records: {...allRecords},
                    timestamp: Date.now()
                });

                break;
            default:
                // 默認情況下直接退出編輯模式
                await exitEditMode();
        }
    };

    const confirmDelete = async () => {
        if (!db || !deletingRecord) return;
        
        // 在編輯模式下，我們只需要更新本地狀態，不需要重新整理畫面
        if (isEditMode) {
            try {
                // 更新本地狀態而不是調用 Firebase
                setLocalRecords(prev => {
                    const newRecords = {...prev};
                    if (newRecords[deletingRecord.numericalID]) {
                        newRecords[deletingRecord.numericalID] = newRecords[deletingRecord.numericalID].filter(
                            record => record.id !== deletingRecord.id
                        );
                    }
                    return newRecords;
                });
                
                // 顯示成功消息
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            } finally {
                setDeletingRecord(null);
            }
        } else {
            // 非編輯模式下保持原有行為
            setIsAfterDelete(true); // Signal that the next data fetch is after a delete
            try {
                const recordRef = doc(db, "priceRecords", deletingRecord.id);
                await deleteDoc(recordRef);
                await fetchData(); // 重新獲取數據以更新UI
                showSuccessMessage('記錄已成功刪除');
            } catch (error) {
                console.error("刪除記錄失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "刪除價格記錄");
                showUserFriendlyError(userMessage);
            }
            setDeletingRecord(null);
        }
    };

    const handleSearchToggle = () => {
        if (isSearchOpen) {
            setSearchQuery('');
        }
        setIsSearchOpen(!isSearchOpen);
    };

    if (loading) {
        return (
            <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
                <div className="max-w-4xl mx-auto">
                    <div className="flex items-center mb-6">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800">所有記錄</h1>
                    </div>
                    <div className="text-center py-10">
                        {!isAuthReady ? (
                            <p>正在初始化雲端服務，請稍候...</p>
                        ) : !userId ? (
                            <p>正在獲取用戶信息，請稍候...</p>
                        ) : (
                            <p>正在從雲端加載數據...</p>
                        )}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen p-4 sm:p-8 bg-gray-100">
            <div className="max-w-4xl mx-auto pb-28"> {/* Added pb-28 for floating button */}
                <SuccessMessage message={successMessage} />
                <div className="flex flex-col sm:flex-row sm:items-center justify-between mb-6">
                    <div className="flex items-center mb-4 sm:mb-0">
                        <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4"><ArrowLeft className="mr-1" size={20} />返回</button>
                        <h1 className="text-2xl font-bold text-gray-800 flex items-center"><Database className="mr-2" />所有記錄</h1>
                    </div>
                    <div className="flex items-center">
                        <label className="mr-2 text-gray-700">排序:</label>
                        <select value={sortOption} onChange={(e) => setSortOption(e.target.value)} className="border border-gray-300 rounded p-2 mr-2">
                            <option value="latest">最新記錄</option>
                            <option value="name">產品名稱</option>
                            <option value="price">最新價格</option>
                        </select>
                        <button 
                            onClick={() => {
                                if (!isEditMode) {
                                    // Enter edit mode - copy current data to local state
                                    setLocalProducts([...allProducts]);
                                    setLocalRecords({...allRecords});
                                    // 保存原始數據快照和時間戳
                                    setOriginalDataSnapshot({
                                        products: [...allProducts],
                                        records: {...allRecords},
                                        timestamp: Date.now()
                                    });
                                } else {
                                    // Exit edit mode - 檢查數據版本衝突
                                    checkForConflictsAndExit();
                                }
                                setIsEditMode(!isEditMode);
                                setSelectedItems(new Set());
                            }}
                            className={`px-3 py-2 rounded text-white text-sm ${
                                isEditMode ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'
                            }`}
                        >
                            {isEditMode ? '退出編輯模式' : '編輯模式'}
                        </button>
                    </div>
                </div>

                {/* Floating Delete Button - 修改為固定位置 */}
                {isEditMode && selectedItems.size > 0 && (
                    <div className="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-4 shadow-lg z-50 flex items-center"
                         style={{bottom: '6rem'}}>
                        <button 
                            onClick={handleBulkDeleteClick}
                            className="flex items-center"
                        >
                            <Trash2 size={20} className="mr-2" />
                            刪除選取項目 ({selectedItems.size})
                        </button>
                    </div>
                )}

                {/* Floating Exit Edit Mode Button - 修改為固定位置 */}
                {isEditMode && (
                    <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white rounded-full p-4 shadow-lg z-50">
                        <button 
                            onClick={checkForConflictsAndExit}
                            className="flex items-center"
                        >
                            <X size={20} className="mr-2" />
                            退出編輯模式
                        </button>
                    </div>
                )}

                {filteredProducts.length === 0 ? (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <Database size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">{searchQuery ? '找不到結果' : '暫無記錄'}</h3>
                        <p className="text-gray-500">{searchQuery ? `找不到符合 "${searchQuery}" 的產品` : '還沒有任何產品和價格記錄'}</p>
                    </div>
                ) : (
                    <div>
                        <div className="mb-4 p-4 bg-white rounded-lg shadow">
                            <div className="flex justify-between">
                                <p className="text-gray-700">總共 <span className="font-bold">{filteredProducts.length}</span> 個產品</p>
                                <p className="text-gray-700">總共 <span className="font-bold">{Object.values(allRecords).flat().length}</span> 條記錄</p>
                            </div>
                        </div>
                        {filteredProducts.map(product => {
                            // 修復：確保 records 始終有默認值
                            const records = isEditMode ? (localRecords[product.numericalID] || []) : (allRecords[product.numericalID] || []);
                            // 修改：即使沒有記錄也顯示產品卡片，但只在編輯模式下
                            if (records.length === 0 && !isEditMode) return null;
                            return (
                                // 修改：為選中的項目添加增強的視覺反饋
                                <div key={product.numericalID} className={`relative transition-all duration-200 ${isEditMode && selectedItems.has(product.numericalID) ? 'bg-blue-50 border-2 border-blue-500 rounded-lg' : ''}`}>
                                    {isEditMode && (
                                        <div className="absolute top-4 left-4 z-10">
                                            <input
                                                type="checkbox"
                                                checked={selectedItems.has(product.numericalID)}
                                                onChange={() => handleItemSelect(product.numericalID)}
                                                className="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                                            />
                                        </div>
                                    )}
                                    <div className={isEditMode ? "pl-12" : ""}>
                                        <ProductRecord 
                                            product={product} 
                                            records={records} 
                                            theme={theme} 
                                            onEdit={handleEdit} 
                                            onDelete={handleDelete} 
                                        />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}

                {editingRecord && (
                    <EditModal
                        record={editingRecord}
                        onClose={() => setEditingRecord(null)}
                        onSave={handleSaveEdit}
                    />
                )}

                {deletingRecord && (
                    <DeleteConfirmation
                        record={deletingRecord}
                        onClose={() => setDeletingRecord(null)}
                        onConfirm={confirmDelete}
                    />
                )}

                {/* 新增批量刪除確認對話框 */}
                {isBulkDeleteConfirmationOpen && (
                    <BulkDeleteConfirmation
                        count={selectedItems.size}
                        onClose={() => setIsBulkDeleteConfirmationOpen(false)}
                        onConfirm={deleteSelectedItems}
                    />
                )}

                {/* 新增衝突解決對話框 */}
                {isConflictDialogOpen && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                            <h2 className="text-xl font-bold mb-4">檢測到數據衝突</h2>
                            <p className="mb-4">在您編輯期間，其他用戶修改了部分數據。請選擇如何解決衝突：</p>
                            
                            <div className="mb-6 p-4 bg-yellow-50 rounded-lg">
                                <h3 className="font-semibold text-yellow-800 mb-2">衝突詳情：</h3>
                                <ul className="list-disc pl-5 text-sm text-yellow-700">
                                    <li>數據可能已被人修改</li>
                                    <li>您的更改可能與其他用戶的更改衝突</li>
                                </ul>
                            </div>
                            
                            <div className="space-y-3">
                                <button 
                                    onClick={() => handleConflictResolution('local')}
                                    className="w-full p-3 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                                >
                                    保留我的更改
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('remote')}
                                    className="w-full p-3 bg-green-500 text-white rounded-md hover:bg-green-600"
                                >
                                    保留最新數據
                                </button>
                                <button 
                                    onClick={() => handleConflictResolution('merge')}
                                    className="w-full p-3 bg-purple-500 text-white rounded-md hover:bg-purple-600"
                                >
                                    手動合併（推薦）
                                </button>
                            </div>
                            
                            <div className="mt-6 flex justify-end">
                                <button 
                                    onClick={() => setIsConflictDialogOpen(false)}
                                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                                >
                                    取消
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- START: Revamped Search Component --- */}
                <div className="fixed top-6 right-6 z-30">
                    <div 
                        className={`flex items-center justify-end bg-white rounded-full shadow-xl transition-all duration-300 ease-in-out overflow-hidden ${isSearchOpen ? 'w-80' : 'w-16 h-16'}`}
                    >
                        <Search className={`absolute left-5 top-1/2 -translate-y-1/2 text-gray-400 transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`} size={22} />
                        <input
                            ref={searchInputRef}
                            type="text"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="輸入品名進行模糊搜尋..."
                            className={`w-full h-16 pl-14 pr-20 bg-transparent border-none rounded-full outline-none text-lg transition-opacity duration-200 ${isSearchOpen ? 'opacity-100' : 'opacity-0'}`}
                            style={{pointerEvents: isSearchOpen ? 'auto' : 'none'}}
                        />
                        <button
                            onClick={handleSearchToggle}
                            className="absolute right-0 top-0 w-16 h-16 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 flex items-center justify-center"
                            aria-label={isSearchOpen ? "關閉搜尋" : "開啟搜尋"}
                        >
                            {isSearchOpen ? <X size={28} /> : <Search size={28} />}
                        </button>
                    </div>
                </div>
                {/* --- END: Revamped Search Component --- */}
            </div>
        </div>
    );
}

function EditModal({ record, onClose, onSave }) {
    const [price, setPrice] = useState(record.price);
    const [quantity, setQuantity] = useState(record.quantity || '');
    const [unitType, setUnitType] = useState(record.unitType || 'pcs');
    const [discount, setDiscount] = useState(record.discountDetails || '');
    const [originalPrice, setOriginalPrice] = useState(record.originalPrice || '');
    const [specialPrice, setSpecialPrice] = useState(record.specialPrice || '');
    const [productName, setProductName] = useState(record.productName || '');
    const [storeName, setStoreName] = useState(record.storeName || '');
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);

    const handleSave = () => {
        const newUnitPrice = calculateUnitPrice(price, quantity, unitType);
        if (newUnitPrice === null) {
            alert("請輸入有效的價格和數量。");
            return;
        }
        onSave({ 
            ...record, 
            price: parseFloat(price),
            quantity: parseFloat(quantity),
            unitType: unitType,
            unitPrice: newUnitPrice,
            discountDetails: discount,
            originalPrice: originalPrice ? parseFloat(originalPrice) : null,
            specialPrice: specialPrice ? parseFloat(specialPrice) : null,
            productName: productName,
            storeName: storeName
        });
    };

    const currentUnitPrice = calculateUnitPrice(price, quantity, unitType);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 overflow-hidden">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                <h2 className="text-xl font-bold mb-4">編輯記錄</h2>
                <div className="space-y-3">
                    {/* 產品名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">產品名稱</label>
                        <input
                            type="text"
                            value={productName}
                            onChange={(e) => setProductName(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 商店名稱輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">商店名稱</label>
                        <div className="mt-1 flex">
                            <input
                                type="text"
                                value={storeName}
                                onChange={(e) => setStoreName(e.target.value)}
                                className="block flex-grow border border-gray-300 rounded-l-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                placeholder="點擊選擇商店或手動輸入"
                                readOnly
                            />
                            <button 
                                onClick={() => setIsStoreSelectorOpen(true)}
                                className="bg-indigo-600 text-white px-4 py-2 rounded-r-md hover:bg-indigo-700"
                            >
                                選擇
                            </button>
                        </div>
                    </div>
                    
                    {/* 原價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">原價 ($)</label>
                        <input
                            type="number"
                            value={originalPrice}
                            onChange={(e) => setOriginalPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 特價輸入 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">特價 ($)</label>
                        <input
                            type="number"
                            value={specialPrice}
                            onChange={(e) => setSpecialPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    {/* 總價輸入（實際支付價格） */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700">總價 ($)</label>
                        <input
                            type="number"
                            value={price}
                            onChange={(e) => setPrice(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    
                    <div>
                        <label className="block text-sm font-medium text-gray-700">數量</label>
                        <input
                            type="number"
                            value={quantity}
                            onChange={(e) => setQuantity(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單位</label>
                        <select
                            value={unitType}
                            onChange={(e) => setUnitType(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        >
                            <option value="ml">ml (毫升)</option>
                            <option value="g">g (克)</option>
                            <option value="pcs">pcs (個/包/支/條)</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">單價 (自動計算)</label>
                        <input
                            type="text"
                            value={currentUnitPrice === null ? 'N/A' : currentUnitPrice.toFixed(2)}
                            readOnly
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-gray-100"
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">折扣詳情</label>
                        <input
                            type="text"
                            value={discount}
                            onChange={(e) => setDiscount(e.target.value)}
                            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                </div>
                <div className="mt-4 flex justify-between">
                    <button onClick={onClose} className="flex-1 mr-2 items-center bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 flex justify-center">
                        <X size={18} className="mr-1" />
                        取消
                    </button>
                    <button onClick={handleSave} className="flex-1 ml-2 items-center bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 flex justify-center">
                        <Save size={18} className="mr-1" />
                        保存
                    </button>
                </div>
            </div>
            
            {isStoreSelectorOpen && (
                <StoreSelector 
                    onSelect={(selectedStore) => {
                        setStoreName(selectedStore);
                        setIsStoreSelectorOpen(false);
                    }}
                    onClose={() => setIsStoreSelectorOpen(false)}
                    theme={{ primary: 'bg-indigo-600', hover: 'hover:bg-indigo-700', text: 'text-indigo-600' }}
                />
            )}
        </div>
    );
}

function DeleteConfirmation({ record, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p>您確定要刪除這條價格為 ${record.price.toFixed(2)} 的記錄嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}

function SuccessMessage({ message }) {
    if (!message) return null;

    return (
        <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center z-50">
            <CheckCircle size={20} className="mr-2" />
            <span>{message}</span>
        </div>
    );
}



// 新增批量刪除確認對話框組件
function BulkDeleteConfirmation({ count, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認批量刪除</h2>
                <p>您確定要刪除選中的 {count} 個產品項目嗎？此操作無法復原。</p>
                <div className="mt-6 flex justify-end space-x-3">
                    <button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">取消</button>
                    <button onClick={onConfirm} className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">確認刪除</button>
                </div>
            </div>
        </div>
    );
}



export default AllRecordsPage;
</file>

<file path="App.css">
/* 應用基本樣式 */
.App {
  text-align: center;
  min-height: 100vh;
}

/* 自定義樣式可以在這裡添加 */
</file>

<file path="App.js">
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PaintBucket, DollarSign, Barcode, ClipboardCheck, X, Camera, Zap, FileText, RotateCcw, Database } from 'lucide-react';
import AllRecordsPage from './AllRecordsPage';
import StoreSelector from './StoreSelector';
import AIOcrCaptureModal from './components/AIOcrCaptureModal';
import { db } from './firebase-config.js'; // <-- 引入 Firebase
import { getAuth, signInAnonymously } from "firebase/auth";
import { doc, getDoc, setDoc, collection, query, where, getDocs, addDoc, orderBy, serverTimestamp } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import OcrQueuePage from './OcrQueuePage';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// ----------------------------------------------------------------------------
// 1. 核心設定與工具函數 (Core Setup & Utilities)
// ----------------------------------------------------------------------------

function djb2Hash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
}

// 以下函數已移至 src/components/AIOcrCaptureModal.js
// callGeminiApiWithRetry
// withExponentialBackoff


function generateProductId(barcode, productName, storeName) {
    if (barcode) {
        return djb2Hash(barcode).toString();
    } else {
        // Combine productName and storeName to create a unique ID for products without barcodes
        // This assumes productName + storeName is sufficiently unique for non-barcoded items
        return djb2Hash(`${productName}-${storeName}`).toString();
    }
}

// ----------------------------------------------------------------------------
// 2. UI 元件 (UI Components)
// ----------------------------------------------------------------------------

const CHART_WIDTH = 400;
const CHART_HEIGHT = 150;
const PADDING = 20;

function PriceTrendChart({ records, theme }) {
    const validRecords = records.map(r => ({
        ...r,
        timestamp: r.timestamp?.toDate ? r.timestamp.toDate() : new Date(r.timestamp),
        displayPrice: r.unitPrice !== undefined && r.unitPrice !== null ? r.unitPrice : r.price // Use unitPrice if available, else price
    })).filter(r => !isNaN(r.displayPrice) && r.timestamp);

    if (validRecords.length < 2) {
        return <p className="text-center text-sm text-gray-500">至少需要兩筆紀錄才能繪製趨勢圖。</p>;
    }

    const prices = validRecords.map(r => r.displayPrice);
    const minPrice = Math.min(...prices) * 0.95;
    const maxPrice = Math.max(...prices) * 1.05;
    const priceRange = maxPrice - minPrice;

    const timestamps = validRecords.map(r => r.timestamp.getTime());
    const minTimestamp = Math.min(...timestamps);
    const maxTimestamp = Math.max(...timestamps);
    const timeRange = maxTimestamp - minTimestamp;

    if (priceRange === 0 || timeRange === 0) {
        return <p className="text-center text-sm text-gray-500">價格或時間沒有足夠的變化來繪製趨勢圖。</p>;
    }

    const points = validRecords.map(record => {
        const xRatio = (record.timestamp.getTime() - minTimestamp) / timeRange;
        const x = PADDING + xRatio * (CHART_WIDTH - 2 * PADDING);
        const yRatio = (record.displayPrice - minPrice) / priceRange;
        const y = CHART_HEIGHT - PADDING - yRatio * (CHART_HEIGHT - 2 * PADDING);
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
            <h3 className="text-base font-medium text-gray-700 mb-2 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1 text-gray-500"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                單價走勢
            </h3>
            <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-auto" style={{maxWidth: `${CHART_WIDTH}px`}}>
                <line x1={PADDING} y1={PADDING} x2={PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <line x1={PADDING} y1={CHART_HEIGHT - PADDING} x2={CHART_WIDTH - PADDING} y2={CHART_HEIGHT - PADDING} stroke="#ddd" strokeWidth="1" />
                <text x={PADDING - 5} y={PADDING + 5} textAnchor="end" fontSize="10" fill="#666">${maxPrice.toFixed(2)}</text>
                <text x={PADDING - 5} y={CHART_HEIGHT - PADDING} textAnchor="end" fontSize="10" fill="#666">${minPrice.toFixed(2)}</text>
                <polyline fill="none" stroke={theme.color === 'red' ? '#EF4444' : '#4F46E5'} strokeWidth="2" points={points} />
                {validRecords.map((record, index) => {
                    const [x, y] = points.split(' ')[index].split(',').map(Number);
                    return <circle key={index} cx={x} cy={y} r="3" fill={index === 0 ? '#10B981' : theme.primary.split('-')[1]} title={`$${record.displayPrice.toFixed(2)}`} />;
                })}
            </svg>
            <div className="text-xs text-gray-500 mt-2 flex justify-between px-3">
                <span>最早: {new Date(minTimestamp).toLocaleDateString()}</span>
                <span>最新: {new Date(maxTimestamp).toLocaleDateString()}</span>
            </div>
        </div>
    );
}

function PriceHistoryDisplay({ historyRecords, theme }) {
    if (historyRecords.length === 0) {
        return <div className="text-center p-6 text-gray-500 bg-white rounded-xl shadow-md">尚無歷史價格紀錄。</div>;
    }

    const formattedRecords = historyRecords.map(record => ({
        ...record,
        timestamp: record.timestamp?.toDate ? record.timestamp.toDate() : new Date(record.timestamp),
        displayPrice: record.unitPrice !== undefined && record.unitPrice !== null ? record.unitPrice : record.price // Use unitPrice if available, else price
    }));

    return (
        <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${theme.border} mt-8`}>
            <h2 className={`text-xl font-semibold ${theme.text} mb-4`}>價格紀錄 ({formattedRecords.length} 筆)</h2>
            <div className="mb-6"><PriceTrendChart records={formattedRecords} theme={theme} /></div>
            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {formattedRecords.map((record, index) => (
                    <div key={index} className={`p-3 rounded-lg shadow-sm border border-gray-100 ${index === 0 ? theme.light : 'bg-white'}`}>
                        <div className="flex justify-between items-start font-bold">
                            {/* 顯示原價和特價信息 */}
                            {record.specialPrice ? (
                                <span className="text-[22px]">
                                    {record.originalPrice && (
                                        <span className="text-gray-500 line-through">${record.originalPrice.toFixed(2)}</span>
                                    )}
                                    <span className="text-red-600 ml-2">${record.specialPrice.toFixed(2)}</span>
                                    <span className="text-gray-500 ml-2">@{formatUnitPrice(record.unitPrice)}</span>
                                </span>
                            ) : (
                                <span className="text-[22px] text-red-600">{`$${(record.price || 0).toFixed(2)} @${formatUnitPrice(record.unitPrice)}`}</span>
                            )}
                            <span className="text-xs text-gray-500">{record.timestamp.toLocaleString()}</span>
                        </div>
                        <p className="text-sm text-gray-700 mt-1">商店: {record.storeName || '未標註'}</p>
                        {/* 顯示數量和單位資訊 */}
                        {record.quantity && record.unitType && <p className="text-xs text-gray-600">數量: {record.quantity} {record.unitType} (總價: ${(record.price || 0).toFixed(2)})</p>}
                        {record.discountDetails && <p className="text-xs text-indigo-600 italic">優惠: {record.discountDetails}</p>}
                        {index === 0 && <span className={`text-xs font-semibold px-2 py-0.5 rounded-full text-white ${theme.primary}`}>最新紀錄</span>}
                    </div>
                ))}
            </div>
        </div>
    );
}

const THEMES = {
    'Default (Indigo)': { primary: 'bg-indigo-600', light: 'bg-indigo-100', hover: 'hover:bg-indigo-700', border: 'border-indigo-600', text: 'text-indigo-600', color: 'indigo' },
    '海洋藍 (Ocean Blue)': { primary: 'bg-blue-600', light: 'bg-blue-100', hover: 'hover:bg-blue-700', border: 'border-blue-600', text: 'text-blue-600', color: 'blue' },
    '森林綠 (Forest Green)': { primary: 'bg-green-600', light: 'bg-green-100', hover: 'hover:bg-green-700', border: 'border-green-600', text: 'text-green-600', color: 'green' },
    '夕陽紅 (Sunset Red)': { primary: 'bg-red-600', light: 'bg-red-100', hover: 'hover:bg-red-700', border: 'border-red-600', text: 'text-red-600', color: 'red' },
    '活力橙 (Vibrant Orange)': { primary: 'bg-orange-600', light: 'bg-orange-100', hover: 'hover:bg-orange-700', border: 'border-orange-600', text: 'text-orange-600', color: 'orange' },
    '薰衣草紫 (Lavender)': { primary: 'bg-purple-600', light: 'bg-purple-100', hover: 'hover:bg-purple-700', border: 'border-purple-600', text: 'text-purple-600', color: 'purple' },
};
const DEFAULT_THEME_KEY = 'Default (Indigo)';

function ThemeSelector({ theme, saveTheme, onClose }) {
    const handleThemeChange = (themeKey) => { saveTheme(themeKey); };
    const handleReset = () => { saveTheme(DEFAULT_THEME_KEY); };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 transform transition-all">
                <h3 className={`text-xl font-bold ${theme.text} mb-4 border-b pb-2`}><PaintBucket className="inline-block w-5 h-5 mr-2" />介面配色選項</h3>
                <div className="grid grid-cols-2 gap-4 mb-6">
                    {Object.keys(THEMES).map((themeKey) => {
                        const themeData = THEMES[themeKey];
                        const isSelected = theme.color === themeData.color;
                        return (
                            <button key={themeKey} onClick={() => handleThemeChange(themeKey)}
                                className={`p-3 rounded-lg text-white font-medium shadow-md transition-all ${themeData.primary} ${themeData.hover} ${isSelected ? 'ring-4 ring-offset-2 ring-opacity-70 ring-gray-400' : ''}`}
                                style={{ transform: isSelected ? 'scale(1.05)' : 'scale(1)' }}>
                                {themeKey}
                            </button>
                        );
                    })}
                </div>
                <div className="flex justify-between items-center pt-4 border-t">
                    <button onClick={handleReset} className="flex items-center text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors">
                        <RotateCcw className="w-4 h-4 mr-1" />清除還原 (預設)
                    </button>
                    <button onClick={onClose} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg ${theme.primary} ${theme.hover} transition-all`}>關閉</button>
                </div>
            </div>
        </div>
    );
}

// AIOcrCaptureModal 組件已移至獨立檔案 src/components/AIOcrCaptureModal.js


// ----------------------------------------------------------------------------
// 3. Firebase 身份驗證與主題設定 (Firebase Auth & Theming)
// ----------------------------------------------------------------------------

function useFirebaseAuthentication() {
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        const auth = getAuth();
        signInAnonymously(auth)
            .then((userCredential) => {
                setUserId(userCredential.user.uid);
                setIsAuthReady(true);
            })
            .catch((error) => {
                console.error("Firebase 匿名登入失敗:", error);
            });
    }, []);

    const [currentTheme, setCurrentTheme] = useState(() => {
        const savedKey = localStorage.getItem('appTheme') || DEFAULT_THEME_KEY;
        return THEMES[savedKey] || THEMES[DEFAULT_THEME_KEY];
    });

    const saveUserTheme = useCallback((themeKey) => {
        localStorage.setItem('appTheme', themeKey);
        setCurrentTheme(THEMES[themeKey] || THEMES[DEFAULT_THEME_KEY]);
    }, []);

    return { userId, isAuthReady, currentTheme, saveUserTheme };
}

// ----------------------------------------------------------------------------
// 4. 結果提示框 (Result Toast)
// ----------------------------------------------------------------------------
function SaveResultToast({ result, onClose }) {
    useEffect(() => {
        let timer;
        if (result) {
            timer = setTimeout(onClose, 5000);
        }
        return () => clearTimeout(timer);
    }, [result, onClose]);

    if (!result) {
        return null;
    }

    const { status, message, productName } = result;

    const theme = {
        success: { bg: 'bg-green-500', text: 'text-white', icon: <ClipboardCheck className="w-6 h-6 mr-3" /> },
        warning: { bg: 'bg-yellow-400', text: 'text-gray-800', icon: <DollarSign className="w-6 h-6 mr-3" /> },
        error: { bg: 'bg-red-500', text: 'text-white', icon: <X className="w-6 h-6 mr-3" /> },
    };

    const currentTheme = theme[status];

    return (
        <div className={`fixed top-20 left-1/2 -translate-x-1/2 max-w-md w-full p-4 rounded-xl shadow-2xl z-[100] ${currentTheme.bg} ${currentTheme.text} transition-all duration-300 ease-in-out`}>
            <div className="flex items-center">
                {currentTheme.icon}
                <div className="flex-grow">
                    <p className="font-bold text-lg">{productName}</p>
                    <p className="text-sm">{message}</p>
                    <p className="text-sm font-semibold mt-1">
                        資料儲存: {status === 'error' ? '失敗' : '成功'} | 
                        比價結果: {status === 'success' ? '是最低價' : (status === 'warning' ? '非最低價' : 'N/A')}
                    </p>
                </div>
                <button onClick={onClose} className="ml-4 p-1 rounded-full hover:bg-white/20"><X className="w-5 h-5" /></button>
            </div>
        </div>
    );
}


// ----------------------------------------------------------------------------
// 5. 主應用程式元件 (App Component)
// ----------------------------------------------------------------------------

function App() {
    const { userId, isAuthReady, currentTheme, saveUserTheme } = useFirebaseAuthentication();
    const streamRef = useRef(null);
    
    const [saveResultToast, setSaveResultToast] = useState(null);

    // UI 狀態
    const [barcode, setBarcode] = useState('');
    const [productName, setProductName] = useState('');
    const [currentPrice, setCurrentPrice] = useState('');
    const [quantity, setQuantity] = useState('');
    const [unitType, setUnitType] = useState('pcs'); // 'g', 'ml', 'pcs'
    const [unitPrice, setUnitPrice] = useState(null);
    const [discountDetails, setDiscountDetails] = useState('');
    const [storeName, setStoreName] = useState('');
    const [productHistory, setProductHistory] = useState([]);
    const [comparisonResult, setComparisonResult] = useState({ message: '等待比價數據...' });
    const [statusMessage, setStatusMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [lookupStatus, setLookupStatus] = useState('ready');
    
    // Modal and Page 狀態
    const [isThemeModalOpen, setIsThemeModalOpen] = useState(false);
    const [isCaptureModalOpen, setIsCaptureModalOpen] = useState(false);
    const [isStoreSelectorOpen, setIsStoreSelectorOpen] = useState(false);
    const [isOcrQueueStoreSelectorOpen, setIsOcrQueueStoreSelectorOpen] = useState(false); // 新增狀態
    const [editingOcrCard, setEditingOcrCard] = useState(null); // 新增狀態
    const [currentPage, setCurrentPage] = useState('main'); // 'main', 'allRecords', 'ocrQueue'
    const [ocrResult, setOcrResult] = useState(null);
    const [capturedImage, setCapturedImage] = useState(null); // 新增的狀態
    
    // 新增狀態：待辨識序列
    const [pendingOcrCards, setPendingOcrCards] = useState(() => {
        // 從 localStorage 恢復待辨識卡片
        const savedCards = localStorage.getItem('pendingOcrCards');
        return savedCards ? JSON.parse(savedCards) : [];
    });
    
    // 添加 useEffect 來保存 pendingOcrCards 到 localStorage
    useEffect(() => {
        localStorage.setItem('pendingOcrCards', JSON.stringify(pendingOcrCards));
    }, [pendingOcrCards]);
    
    useEffect(() => {
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const price = parseFloat(finalPrice);
        const qty = parseFloat(quantity);

        if (!isNaN(price) && !isNaN(qty) && qty > 0) {
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(price, qty, unitType);
            setUnitPrice(calculatedUnitPrice);
        } else {
            setUnitPrice(null);
        }
    }, [currentPrice, quantity, unitType, ocrResult]);
    
    // 提前定義所有會被使用的函數，避免 no-use-before-define 警告
    const clearForm = useCallback(() => {
        setBarcode('');
        setProductName('');
        setCurrentPrice('');
        setQuantity('');
        setUnitType('pcs'); // Reset to default unit type
        setUnitPrice(null);
        setDiscountDetails('');
        setStoreName('');
        setProductHistory([]);
        setComparisonResult({ message: '等待比價數據...' });
        setOcrResult(null);
        setLookupStatus('ready');
        setCapturedImage(null); // 清除擷取的圖片
    }, []);

    const stopCameraStream = useCallback(() => {
        console.log("stopCameraStream: Attempting to stop camera.");
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
            console.log("stopCameraStream: Camera stream stopped.");
        }
    }, []);
    
    const startCameraStream = async () => {
        console.log("startCameraStream: Attempting to start camera.");
        if (streamRef.current) {
            return streamRef.current;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
            streamRef.current = stream;
            console.log("startCameraStream: Camera started successfully.");
            return stream;
        } catch (err) {
            console.error("無法存取攝影機:", err);
            setStatusMessage(`無法存取攝影機: ${err.name}`);
            return null;
        }
    };

    const lookupProduct = useCallback(async (barcodeData, currentProductName, currentStoreName) => {
        // 如果 Firebase 尚未初始化，則不執行查詢
        if (!isAuthReady || !userId) {
            return;
        }
        
        const numericalID = generateProductId(barcodeData, currentProductName, currentStoreName);

        // Adjust early exit condition:
        // If no barcode and no product name, or if barcode is too short and no product name,
        // then we can't look up a product.
        if (!numericalID) { // If numericalID couldn't be generated, then we can't look up a product.
            setProductName('');
            setLookupStatus('ready');
            setProductHistory([]);
            return;
        }
        
        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);

            if (productSnap.exists()) {
                setProductName(productSnap.data().productName);
                setLookupStatus('found');
            } else {
                setLookupStatus('new');
            }

            const recordsQueryString = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID), // numericalID is already a string
                orderBy("timestamp", "desc")
            );
            const recordsSnapString = await getDocs(recordsQueryString);
            let records = recordsSnapString.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Attempt to query for numericalID as a number, if it's a valid number string
            const numericalIDAsNumber = parseInt(numericalID, 10);
            if (!isNaN(numericalIDAsNumber) && numericalIDAsNumber.toString() === numericalID) { // Check if it's a pure number string
                const recordsQueryNumber = query(
                    collection(db, "priceRecords"),
                    where("numericalID", "==", numericalIDAsNumber),
                    orderBy("timestamp", "desc")
                );
                const recordsSnapNumber = await getDocs(recordsQueryNumber);
                const recordsNumber = recordsSnapNumber.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Merge and deduplicate records
                const mergedRecordsMap = new Map();
                records.forEach(record => mergedRecordsMap.set(record.id, record));
                recordsNumber.forEach(record => mergedRecordsMap.set(record.id, record));
                records = Array.from(mergedRecordsMap.values()).sort((a, b) => (b.timestamp?.toDate ? b.timestamp.toDate().getTime() : 0) - (a.timestamp?.toDate ? a.timestamp.toDate().getTime() : 0));
            }
            setProductHistory(records);

        } catch (error) {
            console.error("查詢產品失敗 (Firestore):", error);
            setStatusMessage("查詢產品資料時發生錯誤。");
            setLookupStatus('ready');
            setProductHistory([]);
        }
    }, [isAuthReady, userId, setProductName, setLookupStatus, setProductHistory, setStatusMessage]);

    // 新增函數：處理 OCR 隊列的商店選擇
    const handleOcrQueueStoreSelect = useCallback((card) => {
        setEditingOcrCard(card);
        setIsOcrQueueStoreSelectorOpen(true);
    }, [setEditingOcrCard, setIsOcrQueueStoreSelectorOpen]);

    // 新增函數：處理 OCR 隊列的商店選擇確認
    const handleOcrQueueStoreSelectConfirm = useCallback((selectedStore) => {
        if (editingOcrCard) {
            // 更新待辨識卡片的商店名稱
            const updatedCards = pendingOcrCards.map(card => 
                card.id === editingOcrCard.id ? { ...card, storeName: selectedStore } : card
            );
            setPendingOcrCards(updatedCards);
        }
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [editingOcrCard, pendingOcrCards, setPendingOcrCards, setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 新增函數：處理 OCR 隊列的商店選擇器關閉
    const handleOcrQueueStoreSelectorClose = useCallback(() => {
        setIsOcrQueueStoreSelectorOpen(false);
        setEditingOcrCard(null);
    }, [setIsOcrQueueStoreSelectorOpen, setEditingOcrCard]);

    // 正確地提前定義 performSaveAndCompare 函數（必須在 saveAndComparePrice 之前定義）
    const performSaveAndCompare = useCallback(async (selectedStore) => {
        const finalStoreName = selectedStore || storeName;
        const numericalID = generateProductId(barcode, productName, finalStoreName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(currentPrice, ocrResult?.specialPrice);
        const priceValue = parseFloat(finalPrice);

        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, quantity, unitType);

        if (!userId || !productName || isNaN(priceValue) || isNaN(parseFloat(quantity)) || parseFloat(quantity) <= 0 || calculatedUnitPrice === null) {
            showUserFriendlyError("請確保已輸入條碼、產品名稱、有效總價、數量和單位！", "資料驗證");
            setIsLoading(false);
            return;
        }
        if (!finalStoreName.trim()) {
            setIsStoreSelectorOpen(true);
            setIsLoading(false);
            return;
        }

        try {
            const productRef = doc(db, "products", numericalID.toString());
            const productSnap = await getDoc(productRef);
            
            // 準備產品文檔數據
            const productData = {
                numericalID,
                barcodeData: barcode,
                productName,
                createdAt: productSnap.exists() ? productSnap.data().createdAt : serverTimestamp(),
                lastUpdatedBy: userId,
            };

            // 準備價格記錄數據
            const priceRecord = {
                numericalID,
                productName,
                storeName: finalStoreName,
                price: priceValue, // 總價
                quantity: parseFloat(quantity),
                unitType: unitType,
                unitPrice: calculatedUnitPrice, // 單價
                discountDetails: discountDetails || '',
                timestamp: serverTimestamp(),
                recordedBy: userId,
                // 保存原價和特價信息（如果有的話）
                originalPrice: ocrResult?.originalPrice ? parseFloat(ocrResult.originalPrice) : null,
                specialPrice: ocrResult?.specialPrice ? parseFloat(ocrResult.specialPrice) : null
            };

            // 儲存價格記錄
            const priceRecordDocRef = await addDoc(collection(db, "priceRecords"), priceRecord);
            
            // 檢查是否需要更新產品文檔中的最佳單價
            let isBestPrice = false;
            if (productSnap.exists()) {
                const existingProductData = productSnap.data();
                // 如果產品文檔中沒有 bestUnitPrice 或新價格更低，則更新
                if (existingProductData.bestUnitPrice === undefined || calculatedUnitPrice < existingProductData.bestUnitPrice) {
                    productData.bestUnitPrice = calculatedUnitPrice;
                    productData.bestPriceRecordRef = priceRecordDocRef.path; // 儲存指向最佳價格記錄的引用路徑
                    isBestPrice = true;
                } else {
                    // 保持現有的最佳價格信息
                    productData.bestUnitPrice = existingProductData.bestUnitPrice;
                    productData.bestPriceRecordRef = existingProductData.bestPriceRecordRef;
                }
            } else {
                // 新產品，當前價格就是最佳價格
                productData.bestUnitPrice = calculatedUnitPrice;
                productData.bestPriceRecordRef = priceRecordDocRef.path;
                isBestPrice = true;
            }
            
            // 儲存或更新產品文檔
            await setDoc(productRef, productData);

            // 準備比價結果
            let toastStatus, toastMessage, isBest, bestPrice, bestStore;

            if (isBestPrice) {
                isBest = true;
                bestPrice = calculatedUnitPrice;
                bestStore = finalStoreName;
                toastStatus = 'success';
                toastMessage = '恭喜！這是目前紀錄中的最低單價！';
            } else {
                isBest = false;
                bestPrice = productData.bestUnitPrice;
                
                // 從 Firestore 獲取最佳價格記錄的商店名稱
                try {
                    const bestPriceRecordDoc = await getDoc(doc(db, productData.bestPriceRecordRef));
                    if (bestPriceRecordDoc.exists()) {
                        bestStore = bestPriceRecordDoc.data().storeName;
                    } else {
                        bestStore = '未知商店';
                    }
                } catch (error) {
                    console.error("獲取最佳價格記錄失敗:", error);
                    bestStore = '未知商店';
                }
                
                toastStatus = 'warning';
                toastMessage = `非最低單價。歷史最低單價為 $${formatUnitPrice(productData.bestUnitPrice)} (${bestStore})`;
            }

            setComparisonResult({ isBest, bestPrice, bestStore, message: toastMessage });
            // 儲存成功時顯示提示訊息
            setSaveResultToast({ status: toastStatus, message: toastMessage, productName: productName });
            
            lookupProduct(barcode, productName, finalStoreName);

        } catch (error) {
            console.error("儲存或比價失敗 (Firestore):", error);
            const userMessage = handleFirestoreSaveError(error, "儲存價格資訊");
            showUserFriendlyError(userMessage);
        } finally {
            setIsLoading(false);
        }
    }, [userId, barcode, productName, currentPrice, discountDetails, storeName, lookupProduct, quantity, unitType, setSaveResultToast, setComparisonResult, setIsLoading, setIsStoreSelectorOpen, ocrResult]);

    // 正確地提前定義 saveAndComparePrice 函數
    const saveAndComparePrice = useCallback(async (selectedStore) => {
        // 確保 Firebase 已初始化，如果尚未完成初始化則強制初始化
        if (!isAuthReady) {
            // 顯示加載訊息並等待初始化完成
            setIsLoading(true);
            // 等待 Firebase 初始化完成
            const checkAuth = () => {
                if (isAuthReady) {
                    // 初始化完成後繼續執行
                    performSaveAndCompare(selectedStore);
                } else {
                    // 繼續等待
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
            return;
        }
        
        // 如果 Firebase 已準備好，直接執行保存操作
        performSaveAndCompare(selectedStore);
    }, [isAuthReady, performSaveAndCompare]);
    
    const handleAiCaptureSuccess = useCallback((result) => {
        const { scannedBarcode, productName, extractedPrice, storeName, discountDetails, quantity, unitType, specialPrice, capturedImage: receivedImage } = result;
        setOcrResult(result);
        
        // 設置捕獲的圖像
        if (receivedImage) {
            setCapturedImage(receivedImage);
        }
        
        const newBarcode = scannedBarcode || '';
        setBarcode(newBarcode);

        if (!newBarcode) {
            setStatusMessage("AI 未能識別條碼，請手動輸入或確保條碼清晰！");
        } else {
            setStatusMessage(`AI 分析成功！`);
        }

        setProductName(productName || '');
        
        // 優先使用特價，如果有的話
        const finalPrice = specialPrice && !isNaN(parseFloat(specialPrice)) ? specialPrice : extractedPrice;
        setCurrentPrice(finalPrice || '');
        
        setStoreName(storeName || '');
        setDiscountDetails(discountDetails || '');

        setQuantity(quantity || '');
        setUnitType(unitType || 'pcs');

        if (productName && newBarcode) {
            setLookupStatus('found');
        } else {
            setLookupStatus('new');
        }
    }, [setBarcode, setProductName, setCurrentPrice, setStoreName, setDiscountDetails, setOcrResult, setStatusMessage, setLookupStatus, setQuantity, setUnitType, setCapturedImage]);

    // 新增函數：將辨識結果加入待確認序列
    const handleQueueNextCapture = useCallback((result) => {
        // 將結果加入待確認的辨識卡片中
        setPendingOcrCards(prev => [...prev, { ...result, id: Date.now() }]);
        setStatusMessage(`已將辨識結果加入待確認序列！`);
    }, []);

    // 新增函數：移除待確認的辨識卡片
    const handleRemovePendingOcrCard = useCallback((cardId) => {
        setPendingOcrCards(prev => prev.filter(item => item.id !== cardId));
    }, []);

    const handleStoreSelect = useCallback((selectedStore) => {
        setStoreName(selectedStore);
        setIsStoreSelectorOpen(false);
        // 不再自動觸發保存操作，與其他頁面保持一致
    }, [setStoreName, setIsStoreSelectorOpen]);

    const handleCaptureModalClose = useCallback(() => {
        setIsCaptureModalOpen(false);
        stopCameraStream();
    }, [stopCameraStream]);

    const handleNewScanClick = async () => {
        clearForm();
        const stream = await startCameraStream();
        if (stream) {
            setIsCaptureModalOpen(true);
        } else {
            // 如果無法啟動相機，顯示錯誤訊息
            setStatusMessage("無法啟動相機，請檢查權限設置");
        }
    };

    const themePrimary = currentTheme.primary;
    const themeText = currentTheme.text;
    const themeLight = currentTheme.light;
    const themeBorder = currentTheme.border;
    const themeHover = currentTheme.hover; // 添加這一行來定義 themeHover

    const productNamePlaceholder = useMemo(() => {
        switch(lookupStatus) {
            case 'searching': return '正在查詢產品資料...';
            case 'found': return '產品名稱已自動載入';
            case 'new': return '產品不存在，請手動輸入名稱';
            default: return '請先輸入條碼或掃描條碼';
        }
    }, [lookupStatus]);

    if (!isAuthReady) {
        return <div className="flex items-center justify-center min-h-screen bg-gray-50"><p className="text-xl text-gray-700">正在連線至雲端服務...</p></div>;
    }

    if (currentPage === 'allRecords') {
        return <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />;
    }

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${themeLight}`}>
            <SaveResultToast result={saveResultToast} onClose={() => setSaveResultToast(null)} />
            
            {/* 根據 currentPage 狀態渲染不同頁面 */}
            {currentPage === 'main' && (
                <div className="max-w-xl mx-auto">
                    <header className="flex justify-between items-center mb-6 border-b pb-4">
                        <h1 className={`text-3xl font-extrabold ${themeText} flex items-center`}><Barcode className="w-8 h-8 mr-2" />條碼比價神器 (Cloud)</h1>
                        <div className="flex items-center space-x-3">
                            {/* 新增待辨識的按鈕 */}
                            <button 
                                onClick={() => setCurrentPage('ocrQueue')}
                                className={`relative p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`}
                                title={`待辨識 (${pendingOcrCards.length})`}
                            >
                                <Zap className="w-5 h-5" />
                                {pendingOcrCards.length > 0 && (
                                    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                                        {pendingOcrCards.length}
                                    </span>
                                )}
                            </button>
                            <button onClick={() => setCurrentPage('allRecords')} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="查看所有記錄"><Database className="w-5 h-5" /></button>
                            <button onClick={() => setIsThemeModalOpen(true)} className={`p-2 rounded-full text-white shadow-md transition-all ${themePrimary} hover:opacity-80`} title="設定介面主題"><PaintBucket className="w-5 h-5" /></button>
                            <p className="text-sm text-gray-500 hidden sm:block">User: {userId.slice(0, 8)}...</p>
                        </div>
                    </header>

                    {statusMessage && <div className="bg-blue-500 text-white p-3 rounded-lg shadow-md mb-4 text-center font-medium">{statusMessage}</div>}

                    {ocrResult && (
                        <div className="bg-yellow-100 border border-yellow-300 rounded-lg p-4 mb-6">
                            <h3 className="text-lg font-semibold text-yellow-800 mb-2">AI 辨識結果 (開發者確認區)</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm">
                                <div>條碼:</div><div>{ocrResult.scannedBarcode || 'N/A'}</div>
                                <div>品名:</div><div>{ocrResult.productName || 'N/A'}</div>
                                {/* 顯示原價和特價信息 */}
                                {ocrResult.specialPrice ? (
                                    <>
                                        {ocrResult.originalPrice && (
                                            <>
                                                <div>原價:</div><div className="line-through text-red-500">${ocrResult.originalPrice.toFixed(2)}</div>
                                            </>
                                        )}
                                        <div>特價:</div><div className="text-green-600 font-bold">${ocrResult.specialPrice.toFixed(2)}</div>
                                    </>
                                ) : (
                                    <>
                                        <div>價格:</div><div>${ocrResult.extractedPrice || 'N/A'}</div>
                                    </>
                                )}
                                <div>數量:</div><div>{ocrResult.quantity || 'N/A'}</div>
                                <div>商店:</div><div>{ocrResult.storeName || 'N/A'}</div>
                                <div>折扣:</div><div>{ocrResult.discountDetails || '無'}</div>
                            </div>
                            <button onClick={() => setOcrResult(null)} className="mt-3 px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 text-sm">關閉</button>
                        </div>
                    )}

                    <div className={`p-6 rounded-xl shadow-2xl bg-white border-t-4 ${themeBorder}`}>
                        <h2 className={`text-xl font-semibold ${themeText} mb-6 flex items-center`}><Zap className="w-5 h-5 mr-2" />步驟 1: AI 視覺自動擷取</h2>
                        <button className={`w-full p-4 rounded-lg text-white font-bold text-lg shadow-xl transition-all ${themePrimary} hover:opacity-80 flex items-center justify-center`} onClick={handleNewScanClick}>
                            <Camera className="inline-block w-6 h-6 mr-3" />開啟鏡頭擷取
                        </button>
                        <hr className="my-6 border-gray-200" />
                        <h2 className={`text-xl font-semibold text-gray-700 mb-4 flex items-center`}><FileText className="w-5 h-5 mr-2" />步驟 2: 檢查或手動輸入</h2>
                        
                        {/* 新增的擷取畫面顯示區塊 */}
                        {capturedImage && (
                            <div className="mb-6">
                                <label className="block text-gray-700 font-medium mb-2">擷取畫面 (請確認辨識資料是否正確)</label>
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                    <div className="relative w-full aspect-video">
                                        {capturedImage.startsWith('data:image') ? (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        ) : (
                                            <img src={capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                        )}
                                    </div>
                                </div>
                                <p className="text-sm text-gray-500 mt-2">此圖片將持續顯示直到進行下一次辨識或退出應用程式</p>
                            </div>
                        )}
                        
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">條碼數據</label>
                            <input type="text" value={barcode} onChange={(e) => setBarcode(e.target.value)} placeholder="AI 自動填入，或手動輸入" className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" />
                        </div>
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-1">產品名稱</label>
                            <input type="text" value={productName} onChange={(e) => setProductName(e.target.value)} placeholder={productNamePlaceholder} className={`w-full p-3 border border-gray-300 rounded-lg ${lookupStatus === 'found' ? 'bg-green-50' : lookupStatus === 'new' ? 'bg-yellow-50' : ''}`} readOnly={lookupStatus === 'found' && !ocrResult} />
                            <p className="text-sm text-gray-500 mt-1">ID (Hash): {barcode ? djb2Hash(barcode) : 'N/A'}</p>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">總價 ($) <span className="text-red-500">*</span></label>
                                <input type="number" value={currentPrice} onChange={(e) => setCurrentPrice(e.target.value)} placeholder="AI 擷取" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">商店名稱</label>
                                <input 
                                    type="text" 
                                    value={storeName} 
                                    onFocus={() => setIsStoreSelectorOpen(true)}
                                    readOnly
                                    placeholder="點擊選擇商店"
                                    className="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 cursor-pointer"
                                />
                            </div>
                        </div>
                        <div className="grid grid-cols-3 gap-4 mb-4">
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">數量 <span className="text-red-500">*</span></label>
                                <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="例如: 500" className="w-full p-3 border border-gray-300 rounded-lg" />
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單位 <span className="text-red-500">*</span></label>
                                <select value={unitType} onChange={(e) => setUnitType(e.target.value)} className="w-full p-3 border border-gray-300 rounded-lg">
                                    <option value="ml">ml (毫升)</option>
                                    <option value="g">g (克)</option>
                                    <option value="pcs">pcs (個/包/支/條)</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-gray-700 font-medium mb-1">單價 (每100g/ml)</label>
                                <input type="text" value={formatUnitPrice(unitPrice)} readOnly className="w-full p-3 border border-gray-300 rounded-lg bg-gray-100" />
                            </div>
                        </div>
                        <div className="mb-6">
                            <label className="block text-gray-700 font-medium mb-1">優惠細節</label>
                            <input type="text" value={discountDetails} onChange={(e) => setDiscountDetails(e.target.value)} placeholder="例如: 買二送一" className="w-full p-3 border border-gray-300 rounded-lg" />
                        </div>
                        <button className={`w-full mt-4 p-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-emerald-500 hover:bg-emerald-600`} onClick={() => saveAndComparePrice()} disabled={isLoading}>
                            <ClipboardCheck className="inline-block w-5 h-5 mr-2" />{isLoading ? '處理中...' : '步驟 3: 儲存紀錄並比價'}
                        </button>
                    </div>

                    <div className="mt-8">
                        <h2 className={`text-xl font-semibold ${themeText} mb-4 flex items-center`}>
                            <DollarSign className="w-5 h-5 mr-2" />
                            比價結果 {productName && <span className="ml-2 font-normal text-gray-500">- {productName}</span>}
                        </h2>
                        <div className={`p-6 rounded-xl shadow-xl border-2 ${comparisonResult.isBest ? 'border-green-500 bg-green-50' : 'border-yellow-500 bg-yellow-50'}`}>
                            <p className={`text-lg font-bold ${comparisonResult.isBest ? 'text-green-700' : 'text-yellow-700'}`}>{comparisonResult.message}</p>
                            {comparisonResult.bestPrice && <p className="text-sm text-gray-600 mt-2">歷史最低標價: ${comparisonResult.bestPrice}</p>}
                            <p className="text-xs text-gray-500 mt-2">**附註:** 您的紀錄已安全儲存在雲端。</p>
                        </div>
                    </div>

                    {(lookupStatus === 'found' || lookupStatus === 'new') && <PriceHistoryDisplay historyRecords={productHistory} theme={currentTheme} />}
                    
                    {/* 在主介面添加一個快捷處理待辨識卡片的按鈕 */}
                    {pendingOcrCards.length > 0 && (
                        <div className="mt-4 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold text-yellow-800">有待辨識的項目</h3>
                                    <p className="text-sm text-yellow-600">您有 {pendingOcrCards.length} 個待辨識的項目等待處理</p>
                                </div>
                                <button 
                                    onClick={() => {
                                        // 處理第一個待辨識的卡片
                                        const firstCard = pendingOcrCards[0];
                                        
                                        // 設置表單數據
                                        setOcrResult(firstCard);
                                        setCapturedImage(firstCard.capturedImage);
                                        setBarcode(firstCard.scannedBarcode || '');
                                        setProductName(firstCard.productName || '');
                                        setCurrentPrice(firstCard.extractedPrice || '');
                                        setStoreName(firstCard.storeName || '');
                                        setDiscountDetails(firstCard.discountDetails || '');
                                        setQuantity(firstCard.quantity || '');
                                        setUnitType(firstCard.unitType || 'pcs');
                                        
                                        // 計算單價
                                        const priceValue = parseFloat(firstCard.extractedPrice);
                                        const qty = parseFloat(firstCard.quantity);
                                        if (!isNaN(priceValue) && !isNaN(qty) && qty > 0) {
                                            const calculatedUnitPrice = calculateUnitPrice(priceValue, qty, firstCard.unitType);
                                            setUnitPrice(calculatedUnitPrice);
                                        }
                                        
                                        // 更新狀態
                                        if (firstCard.productName && firstCard.scannedBarcode) {
                                            setLookupStatus('found');
                                        } else {
                                            setLookupStatus('new');
                                        }
                                        
                                        // 從待辨識序列中移除該卡片
                                        setPendingOcrCards(prev => prev.filter(item => item.id !== firstCard.id));
                                        
                                        // 顯示提示訊息
                                        setStatusMessage(`已載入待辨識項目: ${firstCard.productName || '未命名產品'}`);
                                    }}
                                    className={`px-4 py-2 rounded-lg text-white font-medium ${themePrimary} ${themeHover}`}
                                >
                                    處理第一個待辨識項目
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            )}
            
            {currentPage === 'allRecords' && (
                <AllRecordsPage theme={currentTheme} onBack={() => setCurrentPage('main')} db={db} userId={userId} isAuthReady={isAuthReady} />
            )}
            
            {currentPage === 'ocrQueue' && (
                <OcrQueuePage 
                    theme={currentTheme} 
                    onBack={() => setCurrentPage('main')} 
                    pendingOcrCards={pendingOcrCards}
                    onRemoveCard={handleRemovePendingOcrCard}
                    onStoreSelect={setPendingOcrCards}
                    isStoreSelectorOpen={isOcrQueueStoreSelectorOpen}
                    onStoreSelectCallback={handleOcrQueueStoreSelect}
                    onCloseStoreSelector={handleOcrQueueStoreSelectorClose}
                />
            )}

            {isThemeModalOpen && <ThemeSelector theme={currentTheme} saveTheme={saveUserTheme} onClose={() => setIsThemeModalOpen(false)} />}
            {isCaptureModalOpen && <AIOcrCaptureModal theme={currentTheme} onAnalysisSuccess={handleAiCaptureSuccess} onClose={handleCaptureModalClose} stream={streamRef.current} onQueueNextCapture={handleQueueNextCapture} />}
            {isStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleStoreSelect} onClose={() => setIsStoreSelectorOpen(false)} />}
            {isOcrQueueStoreSelectorOpen && <StoreSelector theme={currentTheme} onSelect={handleOcrQueueStoreSelectConfirm} onClose={handleOcrQueueStoreSelectorClose} />}
        </div>
    );
}

export default App;
</file>

<file path="components/AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components/AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="firebase-config.js">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAtaZL06wkWJHhOJdne2Z_h9fMIEYldgjM",
  authDomain: "barcodepricing-00898.firebaseapp.com",
  projectId: "barcodepricing-00898",
  storageBucket: "barcodepricing-00898.firebasestorage.app",
  messagingSenderId: "286146042453",
  appId: "1:286146042453:web:14a20a662dcf3d06f592dc",
  measurementId: "G-6GMRVJ4S52"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

export { db };
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="OcrQueuePage.js">
import React, { useState, useEffect, useCallback } from 'react';
import { ArrowLeft, Trash2, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { db } from './firebase-config.js';
import { doc, setDoc, addDoc, collection, serverTimestamp, getDoc, query, where, getDocs } from "firebase/firestore";
import { calculateUnitPrice, calculateFinalPrice, formatUnitPrice } from './utils/priceCalculations';
import { showUserFriendlyError, handleFirestoreSaveError } from './utils/errorHandler'; // 導入錯誤處理工具

// 計算 localStorage 使用量的函數
function getLocalStorageUsage() {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += (localStorage[key].length + key.length) * 2; // 每個字符佔用 2 bytes
    }
  }
  const used = (total / 1024).toFixed(2); // 轉換為 KB
  const quota = 5120; // 大多数瀏覽器的 localStorage 限制約為 5MB
  const percentage = ((used / quota) * 100).toFixed(2);
  
  return {
    used: used,
    quota: quota,
    percentage: percentage
  };
}

// 刪除確認對話框組件
function DeleteConfirmation({ card, onClose, onConfirm }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                <h2 className="text-xl font-bold mb-4">確認刪除</h2>
                <p className="mb-4">您確定要刪除此待辨識項目嗎？</p>
                <p className="mb-4 font-semibold text-gray-800">{card.productName || '未命名產品'}</p>
                <div className="flex justify-end space-x-3">
                    <button 
                        onClick={onClose}
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
                    >
                        取消
                    </button>
                    <button 
                        onClick={onConfirm}
                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                    >
                        確認刪除
                    </button>
                </div>
            </div>
        </div>
    );
}

function OcrQueuePage({ theme, onBack, pendingOcrCards, onRemoveCard, onStoreSelect, 
    isStoreSelectorOpen, onStoreSelectCallback, onCloseStoreSelector }) {
    const [queueStats, setQueueStats] = useState({
        total: 0,
        oldest: null,
        newest: null
    });
    
    // 新增狀態：localStorage 使用量
    const [localStorageUsage, setLocalStorageUsage] = useState({
        used: 0,
        quota: 5120,
        percentage: 0
    });
    
    // 新增狀態：刪除確認對話框
    const [deleteConfirmation, setDeleteConfirmation] = useState(null);
    
    // 新增狀態：正在編輯的卡片
    // 移除 editingCard 狀態，因為現在由父組件控制
    // const [editingCard, setEditingCard] = useState(null);
    
    // 新增狀態：比價結果
    const [priceComparisonResults, setPriceComparisonResults] = useState({});

    useEffect(() => {
        if (pendingOcrCards.length > 0) {
            const timestamps = pendingOcrCards.map(card => card.id);
            setQueueStats({
                total: pendingOcrCards.length,
                oldest: Math.min(...timestamps),
                newest: Math.max(...timestamps)
            });
        } else {
            setQueueStats({
                total: 0,
                oldest: null,
                newest: null
            });
        }
        
        // 更新 localStorage 使用量
        setLocalStorageUsage(getLocalStorageUsage());
    }, [pendingOcrCards]);

    const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleString('zh-TW');
    };

    const calculateDuration = (timestamp) => {
        const now = Date.now();
        const diffMs = now - timestamp;
        const diffSecs = Math.floor(diffMs / 1000);
        const diffMins = Math.floor(diffSecs / 60);
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            return `${diffHours}小時前`;
        } else if (diffMins > 0) {
            return `${diffMins}分鐘前`;
        } else {
            return `${diffSecs}秒前`;
        }
    };

    // 處理刪除操作
    const handleDeleteClick = (card) => {
        setDeleteConfirmation(card);
    };

    // 確認刪除
    const confirmDelete = () => {
        if (deleteConfirmation) {
            onRemoveCard(deleteConfirmation.id);
            setDeleteConfirmation(null);
            // 刪除後更新 localStorage 使用量
            setTimeout(() => {
                setLocalStorageUsage(getLocalStorageUsage());
            }, 100);
        }
    };

    // 取消刪除
    const cancelDelete = () => {
        setDeleteConfirmation(null);
    };

    // 處理儲存操作 - 檢查商店名稱
    const handleSaveClick = async (card) => {
        // 檢查商店名稱是否為空白
        if (!card.storeName || card.storeName.trim() === '') {
            // 如果商店名稱為空白，顯示商店選擇器
            onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
        } else {
            // 如果商店名稱不為空白，直接儲存（不再彈出確認對話框）
            try {
                // 儲存到 Firebase
                await saveOcrCardToFirebase(card);
                
                // 從待辨識序列中移除
                onRemoveCard(card.id);
                
                // 儲存後更新 localStorage 使用量
                setTimeout(() => {
                    setLocalStorageUsage(getLocalStorageUsage());
                }, 100);
                
                // 儲存成功時不顯示任何訊息
            } catch (error) {
                console.error("儲存失敗:", error);
                const userMessage = handleFirestoreSaveError(error, "儲存待辨識卡片");
                showUserFriendlyError(userMessage);
            }
        }
    };

    // 處理卡片欄位變更
    const handleCardChange = (cardId, field, value) => {
        const updatedCards = pendingOcrCards.map(card => 
            card.id === cardId ? { ...card, [field]: value } : card
        );
        onStoreSelect(updatedCards);
        
        // 當價格相關欄位變更時，重新計算比價結果
        if (field === 'extractedPrice' || field === 'specialPrice' || field === 'originalPrice' || field === 'quantity' || field === 'unitType') {
            // 延遲一點時間再重新計算，確保狀態已更新
            setTimeout(() => {
                const fetchPriceComparisonResults = async () => {
                    const results = {};
                    for (const card of updatedCards) {
                        const result = await checkIfBestPrice(card, updatedCards);
                        results[card.id] = result;
                    }
                    setPriceComparisonResults(results);
                };
                
                fetchPriceComparisonResults();
            }, 0);
        }
    };

    // 處理商店欄位點擊
    const handleStoreClick = (card) => {
        onStoreSelectCallback(card); // 調用從父組件傳入的回調函數
    };

    // 儲存 OCR 卡片到 Firebase
    const saveOcrCardToFirebase = async (card) => {
        // 生成產品 ID
        const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
        
        // 使用新的價格計算函數來確定最終價格
        const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
        const priceValue = parseFloat(finalPrice);
        
        // 使用 calculateUnitPrice 函數計算單價
        const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
        
        // 儲存產品資訊
        const productRef = doc(db, "products", numericalID.toString());
        const productSnap = await getDoc(productRef);
        if (!productSnap.exists()) {
            await setDoc(productRef, {
                numericalID,
                barcodeData: card.scannedBarcode,
                productName: card.productName,
                createdAt: serverTimestamp(),
                lastUpdatedBy: "ocr-queue", // 標記為來自 OCR 隊列
            });
        }
        
        // 儲存價格記錄
        const priceRecord = {
            numericalID,
            productName: card.productName,
            storeName: card.storeName,
            price: priceValue, // 總價
            quantity: parseFloat(card.quantity),
            unitType: card.unitType,
            unitPrice: calculatedUnitPrice, // 單價
            discountDetails: card.discountDetails || '',
            timestamp: serverTimestamp(),
            recordedBy: "ocr-queue", // 標記為來自 OCR 隊列
            // 保存原價和特價信息（如果有的話）
            originalPrice: card.originalPrice ? parseFloat(card.originalPrice) : null,
            specialPrice: card.specialPrice ? parseFloat(card.specialPrice) : null
        };
        
        await addDoc(collection(db, "priceRecords"), priceRecord);
    };

    // 生成產品 ID 的函數
    function generateProductId(barcode, productName, storeName) {
        function djb2Hash(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i);
            }
            return hash >>> 0;
        }
        
        if (barcode) {
            return djb2Hash(barcode).toString();
        } else {
            // Combine productName and storeName to create a unique ID for products without barcodes
            return djb2Hash(`${productName}-${storeName}`).toString();
        }
    }

    // 新增函數：檢查價格是否為歷史最低（包含待辨識序列中的卡片）
    const checkIfBestPrice = useCallback(async (card, allCards) => {
        try {
            // 生成產品 ID
            const numericalID = generateProductId(card.scannedBarcode, card.productName, card.storeName);
            
            if (!numericalID) return null;
            
            // 使用新的價格計算函數來確定最終價格
            const finalPrice = calculateFinalPrice(card.extractedPrice, card.specialPrice);
            const priceValue = parseFloat(finalPrice);
            
            // 使用 calculateUnitPrice 函數計算單價
            const calculatedUnitPrice = calculateUnitPrice(priceValue, card.quantity, card.unitType);
            
            if (calculatedUnitPrice === null) return null;
            
            // 查詢 Firebase 中該產品的所有價格記錄
            const recordsQuery = query(
                collection(db, "priceRecords"),
                where("numericalID", "==", numericalID)
            );
            
            const recordsSnap = await getDocs(recordsQuery);
            const records = recordsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // 準備所有記錄以進行比較（包括當前記錄和待辨識序列中的相同產品）
            let allRecordsForCompare = [...records, { 
                unitPrice: calculatedUnitPrice,
                timestamp: new Date()
            }];
            
            // 添加待辨識序列中相同產品的卡片（排除當前卡片）
            const sameProductCards = allCards.filter(c => 
                c.id !== card.id && 
                generateProductId(c.scannedBarcode, c.productName, c.storeName) === numericalID
            );
            
            // 將相同產品的卡片添加到比較列表中
            sameProductCards.forEach(c => {
                const cardFinalPrice = calculateFinalPrice(c.extractedPrice, c.specialPrice);
                const cardPriceValue = parseFloat(cardFinalPrice);
                const cardUnitPrice = calculateUnitPrice(cardPriceValue, c.quantity, c.unitType);
                
                if (cardUnitPrice !== null) {
                    allRecordsForCompare.push({
                        unitPrice: cardUnitPrice,
                        timestamp: new Date(c.id) // 使用卡片 ID 作為時間戳
                    });
                }
            });

            // 如果沒有歷史記錄，則當前價格就是最低價
            if (allRecordsForCompare.length <= 1) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            }
            
            // 使用與主頁面相同的比價邏輯
            const bestDeal = allRecordsForCompare.reduce((best, cur) => {
                const curUnitPrice = cur.unitPrice !== undefined && cur.unitPrice !== null ? cur.unitPrice : Infinity;
                const bestUnitPrice = best.unitPrice !== undefined && best.unitPrice !== null ? best.unitPrice : Infinity;
                return curUnitPrice < bestUnitPrice ? cur : best;
            });

            const isBest = calculatedUnitPrice <= (bestDeal.unitPrice !== undefined && bestDeal.unitPrice !== null ? bestDeal.unitPrice : Infinity);
            
            if (isBest) {
                return { isBest: true, message: "歷史最低價", backgroundColor: "bg-green-100" };
            } else {
                return { isBest: false, message: "非歷史最低價", backgroundColor: "bg-yellow-100" };
            }
        } catch (error) {
            console.error("比價檢查失敗:", error);
            return null;
        }
    }, []);

    // 當待辨識卡片列表改變時，重新計算比價結果
    useEffect(() => {
        const fetchPriceComparisonResults = async () => {
            const results = {};
            for (const card of pendingOcrCards) {
                const result = await checkIfBestPrice(card, pendingOcrCards);
                results[card.id] = result;
            }
            setPriceComparisonResults(results);
        };
        
        if (pendingOcrCards.length > 0) {
            fetchPriceComparisonResults();
        } else {
            setPriceComparisonResults({});
        }
    }, [pendingOcrCards, checkIfBestPrice]);

    return (
        <div className={`min-h-screen p-4 sm:p-8 ${theme.bg}`}>
            <div className="max-w-2xl mx-auto">
                <div className="flex items-center mb-6 border-b pb-4">
                    <button onClick={onBack} className="flex items-center text-indigo-600 hover:text-indigo-800 mr-4">
                        <ArrowLeft className="mr-1" size={20} />返回
                    </button>
                    <h1 className={`text-2xl font-bold ${theme.text} flex items-center`}>
                        <Clock className="w-6 h-6 mr-2" />待辨識序列管理
                    </h1>
                </div>

                {queueStats.total > 0 ? (
                    <div className="mb-6 p-4 bg-white rounded-lg shadow">
                        <h2 className="text-lg font-semibold mb-3">序列統計</h2>
                        {/* 改為橫式條列呈現 */}
                        <div className="flex flex-wrap gap-4">
                            <div className="flex items-center">
                                <div className="bg-blue-100 p-2 rounded-full mr-2">
                                    <span className="text-blue-600 font-bold">{queueStats.total}</span>
                                </div>
                                <span className="text-gray-600">總數</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-green-100 p-2 rounded-full mr-2">
                                    <span className="text-green-600 font-bold">{queueStats.oldest ? formatTime(queueStats.oldest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最早</span>
                            </div>
                            
                            <div className="flex items-center">
                                <div className="bg-purple-100 p-2 rounded-full mr-2">
                                    <span className="text-purple-600 font-bold">{queueStats.newest ? formatTime(queueStats.newest) : 'N/A'}</span>
                                </div>
                                <span className="text-gray-600">最新</span>
                            </div>
                        </div>
                        
                        {/* localStorage 使用量顯示 */}
                        <div className="mt-4 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                ) : (
                    <div className="text-center py-10 bg-white rounded-xl shadow">
                        <AlertCircle size={48} className="mx-auto text-gray-400 mb-4" />
                        <h3 className="text-xl font-semibold text-gray-700 mb-2">無待辨識項目</h3>
                        <p className="text-gray-500">目前沒有任何待確認的辨識卡片</p>
                        
                        {/* localStorage 使用量顯示（即使沒有項目也顯示） */}
                        <div className="mt-6 pt-4 border-t border-gray-200">
                            <h3 className="text-md font-semibold mb-2">儲存空間使用量</h3>
                            <div className="flex items-center">
                                <div className="flex-1 mr-4">
                                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                                        <div 
                                            className="bg-blue-600 h-2.5 rounded-full" 
                                            style={{ width: `${localStorageUsage.percentage > 100 ? 100 : localStorageUsage.percentage}%` }}
                                        ></div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 whitespace-nowrap">
                                    <span>{localStorageUsage.used} KB</span>
                                    <span className="mx-1">/</span>
                                    <span>{localStorageUsage.quota} KB</span>
                                    <span className="ml-1">({localStorageUsage.percentage}%)</span>
                                </div>
                            </div>
                            {localStorageUsage.percentage > 90 && (
                                <div className="mt-2 text-sm text-yellow-600">
                                    ⚠️ 儲存空間使用率已超過 90%，請及時清理不需要的項目
                                </div>
                            )}
                            {localStorageUsage.percentage > 100 && (
                                <div className="mt-2 text-sm text-red-600">
                                    ❌ 儲存空間已滿，無法新增更多項目
                                </div>
                            )}
                        </div>
                    </div>
                )}

                <div className="space-y-4">
                    {pendingOcrCards.map((card) => (
                        <div 
                            key={card.id} 
                            className={`bg-white p-4 rounded-lg shadow border-4 ${
                                priceComparisonResults[card.id]?.isBest 
                                    ? 'border-green-500' 
                                    : 'border-yellow-500'
                            }`}
                        >
                            <div className="flex justify-between items-start">
                                <div className="flex-1">
                                    {/* 將比價結果移到卡片頂部 */}
                                    {priceComparisonResults[card.id] && (
                                        <div className={`mb-3 p-2 rounded text-center text-base font-bold ${
                                            priceComparisonResults[card.id].isBest 
                                                ? 'bg-green-500 text-white' 
                                                : 'bg-yellow-500 text-pink-800'
                                        }`}>
                                            {priceComparisonResults[card.id].message}
                                        </div>
                                    )}
                                    
                                    <input
                                        type="text"
                                        value={card.productName || ''}
                                        onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                        className="font-bold text-lg text-gray-800 w-full p-1 mb-2 border-b border-gray-300 focus:border-blue-500 focus:outline-none"
                                        placeholder="產品名稱"
                                    />
                                    
                                    {/* 擷取畫面顯示 */}
                                    {card.capturedImage && (
                                        <div className="mt-3 mb-3">
                                            <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 relative overflow-hidden">
                                                <div className="relative w-full aspect-video">
                                                    {card.capturedImage.startsWith('data:image') ? (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    ) : (
                                                        <img src={card.capturedImage} alt="擷取畫面" className="w-full h-full object-cover" />
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-1 mt-1 text-sm">
                                        {/* 條碼欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">條碼數據</label>
                                            <input
                                                type="text"
                                                value={card.scannedBarcode || ''}
                                                onChange={(e) => handleCardChange(card.id, 'scannedBarcode', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="條碼"
                                            />
                                        </div>
                                        
                                        {/* 產品名稱欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">產品名稱</label>
                                            <input
                                                type="text"
                                                value={card.productName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'productName', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="產品名稱"
                                            />
                                        </div>
                                        
                                        {/* 商店欄位 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">商店名稱</label>
                                            <input
                                                type="text"
                                                value={card.storeName || ''}
                                                onChange={(e) => handleCardChange(card.id, 'storeName', e.target.value)}
                                                onClick={() => handleStoreClick(card)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 bg-gray-50 cursor-pointer"
                                                placeholder="點擊選擇商店"
                                            />
                                        </div>
                                        
                                        {/* 價格欄位 */}
                                        {card.specialPrice !== undefined ? (
                                            <>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">原價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.originalPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'originalPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                        placeholder="原價"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-gray-700 font-medium mb-0.5">特價 ($)</label>
                                                    <input
                                                        type="number"
                                                        value={card.specialPrice || ''}
                                                        onChange={(e) => handleCardChange(card.id, 'specialPrice', e.target.value)}
                                                        className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 text-green-600 font-bold"
                                                        placeholder="特價"
                                                    />
                                                </div>
                                            </>
                                        ) : (
                                            <div className="col-span-2">
                                                <label className="block text-gray-700 font-medium mb-0.5">總價 ($)</label>
                                                <input
                                                    type="number"
                                                    value={card.extractedPrice || ''}
                                                    onChange={(e) => handleCardChange(card.id, 'extractedPrice', e.target.value)}
                                                    className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                    placeholder="價格"
                                                />
                                            </div>
                                        )}
                                        
                                        {/* 數量和單位 */}
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">數量</label>
                                            <input
                                                type="text"
                                                value={card.quantity || ''}
                                                onChange={(e) => handleCardChange(card.id, 'quantity', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="數量"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-gray-700 font-medium mb-0.5">單位</label>
                                            <select
                                                value={card.unitType || 'pcs'}
                                                onChange={(e) => handleCardChange(card.id, 'unitType', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                            >
                                                <option value="ml">ml (毫升)</option>
                                                <option value="g">g (克)</option>
                                                <option value="pcs">pcs (個/包/支/條)</option>
                                            </select>
                                        </div>
                                        
                                        {/* 單價 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">單價 (每100g/ml)</label>
                                            <input
                                                type="text"
                                                value={formatUnitPrice(card.unitPrice)}
                                                readOnly
                                                className="w-full px-2 py-0 border border-gray-300 rounded bg-gray-100"
                                            />
                                        </div>
                                        
                                        {/* 優惠資訊 */}
                                        <div className="col-span-2">
                                            <label className="block text-gray-700 font-medium mb-0.5">優惠細節</label>
                                            <input
                                                type="text"
                                                value={card.discountDetails || ''}
                                                onChange={(e) => handleCardChange(card.id, 'discountDetails', e.target.value)}
                                                className="w-full px-2 py-0 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500"
                                                placeholder="優惠資訊"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>加入時間: {formatTime(card.id)}</p>
                                        <p>運行時間: {calculateDuration(card.id)}</p>
                                    </div>
                                </div>
                                <div className="flex flex-col">
                                    <button 
                                        onClick={() => handleSaveClick(card)}
                                        className="p-2 text-green-500 hover:text-green-700 hover:bg-green-50 rounded-full"
                                        title="確認儲存"
                                    >
                                        <CheckCircle size={20} />
                                    </button>
                                    <button 
                                        onClick={() => handleDeleteClick(card)}
                                        className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-full mt-5"
                                        title="刪除"
                                    >
                                        <Trash2 size={20} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            
            {/* 刪除確認對話框 - 保留 */}
            {deleteConfirmation && (
                <DeleteConfirmation 
                    card={deleteConfirmation}
                    onClose={cancelDelete}
                    onConfirm={confirmDelete}
                />
            )}
        </div>
    );
}

export default OcrQueuePage;
</file>

<file path="StoreSelector.js">
import React, { useState, useEffect, useCallback } from 'react';
import { X } from 'lucide-react';
import { db } from './firebase-config';
import { collection, getDocs, addDoc, query, where, serverTimestamp, doc, updateDoc } from 'firebase/firestore';

const initialStores = [
    { name: "全聯", sort: 1 },
    { name: "大全聯", sort: 2 },
    { name: "家樂福", sort: 3 },
    { name: "7-11", sort: 4 }, 
    { name: "全家", sort: 5 },
    { name: "萊爾富", sort: 6 }, 
    { name: "好市多", sort: 7 }, 
    { name: "屈臣氏", sort: 8 }, 
    { name: "康是美", sort: 9 },
    { name: "美廉社", sort: 10 }, 
    { name: "愛買", sort: 11 },
    { name: "其他", sort: 999 }
];

function StoreSelector({ theme, onSelect, onClose }) {
    const [selectedStore, setSelectedStore] = useState('');
    const [otherStore, setOtherStore] = useState('');
    const [commonStores, setCommonStores] = useState([]);
    const [loading, setLoading] = useState(true);

    const fetchStores = useCallback(async () => {
        setLoading(true);
        try {
            const storesCollection = collection(db, 'stores');
            let querySnapshot = await getDocs(storesCollection);

            if (querySnapshot.empty) {
                const batch = initialStores.map(store => 
                    addDoc(storesCollection, { ...store, createdAt: serverTimestamp() })
                );
                await Promise.all(batch);
                querySnapshot = await getDocs(storesCollection);
            } else {
                // --- Start of new migration logic ---
                const storesFromDb = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const updates = [];

                for (const initialStore of initialStores) {
                    const dbStore = storesFromDb.find(s => s.name === initialStore.name);
                    // If the store exists in DB but the sort order is different from the code
                    if (dbStore && dbStore.sort !== initialStore.sort) {
                        const storeRef = doc(db, 'stores', dbStore.id);
                        updates.push(updateDoc(storeRef, { sort: initialStore.sort }));
                    }
                }

                // If there are any updates to perform
                if (updates.length > 0) {
                    console.log(`Updating sort order for ${updates.length} stores...`);
                    await Promise.all(updates);
                    // Re-fetch the data after updates to ensure we have the latest version
                    querySnapshot = await getDocs(storesCollection);
                    console.log("Store sort order updated successfully.");
                }
                // --- End of new migration logic ---
            }

            const storesList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const uniqueStores = Array.from(new Map(storesList.map(store => [store.name, store])).values());
            const sortedStores = uniqueStores.sort((a, b) => (a.sort || 999) - (b.sort || 999));
            
            setCommonStores(sortedStores);

        } catch (error) {
            console.error("Firebase Error in fetchStores:", error);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchStores();
    }, [fetchStores]);

    const handleSelect = async () => {
        if (selectedStore === '其他' && otherStore.trim() === '') {
            alert('請輸入其他商店名稱');
            return;
        }
        
        let finalStoreName = selectedStore === '其他' ? otherStore.trim() : selectedStore;

        if (selectedStore === '其他') {
            const storesCollection = collection(db, 'stores');
            const q = query(storesCollection, where("name", "==", finalStoreName));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                await addDoc(storesCollection, {
                    name: finalStoreName,
                    sort: 1000, 
                    createdAt: serverTimestamp()
                });
            }
        }
        
        onSelect(finalStoreName);
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-[60] flex items-center justify-center p-4 sm:p-6">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-[calc(100%-80px)] sm:max-w-md flex flex-col max-h-[80vh] h-auto">
                <div className="p-6 pb-4 flex-shrink-0">
                    <div className="flex justify-between items-center mb-4 border-b pb-2">
                        <h3 className={`text-xl font-bold ${theme.text}`}>
                            選擇商店
                        </h3>
                        <button 
                            onClick={onClose}
                            className="p-1 rounded-full text-gray-500 hover:text-gray-900"
                        >
                            <X className="w-6 h-6" />
                        </button>
                    </div>
                    <p className="text-gray-600">請選擇或輸入商店名稱：</p>
                </div>

                {loading ? (
                    <div className="flex-grow flex justify-center items-center">
                        <p className="text-gray-600">正在從資料庫載入商店列表...</p>
                    </div>
                ) : (
                    <div className="flex-grow overflow-y-auto px-6">
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 py-1">
                            {commonStores.map((store) => (
                                <button
                                    key={store.id}
                                    onClick={() => setSelectedStore(store.name)}
                                    className={`p-3 rounded-lg text-center font-medium transition-all ${
                                        selectedStore === store.name 
                                            ? `${themePrimary} text-white shadow-md` 
                                            : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                                    }`}
                                >
                                    {store.name}
                                </button>
                            ))}
                        </div>
                    </div>
                )}

                <div className="p-6 pt-4 flex-shrink-0">
                    {selectedStore === '其他' && (
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-2">請輸入商店名稱：</label>
                            <input
                                type="text"
                                value={otherStore}
                                onChange={(e) => setOtherStore(e.target.value)}
                                placeholder="輸入商店名稱"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"
                            />
                        </div>
                    )}

                    <div className="flex justify-end space-x-3 pt-4 border-t">
                        <button
                            onClick={onClose}
                            className="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-lg hover:bg-gray-600 transition-all"
                        >
                            取消
                        </button>
                        <button
                            onClick={handleSelect}
                            disabled={loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')}
                            className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg transition-all ${
                                loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : `${themePrimary} ${themeHover}`
                            }`}
                        >
                            確認選擇
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}

export default StoreSelector;
</file>

<file path="utils/errorHandler.js">
/**
 * 全域錯誤處理工具函數
 * 提供更具體的錯誤訊息給使用者
 */

/**
 * 解析 Firebase 錯誤並返回使用者友好的錯誤訊息
 * @param {Error} error - Firebase 錯誤物件
 * @returns {string} 使用者友好的錯誤訊息
 */
export function parseFirebaseError(error) {
    if (!error || !error.code) {
        return "發生未知錯誤，請稍後再試";
    }

    // 根據 Firebase 錯誤碼提供具體的錯誤訊息
    switch (error.code) {
        case 'permission-denied':
            return "權限不足，無法儲存資料。請聯繫系統管理員";
        
        case 'unavailable':
            return "Firebase 服務暫時無法使用，請檢查網路連線後再試";
            
        case 'deadline-exceeded':
            return "請求超時，請檢查網路連線後再試";
            
        case 'resource-exhausted':
            return "系統資源已滿，請稍後再試";
            
        case 'failed-precondition':
            return "資料格式錯誤，無法儲存";
            
        case 'aborted':
            return "操作被中斷，請重新嘗試";
            
        case 'out-of-range':
            return "資料超出允許範圍";
            
        case 'unimplemented':
            return "此功能尚未實作";
            
        case 'internal':
            return "系統內部錯誤，請稍後再試";
            
        case 'data-loss':
            return "資料遺失，請重新輸入";
            
        case 'unauthenticated':
            return "身份驗證失敗，請重新整理頁面";
            
        default:
            // 對於其他錯誤，提供通用但具體的訊息
            if (error.message.includes('offline') || error.message.includes('network')) {
                return "網路連線異常，請檢查網路設定後再試";
            }
            if (error.message.includes('quota')) {
                return "超過使用配額，請稍後再試";
            }
            return `操作失敗: ${error.message || '未知錯誤'}`;
    }
}

/**
 * 顯示錯誤訊息給使用者
 * @param {Error|string} error - 錯誤物件或錯誤訊息
 * @param {string} context - 錯誤發生的上下文（可選）
 */
export function showUserFriendlyError(error, context = '') {
    let message = '';
    
    if (typeof error === 'string') {
        message = error;
    } else if (error && error.message) {
        // 如果是 Firebase 錯誤，使用專門的解析函數
        if (error.code) {
            message = parseFirebaseError(error);
        } else {
            message = error.message;
        }
    } else {
        message = "發生未知錯誤，請稍後再試";
    }
    
    // 如果有上下文資訊，添加到訊息中
    if (context) {
        message = `[${context}] ${message}`;
    }
    
    // 顯示錯誤訊息給使用者
    alert(message);
}

/**
 * 處理 Firestore 儲存操作的錯誤
 * @param {Error} error - 錯誤物件
 * @param {string} operation - 操作類型（如 "儲存產品資訊"、"儲存價格記錄"）
 * @returns {string} 使用者友好的錯誤訊息
 */
export function handleFirestoreSaveError(error, operation = '儲存資料') {
    const userMessage = parseFirebaseError(error);
    const fullMessage = `${operation}失敗: ${userMessage}`;
    
    console.error(`[${operation}錯誤]`, error);
    return fullMessage;
}

// 建立一個導出物件而不是匿名導出
const errorHandler = {
    parseFirebaseError,
    showUserFriendlyError,
    handleFirestoreSaveError
};

export default errorHandler;
</file>

<file path="utils/errorHandler.test.js">
/**
 * 錯誤處理工具的測試檔案
 */

import { parseFirebaseError, handleFirestoreSaveError } from './errorHandler';

// 模擬 Firebase 錯誤物件
const mockFirebaseErrors = [
    { code: 'permission-denied', message: 'Missing or insufficient permissions.' },
    { code: 'unavailable', message: 'The service is currently unavailable.' },
    { code: 'deadline-exceeded', message: 'Deadline exceeded.' },
    { code: 'unknown', message: 'Network error' },
    { code: 'internal', message: 'Internal server error' }
];

// 測試 parseFirebaseError 函數
console.log('測試 parseFirebaseError 函數:');
mockFirebaseErrors.forEach((error, index) => {
    const result = parseFirebaseError(error);
    console.log(`測試 ${index + 1}:`, result);
});

// 測試 handleFirestoreSaveError 函數
console.log('\n測試 handleFirestoreSaveError 函數:');
const testError = { code: 'permission-denied', message: 'Missing or insufficient permissions.' };
const result = handleFirestoreSaveError(testError, "儲存產品資訊");
console.log('結果:', result);

console.log('\n所有測試完成');
</file>

<file path="utils/priceCalculations.js">
export const calculateUnitPrice = (price, quantity, unitType) => {
  const p = parseFloat(price);
  const q = parseFloat(quantity);
  if (isNaN(p) || isNaN(q) || q <= 0) {
    return null;
  }
  // 對於 'g' 或 'ml'，計算每 100 單位的價格
  return (unitType === 'g' || unitType === 'ml') ? (p / q) * 100 : p / q;
};

// 新增一個函數來根據原價和特價計算最終價格
export const calculateFinalPrice = (originalPrice, specialPrice) => {
  // 如果有特價，則優先使用特價
  if (specialPrice && !isNaN(parseFloat(specialPrice))) {
    return parseFloat(specialPrice);
  }
  // 否則使用原價
  if (originalPrice && !isNaN(parseFloat(originalPrice))) {
    return parseFloat(originalPrice);
  }
  // 如果都沒有，返回 0
  return 0;
};

/**
 * 安全地格式化單價顯示
 * @param {number|null|undefined} unitPrice - 單價值
 * @returns {string} 格式化後的單價字符串
 */
export const formatUnitPrice = (unitPrice) => {
  // 檢查值是否存在且不為 null 或 undefined
  if (unitPrice == null) {
    return '--';
  }
  
  // 檢查值是否為有效數字
  const parsedUnitPrice = parseFloat(unitPrice);
  if (isNaN(parsedUnitPrice)) {
    return '--';
  }
  
  // 檢查是否為 0
  if (parsedUnitPrice === 0) {
    return '--';
  }
  
  // 返回格式化後的價格
  return parsedUnitPrice.toFixed(2);
};
</file>

</files>
</file>

<file path="StoreSelector.js">
import React, { useState, useEffect, useCallback } from 'react';
import { X } from 'lucide-react';
import { db } from './firebase-config';
import { collection, getDocs, addDoc, query, where, serverTimestamp, doc, updateDoc } from 'firebase/firestore';

const initialStores = [
    { name: "全聯", sort: 1 },
    { name: "大全聯", sort: 2 },
    { name: "家樂福", sort: 3 },
    { name: "7-11", sort: 4 }, 
    { name: "全家", sort: 5 },
    { name: "萊爾富", sort: 6 }, 
    { name: "好市多", sort: 7 }, 
    { name: "屈臣氏", sort: 8 }, 
    { name: "康是美", sort: 9 },
    { name: "美廉社", sort: 10 }, 
    { name: "愛買", sort: 11 },
    { name: "其他", sort: 999 }
];

function StoreSelector({ theme, onSelect, onClose }) {
    const [selectedStore, setSelectedStore] = useState('');
    const [otherStore, setOtherStore] = useState('');
    const [commonStores, setCommonStores] = useState([]);
    const [loading, setLoading] = useState(true);

    const fetchStores = useCallback(async () => {
        setLoading(true);
        try {
            const storesCollection = collection(db, 'stores');
            let querySnapshot = await getDocs(storesCollection);

            if (querySnapshot.empty) {
                const batch = initialStores.map(store => 
                    addDoc(storesCollection, { ...store, createdAt: serverTimestamp() })
                );
                await Promise.all(batch);
                querySnapshot = await getDocs(storesCollection);
            } else {
                // --- Start of new migration logic ---
                const storesFromDb = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const updates = [];

                for (const initialStore of initialStores) {
                    const dbStore = storesFromDb.find(s => s.name === initialStore.name);
                    // If the store exists in DB but the sort order is different from the code
                    if (dbStore && dbStore.sort !== initialStore.sort) {
                        const storeRef = doc(db, 'stores', dbStore.id);
                        updates.push(updateDoc(storeRef, { sort: initialStore.sort }));
                    }
                }

                // If there are any updates to perform
                if (updates.length > 0) {
                    console.log(`Updating sort order for ${updates.length} stores...`);
                    await Promise.all(updates);
                    // Re-fetch the data after updates to ensure we have the latest version
                    querySnapshot = await getDocs(storesCollection);
                    console.log("Store sort order updated successfully.");
                }
                // --- End of new migration logic ---
            }

            const storesList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const uniqueStores = Array.from(new Map(storesList.map(store => [store.name, store])).values());
            const sortedStores = uniqueStores.sort((a, b) => (a.sort || 999) - (b.sort || 999));
            
            setCommonStores(sortedStores);

        } catch (error) {
            console.error("Firebase Error in fetchStores:", error);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchStores();
    }, [fetchStores]);

    const handleSelect = async () => {
        if (selectedStore === '其他' && otherStore.trim() === '') {
            alert('請輸入其他商店名稱');
            return;
        }
        
        let finalStoreName = selectedStore === '其他' ? otherStore.trim() : selectedStore;

        if (selectedStore === '其他') {
            const storesCollection = collection(db, 'stores');
            const q = query(storesCollection, where("name", "==", finalStoreName));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                await addDoc(storesCollection, {
                    name: finalStoreName,
                    sort: 1000, 
                    createdAt: serverTimestamp()
                });
            }
        }
        
        onSelect(finalStoreName);
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-[60] flex items-center justify-center p-4 sm:p-6">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-[calc(100%-80px)] sm:max-w-md flex flex-col max-h-[80vh] h-auto">
                <div className="p-6 pb-4 flex-shrink-0">
                    <div className="flex justify-between items-center mb-4 border-b pb-2">
                        <h3 className={`text-xl font-bold ${theme.text}`}>
                            選擇商店
                        </h3>
                        <button 
                            onClick={onClose}
                            className="p-1 rounded-full text-gray-500 hover:text-gray-900"
                        >
                            <X className="w-6 h-6" />
                        </button>
                    </div>
                    <p className="text-gray-600">請選擇或輸入商店名稱：</p>
                </div>

                {loading ? (
                    <div className="flex-grow flex justify-center items-center">
                        <p className="text-gray-600">正在從資料庫載入商店列表...</p>
                    </div>
                ) : (
                    <div className="flex-grow overflow-y-auto px-6">
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 py-1">
                            {commonStores.map((store) => (
                                <button
                                    key={store.id}
                                    onClick={() => setSelectedStore(store.name)}
                                    className={`p-3 rounded-lg text-center font-medium transition-all ${
                                        selectedStore === store.name 
                                            ? `${themePrimary} text-white shadow-md` 
                                            : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                                    }`}
                                >
                                    {store.name}
                                </button>
                            ))}
                        </div>
                    </div>
                )}

                <div className="p-6 pt-4 flex-shrink-0">
                    {selectedStore === '其他' && (
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-2">請輸入商店名稱：</label>
                            <input
                                type="text"
                                value={otherStore}
                                onChange={(e) => setOtherStore(e.target.value)}
                                placeholder="輸入商店名稱"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"
                            />
                        </div>
                    )}

                    <div className="flex justify-end space-x-3 pt-4 border-t">
                        <button
                            onClick={onClose}
                            className="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-lg hover:bg-gray-600 transition-all"
                        >
                            取消
                        </button>
                        <button
                            onClick={handleSelect}
                            disabled={loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')}
                            className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg transition-all ${
                                loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : `${themePrimary} ${themeHover}`
                            }`}
                        >
                            確認選擇
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}

export default StoreSelector;
</file>

<file path="utils/errorHandler.js">
/**
 * 全域錯誤處理工具函數
 * 提供更具體的錯誤訊息給使用者
 */

/**
 * 解析 Firebase 錯誤並返回使用者友好的錯誤訊息
 * @param {Error} error - Firebase 錯誤物件
 * @returns {string} 使用者友好的錯誤訊息
 */
export function parseFirebaseError(error) {
    if (!error || !error.code) {
        return "發生未知錯誤，請稍後再試";
    }

    // 根據 Firebase 錯誤碼提供具體的錯誤訊息
    switch (error.code) {
        case 'permission-denied':
            return "權限不足，無法儲存資料。請聯繫系統管理員";
        
        case 'unavailable':
            return "Firebase 服務暫時無法使用，請檢查網路連線後再試";
            
        case 'deadline-exceeded':
            return "請求超時，請檢查網路連線後再試";
            
        case 'resource-exhausted':
            return "系統資源已滿，請稍後再試";
            
        case 'failed-precondition':
            return "資料格式錯誤，無法儲存";
            
        case 'aborted':
            return "操作被中斷，請重新嘗試";
            
        case 'out-of-range':
            return "資料超出允許範圍";
            
        case 'unimplemented':
            return "此功能尚未實作";
            
        case 'internal':
            return "系統內部錯誤，請稍後再試";
            
        case 'data-loss':
            return "資料遺失，請重新輸入";
            
        case 'unauthenticated':
            return "身份驗證失敗，請重新整理頁面";
            
        default:
            // 對於其他錯誤，提供通用但具體的訊息
            if (error.message.includes('offline') || error.message.includes('network')) {
                return "網路連線異常，請檢查網路設定後再試";
            }
            if (error.message.includes('quota')) {
                return "超過使用配額，請稍後再試";
            }
            return `操作失敗: ${error.message || '未知錯誤'}`;
    }
}

/**
 * 顯示錯誤訊息給使用者
 * @param {Error|string} error - 錯誤物件或錯誤訊息
 * @param {string} context - 錯誤發生的上下文（可選）
 */
export function showUserFriendlyError(error, context = '') {
    let message = '';
    
    if (typeof error === 'string') {
        message = error;
    } else if (error && error.message) {
        // 如果是 Firebase 錯誤，使用專門的解析函數
        if (error.code) {
            message = parseFirebaseError(error);
        } else {
            message = error.message;
        }
    } else {
        message = "發生未知錯誤，請稍後再試";
    }
    
    // 如果有上下文資訊，添加到訊息中
    if (context) {
        message = `[${context}] ${message}`;
    }
    
    // 顯示錯誤訊息給使用者
    alert(message);
}

/**
 * 處理 Firestore 儲存操作的錯誤
 * @param {Error} error - 錯誤物件
 * @param {string} operation - 操作類型（如 "儲存產品資訊"、"儲存價格記錄"）
 * @returns {string} 使用者友好的錯誤訊息
 */
export function handleFirestoreSaveError(error, operation = '儲存資料') {
    const userMessage = parseFirebaseError(error);
    const fullMessage = `${operation}失敗: ${userMessage}`;
    
    console.error(`[${operation}錯誤]`, error);
    return fullMessage;
}

// 建立一個導出物件而不是匿名導出
const errorHandler = {
    parseFirebaseError,
    showUserFriendlyError,
    handleFirestoreSaveError
};

export default errorHandler;
</file>

<file path="utils/errorHandler.test.js">
/**
 * 錯誤處理工具的測試檔案
 */

import { parseFirebaseError, handleFirestoreSaveError } from './errorHandler';

// 模擬 Firebase 錯誤物件
const mockFirebaseErrors = [
    { code: 'permission-denied', message: 'Missing or insufficient permissions.' },
    { code: 'unavailable', message: 'The service is currently unavailable.' },
    { code: 'deadline-exceeded', message: 'Deadline exceeded.' },
    { code: 'unknown', message: 'Network error' },
    { code: 'internal', message: 'Internal server error' }
];

// 測試 parseFirebaseError 函數
console.log('測試 parseFirebaseError 函數:');
mockFirebaseErrors.forEach((error, index) => {
    const result = parseFirebaseError(error);
    console.log(`測試 ${index + 1}:`, result);
});

// 測試 handleFirestoreSaveError 函數
console.log('\n測試 handleFirestoreSaveError 函數:');
const testError = { code: 'permission-denied', message: 'Missing or insufficient permissions.' };
const result = handleFirestoreSaveError(testError, "儲存產品資訊");
console.log('結果:', result);

console.log('\n所有測試完成');
</file>

<file path="utils/priceCalculations.js">
export const calculateUnitPrice = (price, quantity, unitType) => {
  const p = parseFloat(price);
  const q = parseFloat(quantity);
  if (isNaN(p) || isNaN(q) || q <= 0) {
    return null;
  }
  // 對於 'g' 或 'ml'，計算每 100 單位的價格
  return (unitType === 'g' || unitType === 'ml') ? (p / q) * 100 : p / q;
};

// 新增一個函數來根據原價和特價計算最終價格
export const calculateFinalPrice = (originalPrice, specialPrice) => {
  // 如果有特價，則優先使用特價
  if (specialPrice && !isNaN(parseFloat(specialPrice))) {
    return parseFloat(specialPrice);
  }
  // 否則使用原價
  if (originalPrice && !isNaN(parseFloat(originalPrice))) {
    return parseFloat(originalPrice);
  }
  // 如果都沒有，返回 0
  return 0;
};

/**
 * 安全地格式化單價顯示
 * @param {number|null|undefined} unitPrice - 單價值
 * @returns {string} 格式化後的單價字符串
 */
export const formatUnitPrice = (unitPrice) => {
  // 檢查值是否存在且不為 null 或 undefined
  if (unitPrice == null) {
    return '--';
  }
  
  // 檢查值是否為有效數字
  const parsedUnitPrice = parseFloat(unitPrice);
  if (isNaN(parsedUnitPrice)) {
    return '--';
  }
  
  // 檢查是否為 0
  if (parsedUnitPrice === 0) {
    return '--';
  }
  
  // 返回格式化後的價格
  return parsedUnitPrice.toFixed(2);
};
</file>

</files>
</file>

<file path="StoreSelector.js">
import React, { useState, useEffect, useCallback } from 'react';
import { X } from 'lucide-react';
import { db } from './firebase-config';
import { collection, getDocs, addDoc, query, where, serverTimestamp, doc, updateDoc } from 'firebase/firestore';

const initialStores = [
    { name: "全聯", sort: 1 },
    { name: "大全聯", sort: 2 },
    { name: "家樂福", sort: 3 },
    { name: "7-11", sort: 4 }, 
    { name: "全家", sort: 5 },
    { name: "萊爾富", sort: 6 }, 
    { name: "好市多", sort: 7 }, 
    { name: "屈臣氏", sort: 8 }, 
    { name: "康是美", sort: 9 },
    { name: "美廉社", sort: 10 }, 
    { name: "愛買", sort: 11 },
    { name: "其他", sort: 999 }
];

function StoreSelector({ theme, onSelect, onClose }) {
    const [selectedStore, setSelectedStore] = useState('');
    const [otherStore, setOtherStore] = useState('');
    const [commonStores, setCommonStores] = useState([]);
    const [loading, setLoading] = useState(true);

    const fetchStores = useCallback(async () => {
        setLoading(true);
        try {
            const storesCollection = collection(db, 'stores');
            let querySnapshot = await getDocs(storesCollection);

            if (querySnapshot.empty) {
                const batch = initialStores.map(store => 
                    addDoc(storesCollection, { ...store, createdAt: serverTimestamp() })
                );
                await Promise.all(batch);
                querySnapshot = await getDocs(storesCollection);
            } else {
                // --- Start of new migration logic ---
                const storesFromDb = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const updates = [];

                for (const initialStore of initialStores) {
                    const dbStore = storesFromDb.find(s => s.name === initialStore.name);
                    // If the store exists in DB but the sort order is different from the code
                    if (dbStore && dbStore.sort !== initialStore.sort) {
                        const storeRef = doc(db, 'stores', dbStore.id);
                        updates.push(updateDoc(storeRef, { sort: initialStore.sort }));
                    }
                }

                // If there are any updates to perform
                if (updates.length > 0) {
                    console.log(`Updating sort order for ${updates.length} stores...`);
                    await Promise.all(updates);
                    // Re-fetch the data after updates to ensure we have the latest version
                    querySnapshot = await getDocs(storesCollection);
                    console.log("Store sort order updated successfully.");
                }
                // --- End of new migration logic ---
            }

            const storesList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const uniqueStores = Array.from(new Map(storesList.map(store => [store.name, store])).values());
            const sortedStores = uniqueStores.sort((a, b) => (a.sort || 999) - (b.sort || 999));
            
            setCommonStores(sortedStores);

        } catch (error) {
            console.error("Firebase Error in fetchStores:", error);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchStores();
    }, [fetchStores]);

    const handleSelect = async () => {
        if (selectedStore === '其他' && otherStore.trim() === '') {
            alert('請輸入其他商店名稱');
            return;
        }
        
        let finalStoreName = selectedStore === '其他' ? otherStore.trim() : selectedStore;

        if (selectedStore === '其他') {
            const storesCollection = collection(db, 'stores');
            const q = query(storesCollection, where("name", "==", finalStoreName));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                await addDoc(storesCollection, {
                    name: finalStoreName,
                    sort: 1000, 
                    createdAt: serverTimestamp()
                });
            }
        }
        
        onSelect(finalStoreName);
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-[60] flex items-center justify-center p-4 sm:p-6">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-[calc(100%-80px)] sm:max-w-md flex flex-col max-h-[80vh] h-auto">
                <div className="p-6 pb-4 flex-shrink-0">
                    <div className="flex justify-between items-center mb-4 border-b pb-2">
                        <h3 className={`text-xl font-bold ${theme.text}`}>
                            選擇商店
                        </h3>
                        <button 
                            onClick={onClose}
                            className="p-1 rounded-full text-gray-500 hover:text-gray-900"
                        >
                            <X className="w-6 h-6" />
                        </button>
                    </div>
                    <p className="text-gray-600">請選擇或輸入商店名稱：</p>
                </div>

                {loading ? (
                    <div className="flex-grow flex justify-center items-center">
                        <p className="text-gray-600">正在從資料庫載入商店列表...</p>
                    </div>
                ) : (
                    <div className="flex-grow overflow-y-auto px-6">
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 py-1">
                            {commonStores.map((store) => (
                                <button
                                    key={store.id}
                                    onClick={() => setSelectedStore(store.name)}
                                    className={`p-3 rounded-lg text-center font-medium transition-all ${
                                        selectedStore === store.name 
                                            ? `${themePrimary} text-white shadow-md` 
                                            : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                                    }`}
                                >
                                    {store.name}
                                </button>
                            ))}
                        </div>
                    </div>
                )}

                <div className="p-6 pt-4 flex-shrink-0">
                    {selectedStore === '其他' && (
                        <div className="mb-4">
                            <label className="block text-gray-700 font-medium mb-2">請輸入商店名稱：</label>
                            <input
                                type="text"
                                value={otherStore}
                                onChange={(e) => setOtherStore(e.target.value)}
                                placeholder="輸入商店名稱"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"
                                autoFocus
                            />
                        </div>
                    )}

                    <div className="flex justify-end space-x-3 pt-4 border-t">
                        <button
                            onClick={onClose}
                            className="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-lg hover:bg-gray-600 transition-all"
                        >
                            取消
                        </button>
                        <button
                            onClick={handleSelect}
                            disabled={loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')}
                            className={`px-4 py-2 text-white font-semibold rounded-lg shadow-lg transition-all ${
                                loading || !selectedStore || (selectedStore === '其他' && otherStore.trim() === '')
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : `${themePrimary} ${themeHover}`
                            }`}
                        >
                            確認選擇
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}

export default StoreSelector;
</file>

<file path="utils/errorHandler.js">
/**
 * 全域錯誤處理工具函數
 * 提供更具體的錯誤訊息給使用者
 */

/**
 * 解析 Firebase 錯誤並返回使用者友好的錯誤訊息
 * @param {Error} error - Firebase 錯誤物件
 * @returns {string} 使用者友好的錯誤訊息
 */
export function parseFirebaseError(error) {
    if (!error || !error.code) {
        return "發生未知錯誤，請稍後再試";
    }

    // 根據 Firebase 錯誤碼提供具體的錯誤訊息
    switch (error.code) {
        case 'permission-denied':
            return "權限不足，無法儲存資料。請聯繫系統管理員";
        
        case 'unavailable':
            return "Firebase 服務暫時無法使用，請檢查網路連線後再試";
            
        case 'deadline-exceeded':
            return "請求超時，請檢查網路連線後再試";
            
        case 'resource-exhausted':
            return "系統資源已滿，請稍後再試";
            
        case 'failed-precondition':
            return "資料格式錯誤，無法儲存";
            
        case 'aborted':
            return "操作被中斷，請重新嘗試";
            
        case 'out-of-range':
            return "資料超出允許範圍";
            
        case 'unimplemented':
            return "此功能尚未實作";
            
        case 'internal':
            return "系統內部錯誤，請稍後再試";
            
        case 'data-loss':
            return "資料遺失，請重新輸入";
            
        case 'unauthenticated':
            return "身份驗證失敗，請重新整理頁面";
            
        default:
            // 對於其他錯誤，提供通用但具體的訊息
            if (error.message.includes('offline') || error.message.includes('network')) {
                return "網路連線異常，請檢查網路設定後再試";
            }
            if (error.message.includes('quota')) {
                return "超過使用配額，請稍後再試";
            }
            return `操作失敗: ${error.message || '未知錯誤'}`;
    }
}

/**
 * 顯示錯誤訊息給使用者
 * @param {Error|string} error - 錯誤物件或錯誤訊息
 * @param {string} context - 錯誤發生的上下文（可選）
 */
export function showUserFriendlyError(error, context = '') {
    let message = '';
    
    if (typeof error === 'string') {
        message = error;
    } else if (error && error.message) {
        // 如果是 Firebase 錯誤，使用專門的解析函數
        if (error.code) {
            message = parseFirebaseError(error);
        } else {
            message = error.message;
        }
    } else {
        message = "發生未知錯誤，請稍後再試";
    }
    
    // 如果有上下文資訊，添加到訊息中
    if (context) {
        message = `[${context}] ${message}`;
    }
    
    // 顯示錯誤訊息給使用者
    alert(message);
}

/**
 * 處理 Firestore 儲存操作的錯誤
 * @param {Error} error - 錯誤物件
 * @param {string} operation - 操作類型（如 "儲存產品資訊"、"儲存價格記錄"）
 * @returns {string} 使用者友好的錯誤訊息
 */
export function handleFirestoreSaveError(error, operation = '儲存資料') {
    const userMessage = parseFirebaseError(error);
    const fullMessage = `${operation}失敗: ${userMessage}`;
    
    console.error(`[${operation}錯誤]`, error);
    return fullMessage;
}

// 建立一個導出物件而不是匿名導出
const errorHandler = {
    parseFirebaseError,
    showUserFriendlyError,
    handleFirestoreSaveError
};

export default errorHandler;
</file>

<file path="utils/errorHandler.test.js">
/**
 * 錯誤處理工具的測試檔案
 */

import { parseFirebaseError, handleFirestoreSaveError } from './errorHandler';

// 模擬 Firebase 錯誤物件
const mockFirebaseErrors = [
    { code: 'permission-denied', message: 'Missing or insufficient permissions.' },
    { code: 'unavailable', message: 'The service is currently unavailable.' },
    { code: 'deadline-exceeded', message: 'Deadline exceeded.' },
    { code: 'unknown', message: 'Network error' },
    { code: 'internal', message: 'Internal server error' }
];

// 測試 parseFirebaseError 函數
console.log('測試 parseFirebaseError 函數:');
mockFirebaseErrors.forEach((error, index) => {
    const result = parseFirebaseError(error);
    console.log(`測試 ${index + 1}:`, result);
});

// 測試 handleFirestoreSaveError 函數
console.log('\n測試 handleFirestoreSaveError 函數:');
const testError = { code: 'permission-denied', message: 'Missing or insufficient permissions.' };
const result = handleFirestoreSaveError(testError, "儲存產品資訊");
console.log('結果:', result);

console.log('\n所有測試完成');
</file>

<file path="utils/priceCalculations.js">
export const calculateUnitPrice = (price, quantity, unitType) => {
  const p = parseFloat(price);
  const q = parseFloat(quantity);
  if (isNaN(p) || isNaN(q) || q <= 0) {
    return null;
  }
  // 對於 'g' 或 'ml'，計算每 100 單位的價格
  return (unitType === 'g' || unitType === 'ml') ? (p / q) * 100 : p / q;
};

// 新增一個函數來根據原價和特價計算最終價格
export const calculateFinalPrice = (originalPrice, specialPrice) => {
  // 如果有特價，則優先使用特價
  if (specialPrice && !isNaN(parseFloat(specialPrice))) {
    return parseFloat(specialPrice);
  }
  // 否則使用原價
  if (originalPrice && !isNaN(parseFloat(originalPrice))) {
    return parseFloat(originalPrice);
  }
  // 如果都沒有，返回 0
  return 0;
};

/**
 * 安全地格式化單價顯示
 * @param {number|null|undefined} unitPrice - 單價值
 * @returns {string} 格式化後的單價字符串
 */
export const formatUnitPrice = (unitPrice) => {
  // 檢查值是否存在且不為 null 或 undefined
  if (unitPrice == null) {
    return '--';
  }
  
  // 檢查值是否為有效數字
  const parsedUnitPrice = parseFloat(unitPrice);
  if (isNaN(parsedUnitPrice)) {
    return '--';
  }
  
  // 檢查是否為 0
  if (parsedUnitPrice === 0) {
    return '--';
  }
  
  // 返回格式化後的價格
  return parsedUnitPrice.toFixed(2);
};
</file>

</files>
