This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
components.xml
DataManagement.js
SettingsPage.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="components.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AIOcrCaptureModal.js
AIOcrCaptureModal備份
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AIOcrCaptureModal.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap, RotateCcw } from 'lucide-react';
import { showUserFriendlyError } from '../utils/errorHandler'; // 導入錯誤處理工具

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream, onQueueNextCapture }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);
    const streamRef = useRef(stream); // 添加這一行來保持對 stream 的引用

    // 更新 useEffect 以處理 stream 變化
    useEffect(() => {
        streamRef.current = stream; // 更新 streamRef 的值
        if (stream && videoRef.current) {
            videoRef.current.srcObject = stream;
            // 只有在沒有捕獲圖片時才自動播放
            if (!capturedImage) {
                videoRef.current.play().catch(err => {
                    console.error("Video play failed:", err);
                    setScanError("無法播放相機影像。");
                });
            }
        }
    }, [stream, capturedImage]);

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Clear the captured image and error, and restart the video stream
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
        
        // Manually play the video stream when retaking
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
        setScanError(userMessage);
        showUserFriendlyError(userMessage, "AI 分析");
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleAnalyzeAndCaptureNext = useCallback(() => {
        if (!capturedImage) { 
            setScanError("沒有可分析的影像。"); 
            return; 
        }
        
        // 立即清除捕獲的圖像並重新啟動相機，讓用戶可以繼續拍攝
        setCapturedImage(null);
        setScanError('');
        
        // 重新啟動相機流
        if (streamRef.current && videoRef.current) {
            videoRef.current.srcObject = streamRef.current;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
        
        // 準備 API 請求參數
        const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        
        // 在後台執行分析
        withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl))
            .then(analysisResult => {
                console.log("AI Analysis Result:", analysisResult);
                
                // 計算並添加單價欄位
                const { 
                    scannedBarcode = '', 
                    productName = '', 
                    listedPrice = 0, 
                    totalCapacity = 0, 
                    baseUnit = 'pcs', 
                    storeName = 'AI 辨識', 
                    discountDetails = '',
                    specialPrice = null,
                    originalPrice = null
                } = analysisResult;
                let unitPrice = 0;
                if (listedPrice > 0 && totalCapacity > 0) {
                     if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據
                const finalData = {
                    scannedBarcode: scannedBarcode,
                    productName: productName,
                    extractedPrice: listedPrice.toString(),
                    storeName: storeName,
                    discountDetails: discountDetails,
                    quantity: totalCapacity.toString(),
                    unitType: baseUnit,
                    unitPrice: unitPrice,
                    specialPrice: specialPrice,
                    originalPrice: originalPrice,
                    capturedImage: capturedImage  // 添加捕獲的圖像
                };
                
                // 通知父組件將完整分析結果加入序列
                onQueueNextCapture(finalData);
            })
            .catch(error => {
                console.error("AI 分析失敗:", error);
                const userMessage = `AI 分析錯誤: ${error.message || '未知錯誤'}`;
                setScanError(userMessage);
                showUserFriendlyError(userMessage, "AI 分析");
                
                // 即使分析失敗，也將基本數據加入序列，讓用戶知道有錯誤
                const errorData = {
                    capturedImage: capturedImage,
                    error: error.message
                };
                onQueueNextCapture(errorData);
            });
    }, [capturedImage, onQueueNextCapture]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}><RotateCcw className="w-5 h-5 mr-2" />重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    {capturedImage && !scanError && (
                        <button onClick={handleAnalyzeAndCaptureNext} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all bg-green-600 hover:bg-green-700 flex items-center justify-center`} disabled={isAnalyzing}>
                            <Zap className="w-5 h-5 mr-2" /><Camera className="w-5 h-5 mr-2" />進行分析並拍攝下一張
                        </button>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

<file path="AIOcrCaptureModal備份">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { X, Camera, Zap } from 'lucide-react';

const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            const currentDelay = delay; // Capture current delay
            await new Promise(resolve => setTimeout(resolve, currentDelay));
            delay *= 2;
        }
    }
};

async function callGeminiApiWithRetry(payload, apiUrl, maxRetries = 3) {
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API response error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const jsonText = candidate.content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", jsonText, parseError);
                    throw new Error("AI 輸出格式錯誤，無法解析 JSON。");
                }
            } else {
                throw new Error("AI 無法生成有效內容。");
            }

        } catch (error) {
            lastError = error;
            console.warn(`API call failed (Attempt ${i + 1}/${maxRetries}):`, error.message);
            if (i < maxRetries - 1) {
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    throw lastError;
}

function AIOcrCaptureModal({ theme, onAnalysisSuccess, onClose, stream }) {
    const videoRef = useRef(null);
    const [scanError, setScanError] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [capturedImage, setCapturedImage] = useState(null);

    useEffect(() => {
        // This effect handles starting the video stream when the modal opens
        // or when the user clicks "Retake".
        if (stream && videoRef.current && !capturedImage) {
            videoRef.current.srcObject = stream;
            videoRef.current.play().catch(err => {
                console.error("Video play failed:", err);
                setScanError("無法播放相機影像。");
            });
        }
    }, [stream, capturedImage]); // Re-run when stream is available or image is cleared

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !videoRef.current.srcObject) return;
        const video = videoRef.current;
        const canvas = document.createElement('canvas');
        const sWidth = video.videoWidth * 0.75;
        const sHeight = video.videoHeight * 0.75;
        const sx = (video.videoWidth - sWidth) / 2;
        const sy = (video.videoHeight - sHeight) / 2;

        canvas.width = sWidth;
        canvas.height = sHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        const base64Data = canvas.toDataURL('image/jpeg', 0.9);
        setCapturedImage(base64Data); // 設置擷取的圖片
        
        // Pause video playback after capture, but don't stop the stream
        if (videoRef.current) {
            videoRef.current.pause();
        }
    }, []);

    const handleRetake = useCallback(() => {
        // Simply clear the captured image. The useEffect will handle restarting the video.
        setCapturedImage(null);
        setScanError('');
        setIsAnalyzing(false);
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!capturedImage) { setScanError("沒有可分析的影像。"); return; }
        setIsAnalyzing(true);
        setScanError('');
        try {
            const base64Image = capturedImage.split(',')[1];
        
        const userQuery = "請根據圖片中的條碼、標價、產品名稱、規格（質量/容量/數量）、商店名稱和折扣資訊，以嚴格的 JSON 格式輸出結構化數據。請特別注意計算產品的總容量/總質量。如果圖像中顯示了原價和特價，請分別標註。";

        const newSchema = {
            type: "OBJECT",
            properties: {
                scannedBarcode: { "type": "STRING", "description": "影像中找到的 EAN, UPC 或其他產品條碼數字，如果不可見則為空字串。" },
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                originalPrice: { "type": "NUMBER", "description": "產品的原價（純數字，例如 59），如果沒有原價則為空。" },
                specialPrice: { "type": "NUMBER", "description": "產品的特價（純數字，例如 39），如果沒有特價則為空。" },
                listedPrice: { "type": "NUMBER", "description": "產品標價（純數字，例如 59），如果沒有單一標價則為空。當有特價時，listedPrice 應為特價；當無特價時，listedPrice 應為原價。" },
                totalCapacity: { "type": "NUMBER", "description": "產品的總容量/總質量/總數量（純數字）。例如：若產品是 '18克10入'，則總容量是 180；若產品是 '2000ml'，則總容量是 2000。" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" },
                storeName: { "type": "STRING", "description": "價目標籤或收據所示的商店名稱。如果不可見則為空字串。" },
                discountDetails: { "type": "STRING", "description": "發現的任何促銷或折扣的詳細描述（例如：'買一送一', '第二件半價', '有效期限 2026/01/01'）。如果沒有折扣則為空字串。" }
            },
            propertyOrdering: ["scannedBarcode", "productName", "originalPrice", "specialPrice", "listedPrice", "totalCapacity", "baseUnit", "storeName", "discountDetails"]
        };
        
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中識別產品條碼、產品名稱、標價、完整的容量/質量/數量資訊、商店名稱和折扣細節，並將其格式化為嚴格的 JSON 輸出。
            **計算規則（重要）：**
            1. 標價 (listedPrice) 必須是純數字。
            2. 總容量 (totalCapacity) 必須是純數字。
            3. 如果產品標示為「X 克 Y 入」，**必須**計算總質量： totalCapacity = X * Y。例如：「18克10入」-> 180。
            4. 如果產品標示為「X 毫升 Y 瓶」，**必須**計算總容量： totalCapacity = X * Y。
            5. 如果產品標示為「Z 個」，則 totalCapacity = Z。
            6. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            7. 如果圖像中同時顯示原價和特價：
               - originalPrice 應包含原價數值
               - specialPrice 應包含特價數值
               - listedPrice 應包含特價數值（因為這是消費者實際支付的價格）
            8. 如果圖像中只顯示一個價格：
               - listedPrice 應包含該價格數值
               - originalPrice 和 specialPrice 應為空
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `/.netlify/functions/gemini-proxy`;
        const payload = { systemPrompt, userPrompt: userQuery, base64Image, responseSchema: newSchema };
        const analysisResult = await withExponentialBackoff(() => callGeminiApiWithRetry(payload, apiUrl));
        console.log("AI Analysis Result:", analysisResult); // Added console.log for debugging

        // 計算並添加單價欄位 (從單價計算.txt 複製過來)
        const { 
            scannedBarcode = '', 
            productName = '', 
            listedPrice = 0, 
            totalCapacity = 0, 
            baseUnit = 'pcs', 
            storeName = 'AI 辨識', 
            discountDetails = '',
            specialPrice = null,
            originalPrice = null
        } = analysisResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
                unitPrice = (listedPrice / totalCapacity) * 100;
            } else if (baseUnit === 'pcs') {
                unitPrice = listedPrice / totalCapacity;
            }
        }
        
        // 準備傳遞給父組件的數據，包含計算出的單價和捕獲的圖像
        const finalData = {
            scannedBarcode: scannedBarcode,
            productName: productName,
            extractedPrice: listedPrice.toString(), // 轉換為字串以符合現有狀態
            storeName: storeName,
            discountDetails: discountDetails,
            quantity: totalCapacity.toString(), // 轉換為字串以符合現有狀態
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: specialPrice, // 保留特價信息
            originalPrice: originalPrice,  // 保留原價信息
            capturedImage: capturedImage  // 添加捕獲的圖像
        };

        onAnalysisSuccess(finalData);
        onClose();
    } catch (error) {
        console.error("AI 分析失敗:", error);
        setScanError(`AI 分析錯誤: ${error.message}`);
    } finally {
        setIsAnalyzing(false);
    }
}, [capturedImage, onAnalysisSuccess, onClose]);

    const handleSimulatedAnalysis = () => {
        const randomListedPrice = parseFloat((Math.random() * 50 + 100).toFixed(2));
        const randomTotalCapacity = Math.floor(Math.random() * 1000) + 100; // 100-1099
        const unitTypes = ['ml', 'g', 'pcs'];
        const randomBaseUnit = unitTypes[Math.floor(Math.random() * unitTypes.length)];
        
        // 模擬特價情況：20% 機率有特價
        const hasSpecialPrice = Math.random() < 0.2;
        let specialPrice = null;
        let finalListedPrice = randomListedPrice;
        
        if (hasSpecialPrice) {
            specialPrice = parseFloat((randomListedPrice * 0.8).toFixed(2)); // 8折特價
            finalListedPrice = specialPrice;
        }
        
        // 使用真實的產品標籤圖片
        const mockImageData = "/士力架.png";
        
        const mockResult = {
            productName: '士力架巧克力',
            listedPrice: finalListedPrice,
            totalCapacity: randomTotalCapacity,
            baseUnit: randomBaseUnit,
            // 以下是 AI 可能額外提供的資訊，如果 AI 模型能辨識
            scannedBarcode: '4710123456789',
            storeName: '模擬超商 (AI)',
            discountDetails: hasSpecialPrice ? '限時特價 8 折' : '買二送一優惠 / 限時促銷',
            specialPrice: specialPrice
        };

        // AIOcrCaptureModal 的 handleAnalyze 函數會處理這個 mockResult
        // 並計算 unitPrice，然後傳遞給 onAnalysisSuccess
        const { listedPrice, totalCapacity, baseUnit } = mockResult;
        let unitPrice = 0;
        if (listedPrice > 0 && totalCapacity > 0) {
             if (baseUnit === 'g' || baseUnit === 'ml') {
            unitPrice = (listedPrice / totalCapacity) * 100;
        } else if (baseUnit === 'pcs') {
            unitPrice = listedPrice / totalCapacity;
        }
    }

        const finalData = {
            scannedBarcode: mockResult.scannedBarcode || '',
            productName: mockResult.productName,
            extractedPrice: listedPrice.toString(),
            storeName: mockResult.storeName || 'AI 辨識',
            discountDetails: mockResult.discountDetails || '',
            quantity: totalCapacity.toString(),
            unitType: baseUnit,
            unitPrice: unitPrice,
            specialPrice: mockResult.specialPrice,
            capturedImage: mockImageData  // 添加真實的產品標籤圖片
        };

        onAnalysisSuccess(finalData);
        onClose();
    };

    const themePrimary = theme.primary;
    const themeHover = theme.hover;

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 transform transition-all flex flex-col items-center">
                <header className="flex justify-between items-center w-full mb-4 border-b pb-2">
                    <h3 className={`text-xl font-bold ${theme.text} flex items-center`}><Zap className="inline-block w-5 h-5 mr-2" />AI 視覺擷取與分析</h3>
                    <button onClick={onClose} className="p-1 rounded-full text-gray-500 hover:text-gray-900"><X className="w-6 h-6" /></button>
                </header>
                {isAnalyzing && <div className={`w-full p-4 mb-4 rounded-lg bg-yellow-100 text-yellow-800 flex items-center justify-center`}>...分析中...</div>}
                {scanError ? <div className="text-red-600 bg-red-100 p-4 rounded-lg w-full mb-4 text-center">{scanError}</div> : (
                    <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border-4 border-dashed border-white">
                        {capturedImage ? <img src={capturedImage} alt="Captured" className="w-full h-full object-cover" /> : <video ref={videoRef} className="w-full h-full object-cover" playsInline muted></video>}
                        {!capturedImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="w-[75%] h-[75%] border-4 border-yellow-400 border-opacity-75 rounded-lg shadow-lg"></div></div>}
                    </div>
                )}
                <div className="w-full">
                    {!capturedImage && !scanError && <button onClick={handleCapture} className={`w-full p-3 mb-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Camera className="inline-block w-5 h-5 mr-2" />擷取畫面</button>}
                    {capturedImage && !scanError && (
                        <div className="grid grid-cols-2 gap-4 mb-3">
                            <button onClick={handleRetake} className="w-full p-3 rounded-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold shadow-lg transition-all flex items-center justify-center" disabled={isAnalyzing}>重新拍攝</button>
                            <button onClick={handleAnalyze} className={`w-full p-3 rounded-lg text-white font-semibold shadow-lg transition-all ${themePrimary} ${themeHover} flex items-center justify-center`} disabled={isAnalyzing}><Zap className="w-5 h-5 mr-2" />開始 AI 分析</button>
                        </div>
                    )}
                    <button onClick={handleSimulatedAnalysis} className="w-full p-3 mb-3 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>模擬 AI 分析成功 (測試用)</button>
                    <button onClick={onClose} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-lg transition-all" disabled={isAnalyzing}>關閉</button>
                </div>
            </div>
        </div>
    );
}

export default AIOcrCaptureModal;
</file>

</files>
</file>

<file path="DataManagement.js">
import React, { useState } from 'react';
import { Trash2, AlertCircle, RefreshCw, FileText } from 'lucide-react'; // 導入 Lucide 圖示

// ----------------------------------------------------
// 【核心邏輯：讀取所有 LocalStorage 數據】
// ----------------------------------------------------
const getLocalStorageData = () => {
    const data = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        let parsedValue;
        let isJson = false;

        try {
            parsedValue = JSON.parse(value);
            isJson = true;
        } catch (e) {
            parsedValue = value;
        }

        data.push({
            key,
            value: isJson ? JSON.stringify(parsedValue, null, 2) : value, 
            size: (new TextEncoder().encode(value).length / 1024).toFixed(2), // KB
            type: isJson ? 'JSON' : 'String',
            count: isJson && Array.isArray(parsedValue) ? parsedValue.length : 1, 
        });
    }
    // 讓最大的佔用 Key 優先顯示
    return data.sort((a, b) => b.size - a.size); 
};

// ----------------------------------------------------
// 【DataManagement 元件】
// ----------------------------------------------------
const DataManagement = ({ onRefreshApp, themePrimary }) => {
    const [data, setData] = useState(getLocalStorageData());

    const handleClearKey = (key) => {
        if (window.confirm(`【警告】確定要清除 Key: ${key} 的數據嗎？這將會遺失該設定/數據。`)) {
            localStorage.removeItem(key);
            setData(getLocalStorageData()); // 刷新列表
            
            // 如果清除的 Key 影響了 App.js 的狀態 (例如 pendingOcrCards)，則通知 App 刷新
            if (onRefreshApp) {
                onRefreshApp(key);
            }
        }
    };
    
    // 一鍵清除所有 App 相關數據 (可根據 Key 前綴判斷)
    const handleClearAllAppData = () => {
         if (window.confirm('【極度警告】這將清除所有應用程式相關的本地數據。確定要繼續嗎？')) {
            // 這裡可以選擇性地只清除 App 相關的 Key，例如所有沒有特定前綴的
            // 由於我們不知道您的 Key 命名規則，最保險的做法是先讓用戶手動清除。
            // 或者： localStorage.clear(); (但這會清除所有網站數據，風險大)
            // 為了安全，我們讓用戶只能清除列表中的 Key。
            
            // 這裡實作一個安全的重設：只清除我們列出來的 key
            data.forEach(item => {
                 // 排除瀏覽器內部使用的 key，例如 'firebase:' 相關的
                 if (!item.key.startsWith('firebase:') && !item.key.startsWith('fbs_')) {
                    localStorage.removeItem(item.key);
                 }
            });
            setData(getLocalStorageData()); 
            if (onRefreshApp) onRefreshApp('ALL');
         }
    };


    return (
        <div className="p-4 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 flex items-center">
                <FileText className="w-5 h-5 mr-2 text-blue-600" />數據與儲存管理 (LocalStorage)
            </h3>
            <p className="text-sm text-gray-600 mb-4">
                這裡顯示應用程式儲存在瀏覽器中的本地數據。異常佔用問題通常由大型陣列 (如待辨識卡片) 未清理導致。
            </p>

            <button 
                onClick={() => setData(getLocalStorageData())} 
                className={`flex items-center p-2 rounded-lg text-sm text-white font-semibold mb-4 ${themePrimary} hover:opacity-90 transition-opacity`}
            >
                <RefreshCw className="w-4 h-4 mr-2" /> 刷新列表
            </button>
            
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">類型</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">大小 (KB)</th>
                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">項目數</th>
                            <th className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">動作</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                        {data.map((item) => (
                            <tr key={item.key} className={item.size > 100 ? 'bg-yellow-50/50' : ''}>
                                <td className="px-3 py-2 font-medium text-gray-900 break-all">{item.key}</td>
                                <td className="px-3 py-2 text-gray-600">{item.type}</td>
                                <td className="px-3 py-2 text-gray-600">
                                    {item.size} KB
                                    {item.size > 100 && <AlertCircle className="w-4 h-4 text-red-500 inline-block ml-1" title="高佔用警告" />}
                                </td>
                                <td className="px-3 py-2 text-gray-600">{item.count}</td>
                                <td className="px-3 py-2 text-center">
                                    <button 
                                        onClick={() => handleClearKey(item.key)} 
                                        className="text-red-600 hover:text-red-800 p-1 rounded transition-colors"
                                        title="清除此 Key 的數據"
                                    >
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* 進階：一鍵重設按鈕 */}
            <div className="mt-6 border-t pt-4">
                 <button onClick={handleClearAllAppData} className="w-full p-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors flex items-center justify-center">
                    <AlertCircle className="w-5 h-5 mr-2" /> 清除所有 App 相關本地數據 (軟重設)
                 </button>
            </div>
        </div>
    );
};

export default DataManagement;
</file>

<file path="SettingsPage.js">
import React from 'react';
import { X, Settings as SettingsIcon } from 'lucide-react';
import DataManagement from './DataManagement';

const SettingsPage = ({ theme, onClose, onDataChange }) => {
    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                {/* Header */}
                <div className={`flex justify-between items-center p-4 border-b ${theme.border}`}>
                    <h2 className={`text-xl font-bold ${theme.text} flex items-center`}>
                        <SettingsIcon className="w-5 h-5 mr-2" />
                        設定
                    </h2>
                    <button 
                        onClick={onClose}
                        className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                    >
                        <X className="w-5 h-5" />
                    </button>
                </div>
                
                {/* Content */}
                <div className="flex-grow overflow-y-auto p-4">
                    <DataManagement 
                        themePrimary={theme.primary}
                        onRefreshApp={onDataChange}
                    />
                </div>
                
                {/* Footer */}
                <div className="p-4 border-t bg-gray-50 flex justify-end">
                    <button 
                        onClick={onClose}
                        className={`px-4 py-2 rounded-lg font-medium ${theme.primary} text-white hover:opacity-90 transition-opacity`}
                    >
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
</file>

</files>
