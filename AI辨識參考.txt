import React, { useState, useEffect, useCallback } from 'react';

// 假設這些是您的主題顏色配置
const themeConfig = {
    'blue': { primary: 'indigo-600', hover: 'indigo-700', bg: 'indigo-50' },
    'red': { primary: 'red-600', hover: 'red-700', bg: 'red-50' },
    // ... 其他主題色
};

// 輔助函數：實現指數退避 (Exponential Backoff)
const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
        }
    }
};

// 輔助函數：從字串中提取數字 (例如: "$120.50" -> 120.50)
const cleanAndParseNumber = (str) => {
    if (typeof str !== 'string' || str === null || str === '') return 0;
    
    // 移除所有非數字、非小數點的字符 (保留負號以防萬一，但價格和容量應是非負的)
    // 這裡使用更保守的策略，移除貨幣符號和大部分非數字字元，然後解析
    const cleaned = str.replace(/[^\d.]/g, ''); 
    const num = parseFloat(cleaned);
    
    // 如果解析結果是 NaN (非數字)，則返回 0
    return isNaN(num) ? 0 : num;
};

// 輔助函數：從複雜字串計算總容量 (例如: "18克10入" -> 180)
const calculateTotalCapacity = (capacityString) => {
    if (typeof capacityString !== 'string') {
        return 0;
    }
    
    // 步驟 1: 處理複合格式 (X 單位 Y 入/瓶/袋)
    // 尋找 (數字A) (單位) (數字B) (入/瓶) 或 (數字A) x (數字B) 的模式
    const complexMatch = capacityString.match(/(\d+\.?\d*)\s*[^x\d]*\s*(\d+)\s*[入瓶袋]/i) ||
                         capacityString.match(/(\d+\.?\d*)\s*[xX*]\s*(\d+\.?\d*)/);

    if (complexMatch && complexMatch.length >= 3) {
        // 匹配到 Unit (單位容量/質量) 和 Count (數量)
        const unit = parseFloat(complexMatch[1]);
        const count = parseFloat(complexMatch[2]);
        if (!isNaN(unit) && !isNaN(count)) {
            return unit * count;
        }
    }
    
    // 步驟 2: 如果沒有複雜模式，就嘗試解析單一數字 (例如 "2000ml" -> 2000)
    return cleanAndParseNumber(capacityString);
}

const AIOcrCaptureModal = ({ theme, onAnalysisSuccess, onClose }) => {
    const [imageSrc, setImageSrc] = useState(null);
    const [base64Image, setBase64Image] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    // resultData 現在儲存 AI 傳回的原始純文字
    const [resultData, setResultData] = useState(null); 
    const [error, setError] = useState(null);

    const currentTheme = themeConfig[theme] || themeConfig['blue'];
    const apiKey = ""; // 保持空白，讓 Canvas 注入

    const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                setImageSrc(e.target.result);
                // 儲存 base64 字串供 API 使用
                const base64 = e.target.result.split(',')[1];
                setBase64Image(base64);
                setError(null);
                setResultData(null);
            };
            reader.readAsDataURL(file);
        }
    };

    const handleAnalyzeImage = useCallback(async () => {
        if (!base64Image) {
            setError("請先選擇一張包含價格或規格的圖片。");
            return;
        }

        setIsLoading(true);
        setError(null);
        setResultData(null);

        // ----------------------------------------------------------------------
        // **【核心修正 1】** 系統指令：要求 AI 輸出純文字格式
        // ----------------------------------------------------------------------
        const systemPrompt = `
            你是一個專業的價格數據分析助理。請根據圖像中的標價、產品名稱和規格，僅輸出以下四行資訊，每行使用 '::' 分隔標籤和值。
            **重要規則：**
            1. 不輸出任何 JSON、註釋、Markdown 格式（如星號或井字號）或 JSON 以外的文字。
            2. listedPrice 必須是 AI 辨識到的原始價格文字，包含貨幣或單位。
            3. totalCapacity 必須是 AI 辨識到的原始容量/數量文字，包含單位。
            4. baseUnit 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            
            --- 輸出格式（務必精準遵循）---
            productName::[產品名稱]
            listedPrice::[原始標價文字]
            totalCapacity::[原始容量/數量文字]
            baseUnit::[g, ml 或 pcs]
        `;
        
        const userQuery = "請根據這張圖片，提取產品名稱、價格、規格和基礎單位，並使用指定的純文字格式輸出。";

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: "image/jpeg",
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            // **【核心修正 2】** 移除 JSON 格式強制約束 (generationConfig)
        };

        try {
            const response = await withExponentialBackoff(async () => {
                const res = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) {
                    throw new Error(`API error: ${res.status} ${res.statusText}`);
                }
                return res.json();
            });

            const textResponse = response.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (textResponse) {
                // **【核心修正 3】** 新的解析邏輯：從純文字中提取數據
                const lines = textResponse.split('\n').filter(line => line.includes('::'));
                const parsedData = {};

                lines.forEach(line => {
                    const [key, value] = line.split('::').map(s => s.trim());
                    if (key) {
                        parsedData[key] = value;
                    }
                });
                
                setResultData(textResponse); // 儲存原始文字響應用於顯示

                // 檢查是否包含所有必須的字段
                if (!parsedData.listedPrice || !parsedData.totalCapacity || !parsedData.productName || !parsedData.baseUnit) {
                    setError("AI 分析成功，但未能返回所有關鍵數據（價格、容量、名稱、單位）或格式不符。原始輸出:\n" + textResponse);
                    setIsLoading(false);
                    return;
                }
                
                // 執行客戶端解析與計算
                const { 
                    listedPrice: priceStr = '0', 
                    totalCapacity: capacityStr = '0', 
                    baseUnit = '' 
                } = parsedData;
                
                // 將 AI 回傳的字串安全地轉換為數字
                const listedPrice = cleanAndParseNumber(priceStr);
                // 將 AI 回傳的容量字串安全地計算為總容量數字
                const totalCapacity = calculateTotalCapacity(capacityStr);

                let unitPrice = 0;
                
                if (listedPrice > 0 && totalCapacity > 0) {
                    if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的最終數據
                const finalData = {
                    ...parsedData,
                    listedPrice: listedPrice, // 傳遞解析後的數字
                    totalCapacity: totalCapacity, // 傳遞計算後的數字
                    unitPrice: unitPrice,
                    standard: (baseUnit === 'g' || baseUnit === 'ml') ? `每 100${baseUnit}` : `每個`,
                    timestamp: Date.now(),
                    storeName: '待定義店舖' 
                };
                
                // 檢查最終數據，如果價格或容量依然為 0，則顯示警告
                if (listedPrice === 0 || totalCapacity === 0) {
                    setError(`AI 辨識成功，但價格 (${listedPrice}) 或總容量 (${totalCapacity}) 提取失敗，請檢查原始圖片清晰度或 AI 原始輸出。`);
                    setIsLoading(false);
                    return;
                }

                onAnalysisSuccess(finalData);

            } else {
                setError("AI 分析失敗或未能返回任何文字數據。");
            }
        } catch (err) {
            console.error("API Call Failed:", err);
            const errorMessage = err.message || (err.toString && err.toString()) || "未知錯誤，請檢查主控台獲取詳細資訊。";
            setError(`分析過程中發生錯誤: ${errorMessage}`);
        } finally {
            setIsLoading(false);
        }
    }, [base64Image, onAnalysisSuccess]);


    return (
        <div className="fixed inset-0 z-50 overflow-y-auto bg-gray-900 bg-opacity-75 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-xl p-6 transform transition-all">
                <h2 className={`text-2xl font-bold mb-4 text-${currentTheme.primary}`}>AI 視覺擷取與單價分析</h2>
                
                {/* 1. 圖片上傳區 */}
                <div className="mb-4">
                    <label className={`block text-sm font-medium text-gray-700 mb-2`}>
                        上傳產品照片 (含價格與規格)
                    </label>
                    <input 
                        type="file" 
                        accept="image/*" 
                        onChange={handleImageChange} 
                        className="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                    />
                </div>
                
                {/* 2. 圖片預覽區 */}
                {imageSrc && (
                    <div className="mb-4">
                        <h3 className="text-lg font-semibold mb-2">預覽圖片：</h3>
                        <div className="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-2">
                            <img src={imageSrc} alt="上傳預覽" className="max-w-full h-auto rounded-lg shadow-md" />
                        </div>
                    </div>
                )}
                
                {/* 3. 操作按鈕與狀態 */}
                <div className="flex justify-end space-x-3 mb-4">
                    <button 
                        onClick={onClose} 
                        className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-full hover:bg-gray-200 transition duration-150"
                        disabled={isLoading}
                    >
                        取消/關閉
                    </button>
                    <button 
                        onClick={handleAnalyzeImage} 
                        className={`px-6 py-2 text-sm font-semibold text-white bg-${currentTheme.primary} rounded-full shadow-md hover:bg-${currentTheme.hover} transition duration-150 flex items-center justify-center`}
                        disabled={isLoading || !base64Image}
                    >
                        {isLoading ? (
                             <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        ) : '開始分析'}
                    </button>
                </div>

                {/* 4. 結果顯示/錯誤區 */}
                {error && (
                    <div className={`p-3 rounded-lg bg-red-100 border border-red-400 text-red-700 text-sm mb-4`}>
                        錯誤: {error}
                    </div>
                )}

                {resultData && (
                    <div className={`p-4 rounded-lg bg-${currentTheme.bg} border border-${currentTheme.primary} mb-4`}>
                        <h3 className="text-lg font-semibold mb-2">分析結果 (原始文字輸出)：</h3>
                        <pre className="text-xs overflow-auto bg-white p-3 rounded-md border border-gray-300">
                            {resultData}
                        </pre>
                        <p className="text-sm mt-2 font-medium text-gray-700">
                            **解析後的數字計算：**
                            <span className="block mt-1">
                                **標價 (已解析):** ${cleanAndParseNumber(resultData).toFixed(2)}
                            </span>
                            <span className="block">
                                **總容量 (已計算):** {calculateTotalCapacity(resultData)}
                            </span>
                        </p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default AIOcrCaptureModal;
