import React, { useState, useEffect, useCallback } from 'react';

// 假設這些是您的主題顏色配置
const themeConfig = {
    'blue': { primary: 'indigo-600', hover: 'indigo-700', bg: 'indigo-50' },
    'red': { primary: 'red-600', hover: 'red-700', bg: 'red-50' },
    // ... 其他主題色
};

// 輔助函數：實現指數退避 (Exponential Backoff)
const withExponentialBackoff = async (fn, retries = 5, delay = 1000) => {
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries - 1) throw error;
            console.warn(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
        }
    }
};

// **【核心修正 1】** 輔助函數：從字串中提取數字 (例如: "$120.50" -> 120.50)
const cleanAndParseNumber = (str) => {
    if (typeof str !== 'string' || str === null || str === '') return 0;
    
    // 移除所有非數字、非小數點的字符 (保留負號以防萬一，但價格和容量應是非負的)
    // 這裡使用更保守的策略，移除貨幣符號和大部分非數字字元，然後解析
    const cleaned = str.replace(/[^\d.]/g, ''); 
    const num = parseFloat(cleaned);
    
    // 如果解析結果是 NaN (非數字)，則返回 0
    return isNaN(num) ? 0 : num;
};

// **【核心修正 2】** 輔助函數：從複雜字串計算總容量 (例如: "18克10入" -> 180)
const calculateTotalCapacity = (capacityString) => {
    if (typeof capacityString !== 'string') {
        return 0;
    }
    
    // 步驟 1: 處理複合格式 (X 單位 Y 入/瓶/袋)
    // 尋找 (數字A) (單位) (數字B) (入/瓶) 或 (數字A) x (數字B) 的模式
    const complexMatch = capacityString.match(/(\d+\.?\d*)\s*[^x\d]*\s*(\d+)\s*[入瓶袋]/i) ||
                         capacityString.match(/(\d+\.?\d*)\s*[xX*]\s*(\d+\.?\d*)/);

    if (complexMatch && complexMatch.length >= 3) {
        // 匹配到 Unit (單位容量/質量) 和 Count (數量)
        const unit = parseFloat(complexMatch[1]);
        const count = parseFloat(complexMatch[2]);
        if (!isNaN(unit) && !isNaN(count)) {
            return unit * count;
        }
    }
    
    // 步驟 2: 如果沒有複雜模式，就嘗試解析單一數字 (例如 "2000ml" -> 2000)
    return cleanAndParseNumber(capacityString);
}

const AIOcrCaptureModal = ({ theme, onAnalysisSuccess, onClose }) => {
    const [imageSrc, setImageSrc] = useState(null);
    const [base64Image, setBase64Image] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [resultData, setResultData] = useState(null);
    const [error, setError] = useState(null);

    const currentTheme = themeConfig[theme] || themeConfig['blue'];
    const apiKey = ""; // 保持空白，讓 Canvas 注入

    const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                setImageSrc(e.target.result);
                // 儲存 base64 字串供 API 使用
                const base64 = e.target.result.split(',')[1];
                setBase64Image(base64);
                setError(null);
                setResultData(null);
            };
            reader.readAsDataURL(file);
        }
    };

    const handleAnalyzeImage = useCallback(async () => {
        if (!base64Image) {
            setError("請先選擇一張包含價格或規格的圖片。");
            return;
        }

        setIsLoading(true);
        setError(null);
        setResultData(null);

        const userQuery = "請根據圖片中的標價、產品名稱和規格（質量/容量/數量），以嚴格的 JSON 格式輸出結構化數據。";
        
        // **【核心修正 3】** 將 listedPrice 和 totalCapacity 改為 STRING
        const newSchema = {
            type: "OBJECT",
            properties: {
                productName: { "type": "STRING", "description": "產品名稱，例如：家庭號牛奶" },
                listedPrice: { "type": "STRING", "description": "產品標價（保留原始文字，例如: $59.99 或 120元）" },
                totalCapacity: { "type": "STRING", "description": "產品的總容量/總質量/總數量（保留原始文字，例如: 1.5L 或 18克10入）" },
                baseUnit: { "type": "STRING", "description": "用於計算單價的基礎單位。僅使用 'g' (克), 'ml' (毫升), 或 'pcs' (個/入)。如果是質量，請統一使用 'g'。" }
            },
            propertyOrdering: ["productName", "listedPrice", "totalCapacity", "baseUnit"]
        };
        
        // 系統指令略作調整，以強調辨識原始字串
        const systemPrompt = `
            你是一個專業的價格數據分析助理。你的任務是從圖像中精確識別產品名稱、標價以及完整的容量/質量/數量資訊，並將其格式化為嚴格的 JSON 輸出。
            **重要規則：**
            1. listedPrice 和 totalCapacity 字段**必須**保留 AI 辨識到的原始文字，包含貨幣或單位。
            2. 基礎單位 (baseUnit) 必須是 'g', 'ml', 或 'pcs' 之一。質量請用 'g'。
            請勿輸出任何 JSON 以外的文字、註釋或說明。
        `;

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: "image/jpeg",
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: newSchema
            }
        };

        try {
            const response = await withExponentialBackoff(async () => {
                const res = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) {
                    throw new Error(`API error: ${res.status} ${res.statusText}`);
                }
                return res.json();
            });

            const jsonText = response.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (jsonText) {
                let parsedJson;
                try {
                    parsedJson = JSON.parse(jsonText);
                } catch (jsonError) {
                    console.error("JSON Parsing Failed:", jsonText, jsonError);
                    setError("AI 回傳的數據格式無效，無法解析 JSON。原始輸出: " + jsonText.substring(0, 50) + "...");
                    return; // 終止執行，避免使用無效數據
                }

                setResultData(parsedJson);

                // **【核心修正 4】** 使用輔助函數解析 AI 回傳的字串
                const { 
                    listedPrice: priceStr = '0', 
                    totalCapacity: capacityStr = '0', 
                    baseUnit = '' 
                } = parsedJson;
                
                // 將 AI 回傳的字串安全地轉換為數字
                const listedPrice = cleanAndParseNumber(priceStr);
                // 將 AI 回傳的容量字串安全地計算為總容量數字
                const totalCapacity = calculateTotalCapacity(capacityStr);

                let unitPrice = 0;
                
                // 確保價格和容量大於零才進行計算
                if (listedPrice > 0 && totalCapacity > 0) {
                    // 價格 / (總容量 / 100) = 每 100 單位價格
                    if (baseUnit === 'g' || baseUnit === 'ml') {
                        unitPrice = (listedPrice / totalCapacity) * 100;
                    } else if (baseUnit === 'pcs') {
                        // 價格 / 總數量 = 每個單價
                        unitPrice = listedPrice / totalCapacity;
                    }
                }
                
                // 準備傳遞給父組件的數據，包含計算出的單價
                const finalData = {
                    ...parsedJson,
                    // 覆蓋原始字串，使用已解析的數字
                    listedPrice: listedPrice, 
                    totalCapacity: totalCapacity, 
                    unitPrice: unitPrice,
                    standard: (baseUnit === 'g' || baseUnit === 'ml') ? `每 100${baseUnit}` : `每個`,
                    timestamp: Date.now(),
                    storeName: '待定義店舖' 
                };
                
                // 檢查最終數據，如果價格或容量依然為 0，則顯示警告
                if (listedPrice === 0 || totalCapacity === 0) {
                    setError(`成功解析 JSON，但價格 (${listedPrice}) 或總容量 (${totalCapacity}) 解析失敗，請檢查原始圖片清晰度或 AI 輸出是否為 0/N/A。`);
                    setIsLoading(false); // 保持 Modal 開啟並顯示錯誤
                    return;
                }

                onAnalysisSuccess(finalData);

            } else {
                setError("AI 分析失敗或未能返回有效的 JSON 數據。");
            }
        } catch (err) {
            console.error("API Call Failed:", err);
            const errorMessage = err.message || (err.toString && err.toString()) || "未知錯誤，請檢查主控台獲取詳細資訊。";
            setError(`分析過程中發生錯誤: ${errorMessage}`);
        } finally {
            setIsLoading(false);
        }
    }, [base64Image, onAnalysisSuccess]);

    // ... (useEffect for apiKey remains the same)

    return (
        <div className="fixed inset-0 z-50 overflow-y-auto bg-gray-900 bg-opacity-75 flex items-center justify-center p-4">
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-xl p-6 transform transition-all">
                <h2 className={`text-2xl font-bold mb-4 text-${currentTheme.primary}`}>AI 視覺擷取與單價分析</h2>
                
                {/* 1. 圖片上傳區 */}
                <div className="mb-4">
                    <label className={`block text-sm font-medium text-gray-700 mb-2`}>
                        上傳產品照片 (含價格與規格)
                    </label>
                    <input 
                        type="file" 
                        accept="image/*" 
                        onChange={handleImageChange} 
                        className="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                    />
                </div>
                
                {/* 2. 圖片預覽區 */}
                {imageSrc && (
                    <div className="mb-4">
                        <h3 className="text-lg font-semibold mb-2">預覽圖片：</h3>
                        <div className="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-2">
                            <img src={imageSrc} alt="上傳預覽" className="max-w-full h-auto rounded-lg shadow-md" />
                        </div>
                    </div>
                )}
                
                {/* 3. 操作按鈕與狀態 */}
                <div className="flex justify-end space-x-3 mb-4">
                    <button 
                        onClick={onClose} 
                        className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-full hover:bg-gray-200 transition duration-150"
                        disabled={isLoading}
                    >
                        取消/關閉
                    </button>
                    <button 
                        onClick={handleAnalyzeImage} 
                        className={`px-6 py-2 text-sm font-semibold text-white bg-${currentTheme.primary} rounded-full shadow-md hover:bg-${currentTheme.hover} transition duration-150 flex items-center justify-center`}
                        disabled={isLoading || !base64Image}
                    >
                        {isLoading ? (
                             <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        ) : '開始分析'}
                    </button>
                </div>

                {/* 4. 結果顯示/錯誤區 */}
                {error && (
                    <div className={`p-3 rounded-lg bg-red-100 border border-red-400 text-red-700 text-sm mb-4`}>
                        錯誤: {error}
                    </div>
                )}

                {resultData && (
                    <div className={`p-4 rounded-lg bg-${currentTheme.bg} border border-${currentTheme.primary} mb-4`}>
                        <h3 className="text-lg font-semibold mb-2">分析結果 (原始 JSON)：</h3>
                        <pre className="text-xs overflow-auto bg-white p-3 rounded-md border border-gray-300">
                            {JSON.stringify(resultData, null, 2)}
                        </pre>
                        <p className="text-sm mt-2 font-medium text-gray-700">
                            **解析後的數據：**
                            <span className="block mt-1">
                                **標價 (已解析):** ${cleanAndParseNumber(resultData.listedPrice).toFixed(2)}
                            </span>
                            <span className="block">
                                **總容量 (已計算):** {calculateTotalCapacity(resultData.totalCapacity)}
                            </span>
                            <span className="block font-bold mt-2">
                                **計算單價:** ${resultData.unitPrice ? resultData.unitPrice.toFixed(2) : 'N/A'} {resultData.standard ? `(${resultData.standard})` : ''}
                            </span>
                        </p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default AIOcrCaptureModal;
