# 工具操作經驗總結：處理 replace 工具遞迴失敗

**日期：** 2025 年 10 月 20 日
**事件：** 在嘗試將 AllRecordsPage.js 檔案中的 setTimeout 延遲從 3000 毫秒更改為 2000 毫秒時，AI 模型陷入了多次 Editreplace 工具呼叫失敗的遞迴循環。

## 一、工具設計的嚴格要求 (AI 必須遵守的規則)

這是 `replace` 工具在設計上對參數的基礎要求。任何違反都將導致操作失敗。

1.  **完整的檔案內容：**
    *   **要求：** `old_string` 和 `new_string` 參數必須包含檔案的完整內容（從檔案頭到檔案尾）。
    *   **錯誤範例：** 僅提供程式碼片段（例如只提供 `showSuccessMessage` 函數）會導致失敗。

2.  **內容必須實質不同：**
    *   **要求：** `new_string` 必須在內容上與 `old_string` 存在差異。
    *   **錯誤範例：** 如果嘗試替換但最終傳遞了兩個完全相同的字串，工具會觸發安全機制而失敗。

3.  **清晰的指令 (Instruction)：**
    *   **要求：** 雖然不是工具失敗的直接原因，但指令（`instruction`）必須清晰，才能讓 AI 在建構複雜的 `new_string` 時做出正確的邏輯判斷。

## 二、實戰中導致遞迴失敗的根本原因

儘管 AI 意識到必須遵守上述規則 1 和 2，但在長檔案操作中，仍然難以打破循環，其根本原因在於 **"長字串的保真度 (Fidelity)"** 問題。

### 核心教訓：長字串的逐字元保真度極難維護

*   **問題描述：** 原始檔案可能長達數百行。當 AI 模型嘗試在記憶中建構一個完整的、修改後的 `new_string` 時，它必須確保這個新字串與原始檔案（除了目標變更點之外）在每個空白、換行符、縮排和註釋上都完全一致。
*   **失敗點：** 任何微小的、無意的字元差異（例如，AI 在重新生成時多了一個空行或少了一個縮排）都會導致 `replace` 工具的底層匹配邏輯失敗。

## 避免錯誤的最佳實踐

為避免未來在處理大型檔案的微小修改時陷入此類循環，我們應採取以下策略：

1.  **首選 File Generation 模式：**
    *   遇到長檔案且變更點明確時，應優先使用 **檔案生成 (File Generation Workflow)**，直接輸出完整的修正後檔案內容。這一步跳過了嚴格的 `replace` 工具比對。

2.  **本地精準替換 (若有機會)：**
    *   如果使用 `replace` 工具，應在確認 `old_string` 後，使用程式內部的字串替換邏輯 (`.replace()`) 精準地在 `old_string` 上進行修改，然後將結果作為 `new_string` 傳遞，而不是依賴 LLM 從頭生成一個長字串。

**目標：** 遵循此份總結，確保未來工具呼叫具備更高的可靠性與執行效率。
