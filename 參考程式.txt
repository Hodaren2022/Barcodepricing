import React, { useState, useEffect, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, collection, query, where, getDocs, addDoc } from 'firebase/firestore'; 

// --- Firebase Configuration and Initialization ---
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// The Quagga global object is assumed to be available via CDN script injection
const Quagga = window.Quagga; 

// Hardcoded list of local supermarkets for demonstration
const STORES = ['å®¶æ¨‚ç¦ (Carrefour)', 'å…¨è¯ (PX Mart)', 'å¤§æ½¤ç™¼ (RT-Mart)', 'ç¾å»‰ç¤¾ (Simple Mart)', 'å…¶ä»–'];

// Simple DJB2-like hash function optimized for speed and consistency
function generateNumericalID(str) {
    let hash = 5381;
    let i = str.length;

    while (i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
    }

    return hash >>> 0;
}

// Custom hook to handle Firebase setup and user authentication
const useFirebase = () => {
    const [db, setDb] = useState(null);
    const [userId, setUserId] = useState(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        if (Object.keys(firebaseConfig).length === 0) {
            console.error("Firebase configuration is missing.");
            setIsLoading(false);
            return;
        }

        try {
            const app = initializeApp(firebaseConfig);
            const authInstance = getAuth(app);
            const dbInstance = getFirestore(app);
            setDb(dbInstance);

            const unsubscribe = onAuthStateChanged(authInstance, async (user) => {
                if (user) {
                    setUserId(user.uid);
                    setIsLoading(false);
                } else {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(authInstance, initialAuthToken);
                        } else {
                            await signInAnonymously(authInstance);
                        }
                    } catch (error) {
                        console.error("Firebase sign-in failed:", error);
                        setIsLoading(false);
                    }
                }
            });

            return () => unsubscribe();
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            setIsLoading(false);
        }
    }, []);

    return { db, userId, isLoading };
};

// Utility function to convert File to Base64
const fileToBase64 = (file) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]); // Only data part
        reader.onerror = (error) => reject(error);
    });
};

// Main App Component
const App = () => {
    const { db, userId, isLoading } = useFirebase();
    const [barcodeInput, setBarcodeInput] = useState('');
    const [numericalID, setNumericalID] = useState(null);
    const [statusMessage, setStatusMessage] = useState('ç­‰å¾…è¼¸å…¥æˆ–å•Ÿç”¨ç›¸æ©Ÿ...');
    const [isScanning, setIsScanning] = useState(false);
    const [isDetected, setIsDetected] = useState(false);
    const [isOCRCaptureMode, setIsOCRCaptureMode] = useState(false); // NEW: OCR Mode state
    const [isOCRLoading, setIsOCRLoading] = useState(false); // NEW: OCR Loading state
    
    // Product Master Data States
    const [productName, setProductName] = useState('');
    const [isProductExist, setIsProductExist] = useState(false);

    // Price Record States (Current Scan)
    const [currentStore, setCurrentStore] = useState(STORES[0]);
    const [currentPrice, setCurrentPrice] = useState('');
    const [currentDiscount, setCurrentDiscount] = useState('');
    
    // Comparison Results State
    const [comparisonData, setComparisonData] = useState([]); 
    const [bestDeal, setBestDeal] = useState(null); 

    const scannerRef = useRef(null);
    const fileInputRef = useRef(null);

    // Function to reset all product states
    const resetStates = () => {
        setNumericalID(null);
        setProductName('');
        setBarcodeInput('');
        setCurrentPrice('');
        setCurrentDiscount('');
        setIsProductExist(false);
        setComparisonData([]);
        setBestDeal(null);
        setIsOCRCaptureMode(false); // Reset OCR mode
    }

    // --- Gemini OCR Image Analysis Logic ---
    const performOCRAnalysis = async (file) => {
        if (!file) return;

        setIsOCRLoading(true);
        setStatusMessage('ğŸš€ æ­£åœ¨ä¸Šå‚³åœ–ç‰‡ä¸¦é€²è¡Œ Gemini åœ–åƒåˆ†æ (OCR)...');

        try {
            const base64ImageData = await fileToBase64(file);
            
            const systemPrompt = "ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„åƒ¹æ ¼æ¨™ç±¤åˆ†æå¸«ã€‚è«‹ä»”ç´°åˆ†ææä¾›çš„åœ–åƒï¼Œè­˜åˆ¥å•†åº—åç¨±ã€å•†å“çš„æ¨™åƒ¹ï¼ˆåƒ…éœ€æ•¸å­—éƒ¨åˆ†ï¼Œå°æ•¸é»å¾Œå…©ä½ï¼‰ï¼Œä»¥åŠä»»ä½•ç›¸é—œçš„å„ªæƒ æˆ–æŠ˜æ‰£è³‡è¨Šã€‚è«‹ä»¥ JSON æ ¼å¼è¼¸å‡ºçµæœï¼Œä¸è¦æ·»åŠ ä»»ä½•è§£é‡‹æ€§æ–‡å­—ã€‚å¦‚æœç„¡æ³•è­˜åˆ¥ï¼Œè«‹ä½¿ç”¨ç©ºå­—ä¸²æˆ– 0ã€‚";
            const userQuery = "è«‹å¾é€™å¼µåœ–ç‰‡ä¸­æå–å•†åº—åç¨±ã€æ¨™åƒ¹å’Œå„ªæƒ è³‡è¨Šã€‚";
            
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: userQuery },
                            {
                                inlineData: {
                                    mimeType: file.type,
                                    data: base64ImageData
                                }
                            }
                        ]
                    }
                ],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "storeName": { "type": "STRING" },
                            "price": { "type": "NUMBER" },
                            "discountDetails": { "type": "STRING" }
                        },
                        "propertyOrdering": ["storeName", "price", "discountDetails"]
                    }
                }
            };

            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            // --- Exponential Backoff for API Call ---
            const maxRetries = 5;
            let attempt = 0;
            let result;

            while (attempt < maxRetries) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429) { // Rate limit hit
                            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            attempt++;
                            continue; // Retry
                        }
                        throw new Error(`API call failed with status: ${response.status}`);
                    }
                    
                    result = await response.json();
                    break; // Success
                } catch (error) {
                    console.error(`Attempt ${attempt + 1} failed:`, error.message);
                    if (attempt === maxRetries - 1) throw error;
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    attempt++;
                }
            }
            // --- End Exponential Backoff ---

            const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) {
                throw new Error("API response was empty or malformed.");
            }
            
            const ocrData = JSON.parse(jsonText);
            
            // Update states with OCR results
            if (ocrData.storeName) setCurrentStore(ocrData.storeName);
            if (ocrData.price && !isNaN(parseFloat(ocrData.price))) setCurrentPrice(ocrData.price.toFixed(2));
            if (ocrData.discountDetails) setCurrentDiscount(ocrData.discountDetails);
            
            setIsOCRCaptureMode(false);
            setStatusMessage(`âœ… åœ–åƒåˆ†æå®Œæˆã€‚çµæœå·²è‡ªå‹•å¡«å…¥ï¼š${ocrData.storeName} $${ocrData.price}`);
            
        } catch (e) {
            console.error("OCR analysis error: ", e);
            setStatusMessage(`ğŸš« åœ–åƒåˆ†æå¤±æ•—ã€‚è«‹æ‰‹å‹•è¼¸å…¥è³‡è¨Šã€‚éŒ¯èª¤: ${e.message}`);
            setIsOCRCaptureMode(false);
        } finally {
            setIsOCRLoading(false);
        }
    };
    
    // Handler for file input change
    const handleFileChange = (event) => {
        const file = event.target.files[0];
        if (file) {
            performOCRAnalysis(file);
        }
    };
    
    // --- Price Comparison Logic (Unchanged) ---
    const fetchComparisonData = async (id, currentRecord) => {
        if (!db) return;

        const pricesRef = collection(db, `artifacts/${appId}/public/data/price_records`);
        const q = query(pricesRef, where('numericalID', '==', id)); 
        
        try {
            const querySnapshot = await getDocs(q);
            let records = [];
            
            querySnapshot.forEach((doc) => {
                records.push({ id: doc.id, ...doc.data() });
            });

            if (currentRecord) {
                records.push({ ...currentRecord, isCurrentScan: true, id: 'current_scan' });
            }

            let lowestPriceRecord = null;
            if (records.length > 0) {
                lowestPriceRecord = records.reduce((min, record) => {
                    return record.price < min.price ? record : min;
                }, records[0]);
            }
            
            setComparisonData(records);
            setBestDeal(lowestPriceRecord);

            return { lowestPriceRecord, records };

        } catch (e) {
            console.error("Error fetching comparison data: ", e);
            setStatusMessage('ğŸš« æ­·å²åƒ¹æ ¼æ¯”è¼ƒå¤±æ•—ã€‚');
            return { lowestPriceRecord: null, records: [] };
        }
    }

    // --- Core Logic: Scan -> Lookup -> Compare (Unchanged) ---
    const processBarcode = async (rawBarcodeData) => {
        if (!rawBarcodeData.trim()) return;

        resetStates(); 
        
        const calculatedNumericalID = generateNumericalID(rawBarcodeData);
        setBarcodeInput(rawBarcodeData);
        setNumericalID(calculatedNumericalID);
        
        setIsDetected(true);
        setTimeout(() => setIsDetected(false), 500); 

        setStatusMessage(`æ•¸å€¼ ID: ${calculatedNumericalID} å·²ç”Ÿæˆã€‚æ­£åœ¨æŸ¥è©¢ç”¢å“ä¸»æª”...`);

        if (db && userId) {
            try {
                // 1. Lookup Product Master Data
                const productDocRef = doc(db, `artifacts/${appId}/public/data/products`, calculatedNumericalID.toString());
                const productSnap = await getDoc(productDocRef);

                if (productSnap.exists()) {
                    const existingData = productSnap.data();
                    setProductName(existingData.productName || 'æœªå‘½åç”¢å“');
                    setIsProductExist(true);
                    setStatusMessage(`ç”¢å“: ${existingData.productName} å·²è¼‰å…¥ã€‚è«‹é€²è¡Œ OCR æˆ–æ‰‹å‹•è¼¸å…¥åƒ¹æ ¼ã€‚`);
                } else {
                    // New product
                    setIsProductExist(false);
                    setStatusMessage('åµæ¸¬åˆ°æ–°ç”¢å“ã€‚è«‹å…ˆè¼¸å…¥ç”¢å“åç¨±ï¼Œç„¶å¾Œé€²è¡Œ OCR æˆ–è¼¸å…¥åƒ¹æ ¼ç´€éŒ„ã€‚');
                }

                // 2. Fetch all historical prices for comparison immediately
                await fetchComparisonData(calculatedNumericalID);

            } catch (e) {
                console.error("Error accessing product master data: ", e);
                setStatusMessage('æ•¸æ“šåº«æŸ¥è©¢å¤±æ•—ï¼Œä½†æ•¸å€¼ ID å·²åœ¨æœ¬åœ°ç”Ÿæˆã€‚');
            }
        }
    };
    
    // --- Save Price Record Logic (Unchanged) ---
    const savePriceRecord = async () => {
        if (!db || !userId || !barcodeInput.trim() || !productName.trim() || isNaN(parseFloat(currentPrice))) {
            setStatusMessage('éŒ¯èª¤ï¼šè«‹ç¢ºä¿ç”¢å“åç¨±å’Œåƒ¹æ ¼çš†å·²è¼¸å…¥ã€‚');
            return;
        }

        const priceValue = parseFloat(currentPrice);
        const rawBarcodeData = barcodeInput.trim();
        const calculatedNumericalID = generateNumericalID(rawBarcodeData);

        const newPriceRecord = {
            numericalID: calculatedNumericalID,
            productName: productName.trim(),
            storeName: currentStore,
            price: priceValue,
            discountDetails: currentDiscount.trim(),
            timestamp: new Date().toISOString(),
            recordedBy: userId,
        };

        try {
            // Check if product master data needs creation/update
            const productDocRef = doc(db, `artifacts/${appId}/public/data/products`, calculatedNumericalID.toString());
            if (!isProductExist) {
                 await setDoc(productDocRef, {
                    numericalID: calculatedNumericalID,
                    barcodeData: rawBarcodeData,
                    productName: productName.trim(),
                    createdAt: new Date().toISOString(),
                    createdBy: userId,
                });
                setIsProductExist(true); 
            } 

            // 1. Save the new price record
            await addDoc(collection(db, `artifacts/${appId}/public/data/price_records`), newPriceRecord);

            // 2. Re-fetch and compare with the new record
            await fetchComparisonData(calculatedNumericalID, newPriceRecord);
            
            setStatusMessage(`ğŸ‰ åƒ¹æ ¼ç´€éŒ„å·²å„²å­˜ã€‚ç•¶å‰ç´€éŒ„ $${priceValue}ã€‚`);

        } catch (e) {
            console.error("Error saving price record: ", e);
            setStatusMessage('ğŸš« åƒ¹æ ¼è³‡æ–™å„²å­˜å¤±æ•—ã€‚');
        }
    }
    
    // --- Input Handlers (Unchanged) ---
    const handleManualScan = () => {
        if (barcodeInput.trim()) {
            processBarcode(barcodeInput);
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            handleManualScan();
        }
    };

    // --- QuaggaJS/Scanning Logic (Unchanged) ---
    useEffect(() => {
        if (!isScanning && Quagga && typeof Quagga.stop === 'function') {
            Quagga.stop();
        }

        if (isScanning && scannerRef.current && Quagga) {
            resetStates(); 
            setStatusMessage('ç›¸æ©Ÿå•Ÿç”¨ä¸­ï¼Œè«‹å°æº–æ¢ç¢¼...');
            
            Quagga.init({
                inputStream: {
                    name: "Live",
                    type: "LiveStream",
                    target: scannerRef.current,
                    constraints: { facingMode: "environment" },
                },
                decoder: {
                    readers: ["ean_reader", "code_128_reader", "code_39_reader", "upc_reader"],
                    multiple: false 
                },
                locator: { patchSize: "medium", halfSample: true },
                numOfWorkers: navigator.hardwareConcurrency || 2,
                locate: true,
            }, (err) => {
                if (err) {
                    console.error("Quagga initialization error:", err);
                    setStatusMessage(`ç›¸æ©Ÿåˆå§‹åŒ–å¤±æ•—: ${err.name}ã€‚è«‹æª¢æŸ¥æ¬Šé™ã€‚`);
                    setIsScanning(false);
                    return;
                }
                Quagga.start();
                setStatusMessage('ç›¸æ©Ÿæƒæä¸­... å˜—è©¦è¾¨è­˜ä¸€ç¶­æ¢ç¢¼ã€‚');
            });

            Quagga.onDetected((data) => {
                const scannedCode = data.codeResult.code;
                if (scannedCode) {
                    Quagga.stop(); 
                    setIsScanning(false);
                    processBarcode(scannedCode);
                }
            });

            return () => {
                if (Quagga && typeof Quagga.stop === 'function') {
                    Quagga.stop();
                    Quagga.offDetected();
                }
            };
        }
    }, [isScanning, db, userId]);

    if (isLoading) {
        return (
            <div className="flex items-center justify-center min-h-screen bg-gray-50">
                <p className="text-xl font-medium text-indigo-600">è¼‰å…¥ä¸­...</p>
            </div>
        );
    }

    // --- UI Components ---
    
    const ComparisonDisplay = () => {
        if (comparisonData.length === 0) return null;
        if (!bestDeal) return <p className="text-blue-600">ç›®å‰æ²’æœ‰å…¶ä»–æ­·å²åƒ¹æ ¼ç´€éŒ„ã€‚</p>;

        const currentPriceFloat = parseFloat(currentPrice);
        const isBestDeal = currentPriceFloat > 0 && currentPriceFloat === bestDeal.price;
        
        let comparisonMessage;
        if (currentPriceFloat > 0 && isBestDeal) {
            comparisonMessage = <p className="text-lg font-bold text-green-700">ğŸ‰ æ‚¨ç•¶å‰æƒæçš„åƒ¹æ ¼å°±æ˜¯ç›®å‰è³‡æ–™åº«ä¸­çš„æœ€å„ªæƒ åƒ¹æ ¼!</p>;
        } else if (currentPriceFloat > 0 && currentPriceFloat > bestDeal.price) {
            comparisonMessage = (
                <div className="text-lg font-bold text-red-700 space-y-2">
                    <p>ğŸš¨ **æ³¨æ„: åƒ¹æ ¼ä¸æ˜¯æœ€ä½!**</p>
                    <div className="bg-red-50 p-3 rounded-lg border-l-4 border-red-500">
                        <p className="font-normal text-sm text-gray-700">ç›®å‰æœ€å„ªæƒ é¸é …æ˜¯:</p>
                        <p className="font-extrabold text-xl text-red-800">
                            ${bestDeal.price.toFixed(2)} @ {bestDeal.storeName}
                        </p>
                        {bestDeal.discountDetails && <p className="text-xs text-red-600">å„ªæƒ : {bestDeal.discountDetails}</p>}
                    </div>
                </div>
            );
        } else {
             comparisonMessage = <p className="text-lg font-bold text-blue-700">â„¹ï¸ å·²è¼‰å…¥æ­·å²åƒ¹æ ¼ï¼Œè«‹è¼¸å…¥ç•¶å‰åƒ¹æ ¼é€²è¡Œæ¯”è¼ƒã€‚</p>;
        }

        return (
            <div className="pt-4 border-t border-gray-200 mt-4 space-y-4">
                <h3 className="text-xl font-bold text-gray-900">3. æ¯”åƒ¹åˆ†æçµæœ</h3>
                
                {comparisonMessage}

                <details className="text-sm text-gray-600 p-2 bg-gray-50 rounded-lg cursor-pointer">
                    <summary className="font-semibold text-gray-700">æª¢è¦–æ‰€æœ‰ {comparisonData.length} ç­†æ­·å²ç´€éŒ„</summary>
                    <ul className="mt-2 space-y-1">
                        {comparisonData
                            .sort((a, b) => a.price - b.price)
                            .map((record, index) => (
                            <li key={index} className={`flex justify-between items-center py-1 px-2 rounded-md ${record.price === bestDeal.price ? 'bg-yellow-100 font-bold' : 'hover:bg-gray-100'}`}>
                                <span>
                                    {record.storeName} ({new Date(record.timestamp).toLocaleDateString()})
                                </span>
                                <span className="text-lg font-mono">
                                    ${record.price.toFixed(2)}
                                </span>
                            </li>
                        ))}
                    </ul>
                </details>
            </div>
        );
    }
    
    // --- Render ---

    return (
        <div className="min-h-screen flex items-center justify-center p-4 bg-gray-100 font-inter">
            <div className="w-full max-w-lg bg-white shadow-2xl rounded-xl p-8 space-y-6 transform transition duration-500 hover:scale-[1.02]">
                <header className="text-center border-b pb-4">
                    <h1 className="text-3xl font-extrabold text-gray-900">ğŸ›’ æ¢ç¢¼æ¯”åƒ¹ç¥å™¨ (OCR å•Ÿå‹•)</h1>
                    <p className="text-sm text-gray-500 mt-1">é€é AI åœ–åƒåˆ†æè‡ªå‹•è­˜åˆ¥å•†åº—èˆ‡åƒ¹æ ¼</p>
                </header>

                <div className="space-y-4">
                    {/* Mode Toggle Button */}
                    <button
                        onClick={() => {
                            if (isScanning && Quagga) Quagga.stop();
                            setIsScanning(!isScanning);
                            setIsDetected(false); 
                            resetStates();
                        }}
                        className={`w-full flex items-center justify-center px-6 py-3 text-base font-medium rounded-lg shadow-md transition duration-150 ease-in-out transform hover:scale-[1.01] ${
                            isScanning ? 'bg-red-500 text-white hover:bg-red-600' : 'bg-indigo-600 text-white hover:bg-indigo-700'
                        }`}
                    >
                        {isScanning ? 'åœæ­¢æƒæ / åˆ‡æ›è‡³æ‰‹å‹•è¼¸å…¥' : 'å•Ÿç”¨ç›¸æ©Ÿæ¢ç¢¼æƒæ'}
                    </button>
                    
                    {/* Camera/Manual Input */}
                    {(isScanning || !numericalID) && (
                        <div className="space-y-4">
                             {/* Camera Scanner View */}
                            {isScanning && (
                                <div className={`relative w-full aspect-video bg-gray-900 rounded-lg overflow-hidden border-4 transition duration-300 ${isDetected ? 'border-green-500 shadow-xl shadow-green-500/50' : 'border-indigo-500'}`}>
                                    <div ref={scannerRef} style={{ width: '100%', height: '100%', position: 'absolute' }} />
                                    
                                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                                        <div className="w-3/4 h-1/2 border-4 border-white border-dashed opacity-80 rounded-lg relative">
                                            <div className={`absolute top-1/2 left-0 right-0 h-0.5 transform -translate-y-1/2 transition duration-100 ${
                                                isDetected ? 'bg-green-500' : 'bg-red-500 animate-pulse'
                                            }`} 
                                            ></div>
                                        </div>
                                    </div>
                                    
                                    <div className="absolute bottom-0 left-0 right-0 text-center text-white text-sm font-semibold p-2 bg-gray-900/60">
                                        {statusMessage}
                                    </div>
                                </div>
                            )}
                            
                            {/* Manual Input View */}
                            {!isScanning && (
                                <div className="space-y-4">
                                    <label htmlFor="barcode" className="block text-lg font-medium text-gray-700">
                                        1. æ‰‹å‹•è¼¸å…¥æ¢ç¢¼æ•¸æ“š:
                                    </label>
                                    <input
                                        type="text"
                                        id="barcode"
                                        value={barcodeInput}
                                        onChange={(e) => setBarcodeInput(e.target.value)}
                                        onKeyDown={handleKeyDown}
                                        className="w-full px-4 py-3 border-2 border-indigo-300 rounded-lg shadow-inner focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-gray-800"
                                        placeholder="ä¾‹å¦‚: ç”¢å“ EAN ç¢¼ã€SKU ç¢¼..."
                                    />
                                    <button
                                        onClick={handleManualScan}
                                        className="w-full flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-lg shadow-lg text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-150 ease-in-out transform hover:translate-y-[-2px] disabled:bg-indigo-400"
                                        disabled={!barcodeInput.trim()}
                                    >
                                        æŸ¥è©¢/ç”Ÿæˆæ•¸å€¼ ID
                                    </button>
                                </div>
                            )}
                        </div>
                    )}
                </div>

                {/* ç”¢å“è³‡æ–™å€ - åªæœ‰æˆåŠŸæƒæå¾Œæ‰é¡¯ç¤º */}
                {numericalID !== null && (
                    <div className="border-t pt-6 space-y-4">
                        <h2 className="text-xl font-bold text-gray-900">
                            2. ç”¢å“è³‡æ–™èˆ‡åƒ¹æ ¼ç´€éŒ„
                        </h2>
                        
                        <div className="bg-indigo-50 border border-indigo-300 p-4 rounded-lg space-y-2">
                            <p className="text-lg font-extrabold text-indigo-800 break-words">
                                å“å: {productName || 'ï¼ˆè«‹è¼¸å…¥åç¨±ä¸¦å„²å­˜ç´€éŒ„ï¼‰'}
                            </p>
                            <p className="text-xs text-indigo-700">
                                æ•¸å€¼ ID: {numericalID} | åŸå§‹æ¢ç¢¼: {barcodeInput}
                            </p>
                            {!isProductExist && (
                                <InputField 
                                    label="è«‹ç‚ºæ–°ç”¢å“å‘½å (å¿…å¡«)"
                                    value={productName}
                                    onChange={setProductName}
                                    type="text"
                                    placeholder="ä¾‹å¦‚: ç‹å­éºµ-åŸå‘³"
                                />
                            )}
                        </div>

                        {/* OCR Capture Toggle */}
                         <button
                            onClick={() => {
                                setIsOCRCaptureMode(true);
                                // Trigger file input click when entering OCR mode
                                if (fileInputRef.current) {
                                    fileInputRef.current.click();
                                }
                            }}
                            className="w-full flex items-center justify-center px-6 py-3 text-base font-medium rounded-lg shadow-md text-white bg-pink-500 hover:bg-pink-600 transition duration-150 transform hover:translate-y-[-1px]"
                            disabled={isOCRLoading}
                        >
                            {isOCRLoading ? 'AI åœ–åƒåˆ†æä¸­...' : 'ğŸ“¸ æ‹ç…§/ä¸Šå‚³åƒ¹æ ¼æ¨™ç±¤é€²è¡Œ OCR'}
                        </button>
                        
                        {/* Hidden File Input for Image Capture */}
                        <input
                            type="file"
                            accept="image/*"
                            capture="environment" // Hint to use back camera on mobile
                            onChange={handleFileChange}
                            ref={fileInputRef}
                            style={{ display: 'none' }}
                        />

                        {/* Price Record Inputs (Manual/OCR Output) */}
                        <div className="space-y-3 pt-4 border-t">
                             <h3 className="text-lg font-semibold text-gray-700">æ–°å¢ç•¶å‰åƒ¹æ ¼ç´€éŒ„ (å¯æ‰‹å‹•ä¿®æ”¹ OCR çµæœ)</h3>
                            
                            <InputField 
                                label="å•†åº— (Store) - ä¾†è‡ª OCR"
                                value={currentStore}
                                onChange={setCurrentStore}
                                type="text" // Changed from SelectField to allow OCR output
                                placeholder="ä¾‹å¦‚: å®¶æ¨‚ç¦"
                            />
                            <InputField 
                                label="åƒ¹æ ¼ (Price) - ä¾†è‡ª OCR / å¿…å¡«"
                                value={currentPrice}
                                onChange={setCurrentPrice}
                                type="number"
                                placeholder="ä¾‹å¦‚: 99.00"
                            />
                            <InputField 
                                label="å„ªæƒ ç´°ç¯€ (Discount Details) - ä¾†è‡ª OCR"
                                value={currentDiscount}
                                onChange={setCurrentDiscount}
                                type="text"
                                placeholder="ä¾‹å¦‚: è²·ä¸€é€ä¸€, ç¬¬äºŒä»¶å…­æŠ˜"
                            />
                        </div>
                        
                        {/* Comparison Display */}
                        <ComparisonDisplay />

                        <button
                            onClick={savePriceRecord}
                            className={`w-full flex items-center justify-center px-6 py-3 text-base font-medium rounded-lg shadow-lg text-white transition duration-150 ease-in-out transform hover:translate-y-[-2px] bg-green-600 hover:bg-green-700 disabled:bg-gray-400`}
                            disabled={!currentPrice.trim() || isNaN(parseFloat(currentPrice)) || !productName.trim()}
                        >
                            å„²å­˜ç•¶å‰åƒ¹æ ¼ç´€éŒ„ä¸¦æ¯”åƒ¹
                        </button>
                    </div>
                )}
                
                {/* ç‹€æ…‹é¡¯ç¤ºå€ */}
                <div className="pt-4 border-t">
                     <div className={`p-3 text-sm rounded-lg ${
                        statusMessage.includes('å¤±æ•—') ? 'bg-red-100 text-red-800' : 
                        statusMessage.includes('æ³¨æ„') ? 'bg-yellow-100 text-yellow-800' : 
                        statusMessage.includes('å·²è¼‰å…¥') || statusMessage.includes('å®Œæˆ') ? 'bg-green-100 text-green-800' :
                        'bg-blue-100 text-blue-800'
                    }`}>
                        <p className="font-semibold">ç•¶å‰ç‹€æ…‹:</p>
                        <p>{statusMessage}</p>
                    </div>
                </div>
            </div>
        </div>
    );
};

// Simple reusable input component
const InputField = ({ label, value, onChange, type, placeholder }) => (
    <div>
        <label className="block text-sm font-medium text-gray-700">
            {label}
        </label>
        <input
            type={type}
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
            placeholder={placeholder}
        />
    </div>
);

// SelectField is no longer used for Store, changed to InputField for direct OCR output.
// Kept here for reference but removed from the main component's render.
const SelectField = ({ label, value, onChange, options }) => (
    <div>
        <label className="block text-sm font-medium text-gray-700">
            {label}
        </label>
        <select
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white"
        >
            {options.map((option) => (
                <option key={option} value={option}>
                    {option}
                </option>
            ))}
        </select>
    </div>
);

export default App;
